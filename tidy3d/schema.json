{
  "title": "Simulation",
  "description": "Contains all information about Tidy3d simulation.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat] = None\n    [units = um].  Size in x, y, and z directions.\nrun_time : PositiveFloat = None\n    [units = sec].  Total electromagnetic evolution time in seconds. Note: If simulation 'shutoff' is specified, simulation will terminate early when shutoff condition met. \ngrid_size : Union[GridSpec, Tuple[Union[pydantic.types.PositiveFloat, List[pydantic.types.PositiveFloat]], Union[pydantic.types.PositiveFloat, List[pydantic.types.PositiveFloat]], Union[pydantic.types.PositiveFloat, List[pydantic.types.PositiveFloat]]]] = None\n    [units = um].  NOTE: 'grid_size' has been replaced by 'grid_spec'.\nmedium : Union[Medium, AnisotropicMedium, PECMedium, PoleResidue, Sellmeier, Lorentz, Debye, Drude] = Medium(name=None, frequency_range=None, type='Medium', permittivity=1.0, conductivity=0.0)\n    Background medium of simulation, defaults to vacuum if not specified.\nsymmetry : Tuple[Literal[0, -1, 1], Literal[0, -1, 1], Literal[0, -1, 1]] = (0, 0, 0)\n    Tuple of integers defining reflection symmetry across a plane bisecting the simulation domain normal to the x-, y-, and z-axis, respectvely. Each element can be ``0`` (no symmetry), ``1`` (even, i.e. 'PMC' symmetry) or ``-1`` (odd, i.e. 'PEC' symmetry). Note that the vectorial nature of the fields must be taken into account to correctly determine the symmetry value.\nstructures : List[Structure] = []\n    List of structures present in simulation. Note: Structures defined later in this list override the simulation material properties in regions of spatial overlap.\nsources : List[Union[UniformCurrentSource, PointDipole, GaussianBeam, AstigmaticGaussianBeam, ModeSource, PlaneWave]] = []\n    List of electric current sources injecting fields into the simulation.\nmonitors : List[Union[FieldMonitor, FieldTimeMonitor, PermittivityMonitor, FluxMonitor, FluxTimeMonitor, ModeMonitor, ModeFieldMonitor]] = []\n    List of monitors in the simulation. Note: monitor names are used to access data after simulation is run.\ngrid_spec : GridSpec = GridSpec(grid_x=AutoGrid(type='AutoGrid',, min_steps_per_wvl=10.0,, max_scale=1.4,, mesher=GradedMesher(type='GradedMesher')), grid_y=AutoGrid(type='AutoGrid',, min_steps_per_wvl=10.0,, max_scale=1.4,, mesher=GradedMesher(type='GradedMesher')), grid_z=AutoGrid(type='AutoGrid',, min_steps_per_wvl=10.0,, max_scale=1.4,, mesher=GradedMesher(type='GradedMesher')), wavelength=None, override_structures=[], type='GridSpec')\n    Specifications for the simulation grid along each of the three directions.\npml_layers : Tuple[Union[PML, StablePML, Absorber, NoneType], Union[PML, StablePML, Absorber, NoneType], Union[PML, StablePML, Absorber, NoneType]] = (None, None, None)\n    Specifications for the absorbing layers on x, y, and z edges. If ``None``, no absorber will be added on that dimension and periodic boundary conditions will be used.\nshutoff : NonNegativeFloat = 1e-05\n    Ratio of the instantaneous integrated E-field intensity to the maximum value at which the simulation will automatically terminate time stepping. Used to prevent extraneous run time of simulations with fully decayed fields. Set to ``0`` to disable this feature.\nsubpixel : bool = True\n    If ``True``, uses subpixel averaging of the permittivity based on structure definition, resulting in much higher accuracy for a given grid size.\ncourant : ConstrainedFloatValue = 0.9\n    Courant stability factor, controls time step to spatial step ratio. Lower values lead to more stable simulations for dispersive materials, but result in longer simulation times.\nversion : str = 1.3.3\n    String specifying the front end version number.\n\nExample\n-------\n>>> from tidy3d import Sphere, Cylinder, PolySlab\n>>> from tidy3d import UniformCurrentSource, GaussianPulse\n>>> from tidy3d import FieldMonitor, FluxMonitor\n>>> from tidy3d import GridSpec, AutoGrid\n>>> sim = Simulation(\n...     size=(2.0, 2.0, 2.0),\n...     grid_spec=GridSpec(\n...         grid_x = AutoGrid(min_steps_per_wvl = 20),\n...         grid_y = AutoGrid(min_steps_per_wvl = 20),\n...         grid_z = AutoGrid(min_steps_per_wvl = 20)\n...     ),\n...     run_time=40e-11,\n...     structures=[\n...         Structure(\n...             geometry=Box(size=(1, 1, 1), center=(-1, 0, 0)),\n...             medium=Medium(permittivity=2.0),\n...         ),\n...     ],\n...     sources=[\n...         UniformCurrentSource(\n...             size=(0, 0, 0),\n...             center=(0, 0.5, 0),\n...             polarization=\"Hx\",\n...             source_time=GaussianPulse(\n...                 freq0=2e14,\n...                 fwidth=4e13,\n...             ),\n...         )\n...     ],\n...     monitors=[\n...         FieldMonitor(size=(0, 0, 0), center=(0, 0, 0), freqs=[1.5e14, 2e14], name='point'),\n...         FluxMonitor(size=(1, 1, 0), center=(0, 0, 0), freqs=[2e14, 2.5e14], name='flux'),\n...     ],\n...     symmetry=(0, 0, 0),\n...     pml_layers=(\n...         PML(num_layers=20),\n...         PML(num_layers=30),\n...         None,\n...     ),\n...     shutoff=1e-6,\n...     courant=0.8,\n...     subpixel=False,\n... )",
  "type": "object",
  "properties": {
    "center": {
      "title": "Center",
      "description": "Center of object in x, y, and z.",
      "default": [
        0.0,
        0.0,
        0.0
      ],
      "units": "um",
      "type": "array",
      "minItems": 3,
      "maxItems": 3,
      "items": [
        {
          "type": "number"
        },
        {
          "type": "number"
        },
        {
          "type": "number"
        }
      ]
    },
    "type": {
      "title": "Type",
      "default": "Simulation",
      "enum": [
        "Simulation"
      ],
      "type": "string"
    },
    "size": {
      "title": "Size",
      "description": "Size in x, y, and z directions.",
      "units": "um",
      "type": "array",
      "minItems": 3,
      "maxItems": 3,
      "items": [
        {
          "type": "number",
          "minimum": 0
        },
        {
          "type": "number",
          "minimum": 0
        },
        {
          "type": "number",
          "minimum": 0
        }
      ]
    },
    "run_time": {
      "title": "Run Time",
      "description": "Total electromagnetic evolution time in seconds. Note: If simulation 'shutoff' is specified, simulation will terminate early when shutoff condition met. ",
      "units": "sec",
      "exclusiveMinimum": 0,
      "type": "number"
    },
    "grid_size": {
      "title": "Grid Size",
      "description": "NOTE: 'grid_size' has been replaced by 'grid_spec'.",
      "units": "um",
      "anyOf": [
        {
          "$ref": "#/definitions/GridSpec"
        },
        {
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "anyOf": [
                {
                  "type": "number",
                  "exclusiveMinimum": 0
                },
                {
                  "type": "array",
                  "items": {
                    "type": "number",
                    "exclusiveMinimum": 0
                  }
                }
              ]
            },
            {
              "anyOf": [
                {
                  "type": "number",
                  "exclusiveMinimum": 0
                },
                {
                  "type": "array",
                  "items": {
                    "type": "number",
                    "exclusiveMinimum": 0
                  }
                }
              ]
            },
            {
              "anyOf": [
                {
                  "type": "number",
                  "exclusiveMinimum": 0
                },
                {
                  "type": "array",
                  "items": {
                    "type": "number",
                    "exclusiveMinimum": 0
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    "medium": {
      "title": "Background Medium",
      "description": "Background medium of simulation, defaults to vacuum if not specified.",
      "default": {
        "name": null,
        "frequency_range": null,
        "type": "Medium",
        "permittivity": 1.0,
        "conductivity": 0.0
      },
      "anyOf": [
        {
          "$ref": "#/definitions/Medium"
        },
        {
          "$ref": "#/definitions/AnisotropicMedium"
        },
        {
          "$ref": "#/definitions/PECMedium"
        },
        {
          "$ref": "#/definitions/PoleResidue"
        },
        {
          "$ref": "#/definitions/Sellmeier"
        },
        {
          "$ref": "#/definitions/Lorentz"
        },
        {
          "$ref": "#/definitions/Debye"
        },
        {
          "$ref": "#/definitions/Drude"
        }
      ]
    },
    "symmetry": {
      "title": "Symmetries",
      "description": "Tuple of integers defining reflection symmetry across a plane bisecting the simulation domain normal to the x-, y-, and z-axis, respectvely. Each element can be ``0`` (no symmetry), ``1`` (even, i.e. 'PMC' symmetry) or ``-1`` (odd, i.e. 'PEC' symmetry). Note that the vectorial nature of the fields must be taken into account to correctly determine the symmetry value.",
      "default": [
        0,
        0,
        0
      ],
      "type": "array",
      "minItems": 3,
      "maxItems": 3,
      "items": [
        {
          "enum": [
            0,
            -1,
            1
          ],
          "type": "integer"
        },
        {
          "enum": [
            0,
            -1,
            1
          ],
          "type": "integer"
        },
        {
          "enum": [
            0,
            -1,
            1
          ],
          "type": "integer"
        }
      ]
    },
    "structures": {
      "title": "Structures",
      "description": "List of structures present in simulation. Note: Structures defined later in this list override the simulation material properties in regions of spatial overlap.",
      "default": [],
      "type": "array",
      "items": {
        "$ref": "#/definitions/Structure"
      }
    },
    "sources": {
      "title": "Sources",
      "description": "List of electric current sources injecting fields into the simulation.",
      "default": [],
      "type": "array",
      "items": {
        "anyOf": [
          {
            "$ref": "#/definitions/UniformCurrentSource"
          },
          {
            "$ref": "#/definitions/PointDipole"
          },
          {
            "$ref": "#/definitions/GaussianBeam"
          },
          {
            "$ref": "#/definitions/AstigmaticGaussianBeam"
          },
          {
            "$ref": "#/definitions/ModeSource"
          },
          {
            "$ref": "#/definitions/PlaneWave"
          }
        ]
      }
    },
    "monitors": {
      "title": "Monitors",
      "description": "List of monitors in the simulation. Note: monitor names are used to access data after simulation is run.",
      "default": [],
      "type": "array",
      "items": {
        "anyOf": [
          {
            "$ref": "#/definitions/FieldMonitor"
          },
          {
            "$ref": "#/definitions/FieldTimeMonitor"
          },
          {
            "$ref": "#/definitions/PermittivityMonitor"
          },
          {
            "$ref": "#/definitions/FluxMonitor"
          },
          {
            "$ref": "#/definitions/FluxTimeMonitor"
          },
          {
            "$ref": "#/definitions/ModeMonitor"
          },
          {
            "$ref": "#/definitions/ModeFieldMonitor"
          }
        ]
      }
    },
    "grid_spec": {
      "title": "Grid Specification",
      "description": "Specifications for the simulation grid along each of the three directions.",
      "default": {
        "grid_x": {
          "type": "AutoGrid",
          "min_steps_per_wvl": 10.0,
          "max_scale": 1.4,
          "mesher": {
            "type": "GradedMesher"
          }
        },
        "grid_y": {
          "type": "AutoGrid",
          "min_steps_per_wvl": 10.0,
          "max_scale": 1.4,
          "mesher": {
            "type": "GradedMesher"
          }
        },
        "grid_z": {
          "type": "AutoGrid",
          "min_steps_per_wvl": 10.0,
          "max_scale": 1.4,
          "mesher": {
            "type": "GradedMesher"
          }
        },
        "wavelength": null,
        "override_structures": [],
        "type": "GridSpec"
      },
      "allOf": [
        {
          "$ref": "#/definitions/GridSpec"
        }
      ]
    },
    "pml_layers": {
      "title": "Absorbing Layers",
      "description": "Specifications for the absorbing layers on x, y, and z edges. If ``None``, no absorber will be added on that dimension and periodic boundary conditions will be used.",
      "default": [
        null,
        null,
        null
      ],
      "type": "array",
      "minItems": 3,
      "maxItems": 3,
      "items": [
        {
          "anyOf": [
            {
              "$ref": "#/definitions/PML"
            },
            {
              "$ref": "#/definitions/StablePML"
            },
            {
              "$ref": "#/definitions/Absorber"
            }
          ]
        },
        {
          "anyOf": [
            {
              "$ref": "#/definitions/PML"
            },
            {
              "$ref": "#/definitions/StablePML"
            },
            {
              "$ref": "#/definitions/Absorber"
            }
          ]
        },
        {
          "anyOf": [
            {
              "$ref": "#/definitions/PML"
            },
            {
              "$ref": "#/definitions/StablePML"
            },
            {
              "$ref": "#/definitions/Absorber"
            }
          ]
        }
      ]
    },
    "shutoff": {
      "title": "Shutoff Condition",
      "description": "Ratio of the instantaneous integrated E-field intensity to the maximum value at which the simulation will automatically terminate time stepping. Used to prevent extraneous run time of simulations with fully decayed fields. Set to ``0`` to disable this feature.",
      "default": 1e-05,
      "minimum": 0,
      "type": "number"
    },
    "subpixel": {
      "title": "Subpixel Averaging",
      "description": "If ``True``, uses subpixel averaging of the permittivity based on structure definition, resulting in much higher accuracy for a given grid size.",
      "default": true,
      "type": "boolean"
    },
    "courant": {
      "title": "Courant Factor",
      "description": "Courant stability factor, controls time step to spatial step ratio. Lower values lead to more stable simulations for dispersive materials, but result in longer simulation times.",
      "default": 0.9,
      "exclusiveMinimum": 0.0,
      "maximum": 1.0,
      "type": "number"
    },
    "version": {
      "title": "Version",
      "description": "String specifying the front end version number.",
      "default": "1.3.3",
      "type": "string"
    }
  },
  "required": [
    "size",
    "run_time"
  ],
  "additionalProperties": false,
  "definitions": {
    "UniformGrid": {
      "title": "UniformGrid",
      "description": "Uniform 1D grid.\n\nParameters\n----------\ndl : PositiveFloat = None\n    [units = um].  Grid size for uniform grid generation.\n\nExample\n-------\n>>> grid_1d = UniformGrid(dl=0.1)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "UniformGrid",
          "enum": [
            "UniformGrid"
          ],
          "type": "string"
        },
        "dl": {
          "title": "Grid Size",
          "description": "Grid size for uniform grid generation.",
          "units": "um",
          "exclusiveMinimum": 0,
          "type": "number"
        }
      },
      "required": [
        "dl"
      ],
      "additionalProperties": false
    },
    "CustomGrid": {
      "title": "CustomGrid",
      "description": "Custom 1D grid supplied as a list of grid cell sizes centered on the simulation center.\n\nParameters\n----------\ndl : List[PositiveFloat] = None\n    [units = um].  An array of custom nonuniform grid sizes. The resulting grid is centered on the simulation center such that it spans the region ``(center - sum(dl)/2, center + sum(dl)/2)``. Note: if supplied sizes do not cover the simulation size, the first and last sizes are repeated to cover the simulation domain.\n\nExample\n-------\n>>> grid_1d = CustomGrid(dl=[0.2, 0.2, 0.1, 0.1, 0.1, 0.2, 0.2])",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "CustomGrid",
          "enum": [
            "CustomGrid"
          ],
          "type": "string"
        },
        "dl": {
          "title": "Customized grid sizes.",
          "description": "An array of custom nonuniform grid sizes. The resulting grid is centered on the simulation center such that it spans the region ``(center - sum(dl)/2, center + sum(dl)/2)``. Note: if supplied sizes do not cover the simulation size, the first and last sizes are repeated to cover the simulation domain.",
          "units": "um",
          "type": "array",
          "items": {
            "type": "number",
            "exclusiveMinimum": 0
          }
        }
      },
      "required": [
        "dl"
      ],
      "additionalProperties": false
    },
    "GradedMesher": {
      "title": "GradedMesher",
      "description": "Implements automatic nonuniform meshing with a set minimum steps per wavelength and\na graded mesh expanding from higher- to lower-resolution regions.\n\nParameters\n----------",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "GradedMesher",
          "enum": [
            "GradedMesher"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "AutoGrid": {
      "title": "AutoGrid",
      "description": "Specification for non-uniform grid along a given dimension.\n\nParameters\n----------\nmin_steps_per_wvl : ConstrainedFloatValue = 10.0\n    Minimal number of steps per wavelength in each medium.\nmax_scale : ConstrainedFloatValue = 1.4\n    Sets the maximum ratio between any two consecutive grid steps.\nmesher : GradedMesher = GradedMesher(type='GradedMesher')\n    The type of mesher to use to generate the grid automatically.\n\nExample\n-------\n>>> grid_1d = AutoGrid(min_steps_per_wvl=16, max_scale=1.4)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "AutoGrid",
          "enum": [
            "AutoGrid"
          ],
          "type": "string"
        },
        "min_steps_per_wvl": {
          "title": "Minimal number of steps per wavelength",
          "description": "Minimal number of steps per wavelength in each medium.",
          "default": 10.0,
          "minimum": 6.0,
          "type": "number"
        },
        "max_scale": {
          "title": "Maximum Grid Size Scaling",
          "description": "Sets the maximum ratio between any two consecutive grid steps.",
          "default": 1.4,
          "exclusiveMaximum": 2.0,
          "minimum": 1.2,
          "type": "number"
        },
        "mesher": {
          "title": "Grid Construction Tool",
          "description": "The type of mesher to use to generate the grid automatically.",
          "default": {
            "type": "GradedMesher"
          },
          "allOf": [
            {
              "$ref": "#/definitions/GradedMesher"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "Box": {
      "title": "Box",
      "description": "Rectangular prism.\n   Also base class for :class:`Simulation`, :class:`Monitor`, and :class:`Source`.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat] = None\n    [units = um].  Size in x, y, and z directions.\n\nExample\n-------\n>>> b = Box(center=(1,2,3), size=(2,2,2))",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Box",
          "enum": [
            "Box"
          ],
          "type": "string"
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        }
      },
      "required": [
        "size"
      ],
      "additionalProperties": false
    },
    "Sphere": {
      "title": "Sphere",
      "description": "Spherical geometry.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nradius : NonNegativeFloat = None\n    [units = um].  Radius of geometry.\n\nExample\n-------\n>>> b = Sphere(center=(1,2,3), radius=2)",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Sphere",
          "enum": [
            "Sphere"
          ],
          "type": "string"
        },
        "radius": {
          "title": "Radius",
          "description": "Radius of geometry.",
          "units": "um",
          "minimum": 0,
          "type": "number"
        }
      },
      "required": [
        "radius"
      ],
      "additionalProperties": false
    },
    "Cylinder": {
      "title": "Cylinder",
      "description": "Cylindrical geometry.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\naxis : Literal[0, 1, 2] = 2\n    Specifies dimension of the planar axis (0,1,2) -> (x,y,z).\nlength : NonNegativeFloat = None\n    [units = um].  Defines thickness of cylinder along axis dimension.\nradius : NonNegativeFloat = None\n    [units = um].  Radius of geometry.\n\nExample\n-------\n>>> c = Cylinder(center=(1,2,3), radius=2, length=5, axis=2)",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Cylinder",
          "enum": [
            "Cylinder"
          ],
          "type": "string"
        },
        "axis": {
          "title": "Axis",
          "description": "Specifies dimension of the planar axis (0,1,2) -> (x,y,z).",
          "default": 2,
          "enum": [
            0,
            1,
            2
          ],
          "type": "integer"
        },
        "length": {
          "title": "Length",
          "description": "Defines thickness of cylinder along axis dimension.",
          "units": "um",
          "minimum": 0,
          "type": "number"
        },
        "radius": {
          "title": "Radius",
          "description": "Radius of geometry.",
          "units": "um",
          "minimum": 0,
          "type": "number"
        }
      },
      "required": [
        "length",
        "radius"
      ],
      "additionalProperties": false
    },
    "PolySlab": {
      "title": "PolySlab",
      "description": "Polygon extruded with optional sidewall angle along axis direction.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\naxis : Literal[0, 1, 2] = 2\n    Specifies dimension of the planar axis (0,1,2) -> (x,y,z).\nlength : Optional[NonNegativeFloat] = None\n    [units = um].  Defines thickness of geometry along axis dimension.\nslab_bounds : Tuple[float, float] = None\n    [units = um].  Minimum and maximum positions of the slab along axis dimension.\ndilation : float = 0.0\n    [units = um].  Dilation of the polygon in the base by shifting each edge along its normal outwards direction by a distance; a negative value corresponds to erosion.\nsidewall_angle : ConstrainedFloatValue = 0.0\n    [units = rad].  Angle of the sidewall. ``sidewall_angle=0`` (default) specifies vertical wall, while ``0<sidewall_angle<np.pi/2`` for the base to be larger than the top.\nvertices : Union[List[Tuple[float, float]], tidynumpy] = None\n    [units = um].  List of (d1, d2) defining the 2 dimensional positions of the base polygon face vertices along dimensions parallel to slab normal axis.\n\nExample\n-------\n>>> vertices = np.array([(0,0), (1,0), (1,1)])\n>>> p = PolySlab(vertices=vertices, axis=2, slab_bounds=(-1, 1))",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "PolySlab",
          "enum": [
            "PolySlab"
          ],
          "type": "string"
        },
        "axis": {
          "title": "Axis",
          "description": "Specifies dimension of the planar axis (0,1,2) -> (x,y,z).",
          "default": 2,
          "enum": [
            0,
            1,
            2
          ],
          "type": "integer"
        },
        "length": {
          "title": "Length",
          "description": "Defines thickness of geometry along axis dimension.",
          "units": "um",
          "minimum": 0,
          "type": "number"
        },
        "slab_bounds": {
          "title": "Slab Bounds",
          "description": "Minimum and maximum positions of the slab along axis dimension.",
          "units": "um",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "dilation": {
          "title": "Dilation",
          "description": "Dilation of the polygon in the base by shifting each edge along its normal outwards direction by a distance; a negative value corresponds to erosion.",
          "default": 0.0,
          "units": "um",
          "type": "number"
        },
        "sidewall_angle": {
          "title": "Sidewall angle",
          "description": "Angle of the sidewall. ``sidewall_angle=0`` (default) specifies vertical wall, while ``0<sidewall_angle<np.pi/2`` for the base to be larger than the top.",
          "default": 0.0,
          "exclusiveMaximum": 1.5707963267948966,
          "minimum": 0.0,
          "units": "rad",
          "type": "number"
        },
        "vertices": {
          "title": "Vertices",
          "description": "List of (d1, d2) defining the 2 dimensional positions of the base polygon face vertices along dimensions parallel to slab normal axis.",
          "units": "um",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "array",
                "minItems": 2,
                "maxItems": 2,
                "items": [
                  {
                    "type": "number"
                  },
                  {
                    "type": "number"
                  }
                ]
              }
            },
            {
              "title": "NumpyArray",
              "description": "Wrapper around numpy arrays that has a well defined json schema.",
              "type": "object",
              "properties": {
                "data_list": {
                  "title": "Data List",
                  "type": "array",
                  "items": {}
                }
              },
              "required": [
                "data_list"
              ]
            }
          ]
        }
      },
      "required": [
        "slab_bounds",
        "vertices"
      ],
      "additionalProperties": false
    },
    "Medium": {
      "title": "Medium",
      "description": "Dispersionless medium.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = Hz].  Optional range of validity for the medium.\npermittivity : ConstrainedFloatValue = 1.0\n    [units = None (relative permittivity)].  Relative permittivity.\nconductivity : ConstrainedFloatValue = 0.0\n    [units = S/m].  Electric conductivity.  Defined such that the imaginary part of the complex permittivity at angular frequency omega is given by conductivity/omega.\n\nExample\n-------\n>>> dielectric = Medium(permittivity=4.0, name='my_medium')\n>>> eps = dielectric.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": "Hz",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Medium",
          "enum": [
            "Medium"
          ],
          "type": "string"
        },
        "permittivity": {
          "title": "Permittivity",
          "description": "Relative permittivity.",
          "default": 1.0,
          "minimum": 1.0,
          "units": "None (relative permittivity)",
          "type": "number"
        },
        "conductivity": {
          "title": "Conductivity",
          "description": "Electric conductivity.  Defined such that the imaginary part of the complex permittivity at angular frequency omega is given by conductivity/omega.",
          "default": 0.0,
          "minimum": 0.0,
          "units": "S/m",
          "type": "number"
        }
      },
      "additionalProperties": false
    },
    "AnisotropicMedium": {
      "title": "AnisotropicMedium",
      "description": "Diagonally anisotripic medium.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = Hz].  Optional range of validity for the medium.\nxx : Medium = None\n    Medium describing the xx-component of the diagonal permittivity tensor.\nyy : Medium = None\n    Medium describing the yy-component of the diagonal permittivity tensor.\nzz : Medium = None\n    Medium describing the zz-component of the diagonal permittivity tensor.\n\nNote\n----\nOnly diagonal anisotropy and non-dispersive components are currently supported.\n\nExample\n-------\n>>> medium_xx = Medium(permittivity=4.0)\n>>> medium_yy = Medium(permittivity=4.1)\n>>> medium_zz = Medium(permittivity=3.9)\n>>> anisotropic_dielectric = AnisotropicMedium(xx=medium_xx, yy=medium_yy, zz=medium_zz)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": "Hz",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "AnisotropicMedium",
          "enum": [
            "AnisotropicMedium"
          ],
          "type": "string"
        },
        "xx": {
          "title": "XX Component",
          "description": "Medium describing the xx-component of the diagonal permittivity tensor.",
          "allOf": [
            {
              "$ref": "#/definitions/Medium"
            }
          ]
        },
        "yy": {
          "title": "YY Component",
          "description": "Medium describing the yy-component of the diagonal permittivity tensor.",
          "allOf": [
            {
              "$ref": "#/definitions/Medium"
            }
          ]
        },
        "zz": {
          "title": "ZZ Component",
          "description": "Medium describing the zz-component of the diagonal permittivity tensor.",
          "allOf": [
            {
              "$ref": "#/definitions/Medium"
            }
          ]
        }
      },
      "required": [
        "xx",
        "yy",
        "zz"
      ],
      "additionalProperties": false
    },
    "PECMedium": {
      "title": "PECMedium",
      "description": "Perfect electrical conductor class.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = Hz].  Optional range of validity for the medium.\n\nNote\n----\nTo avoid confusion from duplicate PECs, should import ``tidy3d.PEC`` instance directly.",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": "Hz",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "PECMedium",
          "enum": [
            "PECMedium"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "ComplexNumber": {
      "title": "ComplexNumber",
      "description": "Complex number with a well defined schema.",
      "type": "object",
      "properties": {
        "real": {
          "title": "Real",
          "type": "number"
        },
        "imag": {
          "title": "Imag",
          "type": "number"
        }
      },
      "required": [
        "real",
        "imag"
      ]
    },
    "PoleResidue": {
      "title": "PoleResidue",
      "description": "A dispersive medium described by the pole-residue pair model.\nThe frequency-dependence of the complex-valued permittivity is described by:\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = Hz].  Optional range of validity for the medium.\neps_inf : float = 1.0\n    Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\npoles : List[Tuple[Union[tidy3d.components.types.tidycomplex, tidy3d.components.types.ComplexNumber], Union[tidy3d.components.types.tidycomplex, tidy3d.components.types.ComplexNumber]]] = []\n    [units = rad/sec].  List of complex-valued (:math:`a_i, c_i`) poles for the model.\n\nNote\n----\n.. math::\n\n    \\epsilon(\\omega) = \\epsilon_\\infty - \\sum_i\n    \\left[\\frac{c_i}{j \\omega + a_i} +\n    \\frac{c_i^*}{j \\omega + a_i^*}\\right]\n\nExample\n-------\n>>> pole_res = PoleResidue(eps_inf=2.0, poles=[((1+2j), (3+4j)), ((5+6j), (7+8j))])\n>>> eps = pole_res.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": "Hz",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "PoleResidue",
          "enum": [
            "PoleResidue"
          ],
          "type": "string"
        },
        "eps_inf": {
          "title": "Epsilon at Infinity",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "default": 1.0,
          "type": "number"
        },
        "poles": {
          "title": "Poles",
          "description": "List of complex-valued (:math:`a_i, c_i`) poles for the model.",
          "default": [],
          "units": "rad/sec",
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "anyOf": [
                  {
                    "title": "ComplexNumber",
                    "description": "Complex number with a well defined schema.",
                    "type": "object",
                    "properties": {
                      "real": {
                        "title": "Real",
                        "type": "number"
                      },
                      "imag": {
                        "title": "Imag",
                        "type": "number"
                      }
                    },
                    "required": [
                      "real",
                      "imag"
                    ]
                  },
                  {
                    "$ref": "#/definitions/ComplexNumber"
                  }
                ]
              },
              {
                "anyOf": [
                  {
                    "title": "ComplexNumber",
                    "description": "Complex number with a well defined schema.",
                    "type": "object",
                    "properties": {
                      "real": {
                        "title": "Real",
                        "type": "number"
                      },
                      "imag": {
                        "title": "Imag",
                        "type": "number"
                      }
                    },
                    "required": [
                      "real",
                      "imag"
                    ]
                  },
                  {
                    "$ref": "#/definitions/ComplexNumber"
                  }
                ]
              }
            ]
          }
        }
      },
      "additionalProperties": false
    },
    "Sellmeier": {
      "title": "Sellmeier",
      "description": "A dispersive medium described by the Sellmeier model.\nThe frequency-dependence of the refractive index is described by:\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = Hz].  Optional range of validity for the medium.\ncoeffs : List[Tuple[float, pydantic.types.PositiveFloat]] = None\n    List of Sellmeier (:math:`B_i, C_i`) coefficients (unitless, microns^2).\n\nNote\n----\n.. math::\n\n    n(\\lambda)^2 = 1 + \\sum_i \\frac{B_i \\lambda^2}{\\lambda^2 - C_i}\n\nExample\n-------\n>>> sellmeier_medium = Sellmeier(coeffs=[(1,2), (3,4)])\n>>> eps = sellmeier_medium.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": "Hz",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Sellmeier",
          "enum": [
            "Sellmeier"
          ],
          "type": "string"
        },
        "coeffs": {
          "title": "Coefficients",
          "description": "List of Sellmeier (:math:`B_i, C_i`) coefficients (unitless, microns^2).",
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "type": "number"
              },
              {
                "type": "number",
                "exclusiveMinimum": 0
              }
            ]
          }
        }
      },
      "required": [
        "coeffs"
      ],
      "additionalProperties": false
    },
    "Lorentz": {
      "title": "Lorentz",
      "description": "A dispersive medium described by the Lorentz model.\nThe frequency-dependence of the complex-valued permittivity is described by:\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = Hz].  Optional range of validity for the medium.\neps_inf : float = 1.0\n    Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\ncoeffs : List[Tuple[float, float, float]] = None\n    List of (:math:`\\Delta\\epsilon_i, f_i, \\delta_i`) values for model (Hz).\n\nNote\n----\n.. math::\n\n    \\epsilon(f) = \\epsilon_\\infty + \\sum_i\n    \\frac{\\Delta\\epsilon_i f_i^2}{f_i^2 - 2jf\\delta_i - f^2}\n\nExample\n-------\n>>> lorentz_medium = Lorentz(eps_inf=2.0, coeffs=[(1,2,3), (4,5,6)])\n>>> eps = lorentz_medium.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": "Hz",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Lorentz",
          "enum": [
            "Lorentz"
          ],
          "type": "string"
        },
        "eps_inf": {
          "title": "Epsilon at Infinity",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "default": 1.0,
          "type": "number"
        },
        "coeffs": {
          "title": "Epsilon at Infinity",
          "description": "List of (:math:`\\Delta\\epsilon_i, f_i, \\delta_i`) values for model (Hz).",
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 3,
            "maxItems": 3,
            "items": [
              {
                "type": "number"
              },
              {
                "type": "number"
              },
              {
                "type": "number"
              }
            ]
          }
        }
      },
      "required": [
        "coeffs"
      ],
      "additionalProperties": false
    },
    "Debye": {
      "title": "Debye",
      "description": "A dispersive medium described by the Debye model.\nThe frequency-dependence of the complex-valued permittivity is described by:\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = Hz].  Optional range of validity for the medium.\neps_inf : float = 1.0\n    Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\ncoeffs : List[Tuple[float, pydantic.types.PositiveFloat]] = None\n    List of (:math:`\\Delta\\epsilon_i, \\tau_i`) values for model (Hz, sec).\n\nNote\n----\n.. math::\n\n    \\epsilon(f) = \\epsilon_\\infty + \\sum_i\n    \\frac{\\Delta\\epsilon_i}{1 - jf\\tau_i}\n\nExample\n-------\n>>> debye_medium = Debye(eps_inf=2.0, coeffs=[(1,2),(3,4)])\n>>> eps = debye_medium.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": "Hz",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Debye",
          "enum": [
            "Debye"
          ],
          "type": "string"
        },
        "eps_inf": {
          "title": "Epsilon at Infinity",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "default": 1.0,
          "type": "number"
        },
        "coeffs": {
          "title": "Coefficients",
          "description": "List of (:math:`\\Delta\\epsilon_i, \\tau_i`) values for model (Hz, sec).",
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "type": "number"
              },
              {
                "type": "number",
                "exclusiveMinimum": 0
              }
            ]
          }
        }
      },
      "required": [
        "coeffs"
      ],
      "additionalProperties": false
    },
    "Drude": {
      "title": "Drude",
      "description": "A dispersive medium described by the Drude model.\nThe frequency-dependence of the complex-valued permittivity is described by:\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = Hz].  Optional range of validity for the medium.\neps_inf : float = 1.0\n    Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\ncoeffs : List[Tuple[float, pydantic.types.PositiveFloat]] = None\n    List of (:math:`f_i, \\delta_i`) values for model (Hz).\n\nNote\n----\n.. math::\n\n    \\epsilon(f) = \\epsilon_\\infty - \\sum_i\n    \\frac{ f_i^2}{f^2 + jf\\delta_i}\n\nExample\n-------\n>>> drude_medium = Drude(eps_inf=2.0, coeffs=[(1,2), (3,4)])\n>>> eps = drude_medium.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": "Hz",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Drude",
          "enum": [
            "Drude"
          ],
          "type": "string"
        },
        "eps_inf": {
          "title": "Epsilon at Infinity",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "default": 1.0,
          "type": "number"
        },
        "coeffs": {
          "title": "Coefficients",
          "description": "List of (:math:`f_i, \\delta_i`) values for model (Hz).",
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "type": "number"
              },
              {
                "type": "number",
                "exclusiveMinimum": 0
              }
            ]
          }
        }
      },
      "required": [
        "coeffs"
      ],
      "additionalProperties": false
    },
    "Structure": {
      "title": "Structure",
      "description": "Defines a physical object that interacts with the electromagnetic fields.\nA :class:`Structure` is a combination of a material property (:class:`AbstractMedium`)\nand a :class:`Geometry`.\n\nParameters\n----------\ngeometry : Union[Box, Sphere, Cylinder, PolySlab] = None\n    Defines geometric properties of the structure.\nmedium : Union[Medium, AnisotropicMedium, PECMedium, PoleResidue, Sellmeier, Lorentz, Debye, Drude] = None\n    Defines the electromagnetic properties of the structure's medium.\nname : Optional[str] = None\n    Optional name for the structure.\n\nExample\n-------\n>>> box = Box(center=(0,0,1), size=(2, 2, 2))\n>>> glass = Medium(permittivity=3.9)\n>>> struct = Structure(geometry=box, medium=glass, name='glass_box')",
      "type": "object",
      "properties": {
        "geometry": {
          "title": "Geometry",
          "description": "Defines geometric properties of the structure.",
          "anyOf": [
            {
              "$ref": "#/definitions/Box"
            },
            {
              "$ref": "#/definitions/Sphere"
            },
            {
              "$ref": "#/definitions/Cylinder"
            },
            {
              "$ref": "#/definitions/PolySlab"
            }
          ]
        },
        "medium": {
          "title": "Medium",
          "description": "Defines the electromagnetic properties of the structure's medium.",
          "anyOf": [
            {
              "$ref": "#/definitions/Medium"
            },
            {
              "$ref": "#/definitions/AnisotropicMedium"
            },
            {
              "$ref": "#/definitions/PECMedium"
            },
            {
              "$ref": "#/definitions/PoleResidue"
            },
            {
              "$ref": "#/definitions/Sellmeier"
            },
            {
              "$ref": "#/definitions/Lorentz"
            },
            {
              "$ref": "#/definitions/Debye"
            },
            {
              "$ref": "#/definitions/Drude"
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Optional name for the structure.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "Structure",
          "enum": [
            "Structure"
          ],
          "type": "string"
        }
      },
      "required": [
        "geometry",
        "medium"
      ],
      "additionalProperties": false
    },
    "GridSpec": {
      "title": "GridSpec",
      "description": "Collective grid specification for all three dimensions.\n\nParameters\n----------\ngrid_x : Union[UniformGrid, CustomGrid, AutoGrid] = AutoGrid(type='AutoGrid', min_steps_per_wvl=10.0, max_scale=1.4, mesher=GradedMesher(type='GradedMesher'))\n    Grid specification along x-axis\ngrid_y : Union[UniformGrid, CustomGrid, AutoGrid] = AutoGrid(type='AutoGrid', min_steps_per_wvl=10.0, max_scale=1.4, mesher=GradedMesher(type='GradedMesher'))\n    Grid specification along y-axis\ngrid_z : Union[UniformGrid, CustomGrid, AutoGrid] = AutoGrid(type='AutoGrid', min_steps_per_wvl=10.0, max_scale=1.4, mesher=GradedMesher(type='GradedMesher'))\n    Grid specification along z-axis\nwavelength : Optional[float] = None\n    [units = um].  Free-space wavelength for automatic nonuniform grid. It can be 'None' if there is at least one source in the simulation, in which case it is defined by the source central frequency.\noverride_structures : List[Structure] = []\n    A list of structures that is added on top of the simulation structures in the process of generating the grid. This can be used to refine the grid or make it coarser depending than the expected need for higher/lower resolution regions.\n\nExample\n-------\n>>> uniform = UniformGrid(dl=0.1)\n>>> custom = CustomGrid(dl=[0.2, 0.2, 0.1, 0.1, 0.1, 0.2, 0.2])\n>>> auto = AutoGrid(min_steps_per_wvl=12)\n>>> grid_spec = GridSpec(grid_x=uniform, grid_y=custom, grid_z=auto, wavelength=1.5)",
      "type": "object",
      "properties": {
        "grid_x": {
          "title": "Grid specification along x-axis",
          "description": "Grid specification along x-axis",
          "default": {
            "type": "AutoGrid",
            "min_steps_per_wvl": 10.0,
            "max_scale": 1.4,
            "mesher": {
              "type": "GradedMesher"
            }
          },
          "anyOf": [
            {
              "$ref": "#/definitions/UniformGrid"
            },
            {
              "$ref": "#/definitions/CustomGrid"
            },
            {
              "$ref": "#/definitions/AutoGrid"
            }
          ]
        },
        "grid_y": {
          "title": "Grid specification along y-axis",
          "description": "Grid specification along y-axis",
          "default": {
            "type": "AutoGrid",
            "min_steps_per_wvl": 10.0,
            "max_scale": 1.4,
            "mesher": {
              "type": "GradedMesher"
            }
          },
          "anyOf": [
            {
              "$ref": "#/definitions/UniformGrid"
            },
            {
              "$ref": "#/definitions/CustomGrid"
            },
            {
              "$ref": "#/definitions/AutoGrid"
            }
          ]
        },
        "grid_z": {
          "title": "Grid specification along z-axis",
          "description": "Grid specification along z-axis",
          "default": {
            "type": "AutoGrid",
            "min_steps_per_wvl": 10.0,
            "max_scale": 1.4,
            "mesher": {
              "type": "GradedMesher"
            }
          },
          "anyOf": [
            {
              "$ref": "#/definitions/UniformGrid"
            },
            {
              "$ref": "#/definitions/CustomGrid"
            },
            {
              "$ref": "#/definitions/AutoGrid"
            }
          ]
        },
        "wavelength": {
          "title": "Free-space wavelength",
          "description": "Free-space wavelength for automatic nonuniform grid. It can be 'None' if there is at least one source in the simulation, in which case it is defined by the source central frequency.",
          "units": "um",
          "type": "number"
        },
        "override_structures": {
          "title": "Grid specification override structures",
          "description": "A list of structures that is added on top of the simulation structures in the process of generating the grid. This can be used to refine the grid or make it coarser depending than the expected need for higher/lower resolution regions.",
          "default": [],
          "type": "array",
          "items": {
            "$ref": "#/definitions/Structure"
          }
        },
        "type": {
          "title": "Type",
          "default": "GridSpec",
          "enum": [
            "GridSpec"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "GaussianPulse": {
      "title": "GaussianPulse",
      "description": "Source time dependence that describes a Gaussian pulse.\n\nParameters\n----------\namplitude : NonNegativeFloat = 1.0\n    Real-valued maximum amplitude of the time dependence.\nphase : float = 0.0\n    [units = rad].  Phase shift of the time dependence.\nfreq0 : PositiveFloat = None\n    [units = Hz].  Central frequency of the pulse.\nfwidth : PositiveFloat = None\n    [units = Hz].  Standard deviation of the frequency content of the pulse.\noffset : ConstrainedFloatValue = 5.0\n    Time delay of the maximum value of the pulse in units of 1 / ``fwidth``.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)",
      "type": "object",
      "properties": {
        "amplitude": {
          "title": "Amplitude",
          "description": "Real-valued maximum amplitude of the time dependence.",
          "default": 1.0,
          "minimum": 0,
          "type": "number"
        },
        "phase": {
          "title": "Phase",
          "description": "Phase shift of the time dependence.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "type": {
          "title": "Type",
          "default": "GaussianPulse",
          "enum": [
            "GaussianPulse"
          ],
          "type": "string"
        },
        "freq0": {
          "title": "Central Frequency",
          "description": "Central frequency of the pulse.",
          "units": "Hz",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "fwidth": {
          "title": "Fwidth",
          "description": "Standard deviation of the frequency content of the pulse.",
          "units": "Hz",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "offset": {
          "title": "Offset",
          "description": "Time delay of the maximum value of the pulse in units of 1 / ``fwidth``.",
          "default": 5.0,
          "minimum": 2.5,
          "type": "number"
        }
      },
      "required": [
        "freq0",
        "fwidth"
      ],
      "additionalProperties": false
    },
    "ContinuousWave": {
      "title": "ContinuousWave",
      "description": "Source time dependence that ramps up to continuous oscillation\nand holds until end of simulation.\n\nParameters\n----------\namplitude : NonNegativeFloat = 1.0\n    Real-valued maximum amplitude of the time dependence.\nphase : float = 0.0\n    [units = rad].  Phase shift of the time dependence.\nfreq0 : PositiveFloat = None\n    [units = Hz].  Central frequency of the pulse.\nfwidth : PositiveFloat = None\n    [units = Hz].  Standard deviation of the frequency content of the pulse.\noffset : ConstrainedFloatValue = 5.0\n    Time delay of the maximum value of the pulse in units of 1 / ``fwidth``.\n\nExample\n-------\n>>> cw = ContinuousWave(freq0=200e12, fwidth=20e12)",
      "type": "object",
      "properties": {
        "amplitude": {
          "title": "Amplitude",
          "description": "Real-valued maximum amplitude of the time dependence.",
          "default": 1.0,
          "minimum": 0,
          "type": "number"
        },
        "phase": {
          "title": "Phase",
          "description": "Phase shift of the time dependence.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "type": {
          "title": "Type",
          "default": "ContinuousWave",
          "enum": [
            "ContinuousWave"
          ],
          "type": "string"
        },
        "freq0": {
          "title": "Central Frequency",
          "description": "Central frequency of the pulse.",
          "units": "Hz",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "fwidth": {
          "title": "Fwidth",
          "description": "Standard deviation of the frequency content of the pulse.",
          "units": "Hz",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "offset": {
          "title": "Offset",
          "description": "Time delay of the maximum value of the pulse in units of 1 / ``fwidth``.",
          "default": 5.0,
          "minimum": 2.5,
          "type": "number"
        }
      },
      "required": [
        "freq0",
        "fwidth"
      ],
      "additionalProperties": false
    },
    "UniformCurrentSource": {
      "title": "UniformCurrentSource",
      "description": "Source in a rectangular volume with uniform time dependence. size=(0,0,0) gives point source.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat] = None\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave] = None\n    Specification of the source time-dependence.\nname : Optional[str] = None\n    Optional name for the source.\npolarization : Literal['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz'] = None\n    Specifies the direction and type of current component.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> pt_source = UniformCurrentSource(size=(0,0,0), source_time=pulse, polarization='Ex')",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "UniformCurrentSource",
          "enum": [
            "UniformCurrentSource"
          ],
          "type": "string"
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "anyOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "polarization": {
          "title": "Polarization",
          "description": "Specifies the direction and type of current component.",
          "enum": [
            "Ex",
            "Ey",
            "Ez",
            "Hx",
            "Hy",
            "Hz"
          ],
          "type": "string"
        }
      },
      "required": [
        "size",
        "source_time",
        "polarization"
      ],
      "additionalProperties": false
    },
    "PointDipole": {
      "title": "PointDipole",
      "description": "Uniform current source with a zero size.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[Literal[0], Literal[0], Literal[0]] = (0, 0, 0)\n        source_time : Union[GaussianPulse, ContinuousWave] = None\n    Specification of the source time-dependence.\nname : Optional[str] = None\n    Optional name for the source.\npolarization : Literal['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz'] = None\n    Specifies the direction and type of current component.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> pt_dipole = PointDipole(center=(1,2,3), source_time=pulse, polarization='Ex')",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "PointDipole",
          "enum": [
            "PointDipole"
          ],
          "type": "string"
        },
        "size": {
          "title": "Size",
          "default": [
            0,
            0,
            0
          ],
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "enum": [
                0
              ],
              "type": "integer"
            },
            {
              "enum": [
                0
              ],
              "type": "integer"
            },
            {
              "enum": [
                0
              ],
              "type": "integer"
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "anyOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "polarization": {
          "title": "Polarization",
          "description": "Specifies the direction and type of current component.",
          "enum": [
            "Ex",
            "Ey",
            "Ez",
            "Hx",
            "Hy",
            "Hz"
          ],
          "type": "string"
        }
      },
      "required": [
        "source_time",
        "polarization"
      ],
      "additionalProperties": false
    },
    "GaussianBeam": {
      "title": "GaussianBeam",
      "description": "Guassian distribution on finite extent plane.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat] = None\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave] = None\n    Specification of the source time-dependence.\nname : Optional[str] = None\n    Optional name for the source.\ndirection : Literal['+', '-'] = None\n    Specifies propagation in the positive or negative direction of the injection axis.\nangle_theta : float = 0.0\n    [units = rad].  Polar angle of the propagation axis from the injection axis.\nangle_phi : float = 0.0\n    [units = rad].  Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.\npol_angle : float = 0\n    [units = rad].  Specifies the angle between the electric field polarization of the source and the plane defined by the injection axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.\nwaist_radius : PositiveFloat = 1.0\n    [units = um].  Radius of the beam at the waist.\nwaist_distance : float = 0.0\n    [units = um].  Distance from the beam waist along the propagation direction.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> gauss = GaussianBeam(\n...     size=(0,3,3),\n...     source_time=pulse,\n...     pol_angle=np.pi / 2,\n...     direction='+',\n...     waist_radius=1.0)",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "GaussianBeam",
          "enum": [
            "GaussianBeam"
          ],
          "type": "string"
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "anyOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "direction": {
          "title": "Direction",
          "description": "Specifies propagation in the positive or negative direction of the injection axis.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "angle_theta": {
          "title": "Polar Angle",
          "description": "Polar angle of the propagation axis from the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "angle_phi": {
          "title": "Azimuth Angle",
          "description": "Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "pol_angle": {
          "title": "Polarization Angle",
          "description": "Specifies the angle between the electric field polarization of the source and the plane defined by the injection axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.",
          "default": 0,
          "units": "rad",
          "type": "number"
        },
        "waist_radius": {
          "title": "Waist Radius",
          "description": "Radius of the beam at the waist.",
          "default": 1.0,
          "units": "um",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "waist_distance": {
          "title": "Waist Distance",
          "description": "Distance from the beam waist along the propagation direction.",
          "default": 0.0,
          "units": "um",
          "type": "number"
        }
      },
      "required": [
        "size",
        "source_time",
        "direction"
      ],
      "additionalProperties": false
    },
    "AstigmaticGaussianBeam": {
      "title": "AstigmaticGaussianBeam",
      "description": "This class implements the simple astigmatic Gaussian beam described in Kochkina et al.,\nApplied Optics, vol. 52, issue 24, 2013. The simple astigmatic Guassian distribution allows\nboth an elliptical intensity profile and different waist locations for the two principal axes\nof the ellipse. When equal waist sizes and equal waist distances are specified in the two\ndirections, this source becomes equivalent to :class:`GaussianBeam`.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat] = None\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave] = None\n    Specification of the source time-dependence.\nname : Optional[str] = None\n    Optional name for the source.\ndirection : Literal['+', '-'] = None\n    Specifies propagation in the positive or negative direction of the injection axis.\nangle_theta : float = 0.0\n    [units = rad].  Polar angle of the propagation axis from the injection axis.\nangle_phi : float = 0.0\n    [units = rad].  Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.\npol_angle : float = 0\n    [units = rad].  Specifies the angle between the electric field polarization of the source and the plane defined by the injection axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.\nwaist_sizes : Tuple[PositiveFloat, PositiveFloat] = (1.0, 1.0)\n    [units = um].  Size of the beam at the waist in the local x and y directions.\nwaist_distances : Tuple[float, float] = (0.0, 0.0)\n    [units = um].  Distance to the beam waist along the propagation direction for the waist sizes in the local x and y directions.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> gauss = AstigmaticGaussianBeam(\n...     size=(0,3,3),\n...     source_time=pulse,\n...     pol_angle=np.pi / 2,\n...     direction='+',\n...     waist_sizes=(1.0, 2.0),\n...     waist_distances = (3.0, 4.0))",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "AstigmaticGaussianBeam",
          "enum": [
            "AstigmaticGaussianBeam"
          ],
          "type": "string"
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "anyOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "direction": {
          "title": "Direction",
          "description": "Specifies propagation in the positive or negative direction of the injection axis.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "angle_theta": {
          "title": "Polar Angle",
          "description": "Polar angle of the propagation axis from the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "angle_phi": {
          "title": "Azimuth Angle",
          "description": "Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "pol_angle": {
          "title": "Polarization Angle",
          "description": "Specifies the angle between the electric field polarization of the source and the plane defined by the injection axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.",
          "default": 0,
          "units": "rad",
          "type": "number"
        },
        "waist_sizes": {
          "title": "Waist sizes",
          "description": "Size of the beam at the waist in the local x and y directions.",
          "default": [
            1.0,
            1.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number",
              "exclusiveMinimum": 0
            },
            {
              "type": "number",
              "exclusiveMinimum": 0
            }
          ]
        },
        "waist_distances": {
          "title": "Waist distances",
          "description": "Distance to the beam waist along the propagation direction for the waist sizes in the local x and y directions.",
          "default": [
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        }
      },
      "required": [
        "size",
        "source_time",
        "direction"
      ],
      "additionalProperties": false
    },
    "ModeSpec": {
      "title": "ModeSpec",
      "description": "Stores specifications for the mode solver to find an electromagntic mode.\nNote, the planar axes are found by popping the injection axis from {x,y,z}.\nFor example, if injection axis is y, the planar axes are ordered {x,z}.\n\nParameters\n----------\nnum_modes : PositiveInt = 1\n    Number of modes returned by mode solver.\ntarget_neff : Optional[PositiveFloat] = None\n    Guess for effective index of the mode.\nnum_pml : Tuple[NonNegativeInt, NonNegativeInt] = (0, 0)\n    Number of standard pml layers to add in the two tangential axes.\nsort_by : Literal['largest_neff', 'te_fraction', 'tm_fraction'] = largest_neff\n    The solver will always compute the ``num_modes`` modes closest to the ``target_neff``, but they can be reordered by the largest ``te_fraction``, defined as the integral of the intensity of the E-field component parallel to the first plane axis normalized to the total in-plane E-field intensity. Similarly, ``tm_fraction`` uses the E field component parallel to the second plane axis.\nangle_theta : float = 0.0\n    [units = rad].  Polar angle of the propagation axis from the injection axis.\nangle_phi : float = 0.0\n    [units = rad].  Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.\nbend_radius : Optional[float] = None\n    [units = um].  A curvature radius for simulation of waveguide bends. Can be negative, in which case the mode plane center has a smaller value than the curvature center along the tangential axis perpendicular to the bend axis.\nbend_axis : Optional[Literal[0, 1]] = None\n    Index into the two tangential axes defining the normal to the plane in which the bend lies. This must be provided if ``bend_radius`` is not ``None``. For example, for a ring in the global xy-plane, and a mode plane in either the xz or the yz plane, the ``bend_axis`` is always 1 (the global z axis).\n\nExample\n-------\n>>> mode_spec = ModeSpec(num_modes=3, target_neff=1.5)",
      "type": "object",
      "properties": {
        "num_modes": {
          "title": "Number of modes",
          "description": "Number of modes returned by mode solver.",
          "default": 1,
          "exclusiveMinimum": 0,
          "type": "integer"
        },
        "target_neff": {
          "title": "Target effective index",
          "description": "Guess for effective index of the mode.",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "num_pml": {
          "title": "Number of PML layers",
          "description": "Number of standard pml layers to add in the two tangential axes.",
          "default": [
            0,
            0
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "integer",
              "minimum": 0
            },
            {
              "type": "integer",
              "minimum": 0
            }
          ]
        },
        "sort_by": {
          "title": "Ordering of the returned modes",
          "description": "The solver will always compute the ``num_modes`` modes closest to the ``target_neff``, but they can be reordered by the largest ``te_fraction``, defined as the integral of the intensity of the E-field component parallel to the first plane axis normalized to the total in-plane E-field intensity. Similarly, ``tm_fraction`` uses the E field component parallel to the second plane axis.",
          "default": "largest_neff",
          "enum": [
            "largest_neff",
            "te_fraction",
            "tm_fraction"
          ],
          "type": "string"
        },
        "angle_theta": {
          "title": "Polar Angle",
          "description": "Polar angle of the propagation axis from the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "angle_phi": {
          "title": "Azimuth Angle",
          "description": "Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "bend_radius": {
          "title": "Bend radius",
          "description": "A curvature radius for simulation of waveguide bends. Can be negative, in which case the mode plane center has a smaller value than the curvature center along the tangential axis perpendicular to the bend axis.",
          "units": "um",
          "type": "number"
        },
        "bend_axis": {
          "title": "Bend axis",
          "description": "Index into the two tangential axes defining the normal to the plane in which the bend lies. This must be provided if ``bend_radius`` is not ``None``. For example, for a ring in the global xy-plane, and a mode plane in either the xz or the yz plane, the ``bend_axis`` is always 1 (the global z axis).",
          "enum": [
            0,
            1
          ],
          "type": "integer"
        },
        "type": {
          "title": "Type",
          "default": "ModeSpec",
          "enum": [
            "ModeSpec"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "ModeSource": {
      "title": "ModeSource",
      "description": "Injects current source to excite modal profile on finite extent plane.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat] = None\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave] = None\n    Specification of the source time-dependence.\nname : Optional[str] = None\n    Optional name for the source.\ndirection : Literal['+', '-'] = None\n    Specifies propagation in the positive or negative direction of the injection axis.\nmode_spec : ModeSpec = ModeSpec(num_modes=1, target_neff=None, num_pml=(0,, 0), sort_by='largest_neff', angle_theta=0.0, angle_phi=0.0, bend_radius=None, bend_axis=None, type='ModeSpec')\n    Parameters to feed to mode solver which determine modes measured by monitor.\nmode_index : NonNegativeInt = 0\n    Index into the collection of modes returned by mode solver.  Specifies which mode to inject using this source. If larger than ``mode_spec.num_modes``, ``num_modes`` in the solver will be set to ``mode_index + 1``.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> mode_spec = ModeSpec(target_neff=2.)\n>>> mode_source = ModeSource(\n...     size=(10,10,0),\n...     source_time=pulse,\n...     mode_spec=mode_spec,\n...     mode_index=1,\n...     direction='-')",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "ModeSource",
          "enum": [
            "ModeSource"
          ],
          "type": "string"
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "anyOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "direction": {
          "title": "Direction",
          "description": "Specifies propagation in the positive or negative direction of the injection axis.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "mode_spec": {
          "title": "Mode Specification",
          "description": "Parameters to feed to mode solver which determine modes measured by monitor.",
          "default": {
            "num_modes": 1,
            "target_neff": null,
            "num_pml": [
              0,
              0
            ],
            "sort_by": "largest_neff",
            "angle_theta": 0.0,
            "angle_phi": 0.0,
            "bend_radius": null,
            "bend_axis": null,
            "type": "ModeSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ModeSpec"
            }
          ]
        },
        "mode_index": {
          "title": "Mode Index",
          "description": "Index into the collection of modes returned by mode solver.  Specifies which mode to inject using this source. If larger than ``mode_spec.num_modes``, ``num_modes`` in the solver will be set to ``mode_index + 1``.",
          "default": 0,
          "minimum": 0,
          "type": "integer"
        }
      },
      "required": [
        "size",
        "source_time",
        "direction"
      ],
      "additionalProperties": false
    },
    "PlaneWave": {
      "title": "PlaneWave",
      "description": "Uniform current distribution on an infinite extent plane.  One element of size must be zero.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat] = None\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave] = None\n    Specification of the source time-dependence.\nname : Optional[str] = None\n    Optional name for the source.\ndirection : Literal['+', '-'] = None\n    Specifies propagation in the positive or negative direction of the injection axis.\nangle_theta : float = 0.0\n    [units = rad].  Polar angle of the propagation axis from the injection axis.\nangle_phi : float = 0.0\n    [units = rad].  Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.\npol_angle : float = 0\n    [units = rad].  Specifies the angle between the electric field polarization of the source and the plane defined by the injection axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> pw_source = PlaneWave(size=(inf,0,inf), source_time=pulse, pol_angle=0.1, direction='+')",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "PlaneWave",
          "enum": [
            "PlaneWave"
          ],
          "type": "string"
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "anyOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "direction": {
          "title": "Direction",
          "description": "Specifies propagation in the positive or negative direction of the injection axis.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "angle_theta": {
          "title": "Polar Angle",
          "description": "Polar angle of the propagation axis from the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "angle_phi": {
          "title": "Azimuth Angle",
          "description": "Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "pol_angle": {
          "title": "Polarization Angle",
          "description": "Specifies the angle between the electric field polarization of the source and the plane defined by the injection axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.",
          "default": 0,
          "units": "rad",
          "type": "number"
        }
      },
      "required": [
        "size",
        "source_time",
        "direction"
      ],
      "additionalProperties": false
    },
    "NumpyArray": {
      "title": "NumpyArray",
      "description": "Wrapper around numpy arrays that has a well defined json schema.",
      "type": "object",
      "properties": {
        "data_list": {
          "title": "Data List",
          "type": "array",
          "items": {}
        }
      },
      "required": [
        "data_list"
      ]
    },
    "FieldMonitor": {
      "title": "FieldMonitor",
      "description": ":class:`Monitor` that records electromagnetic fields in the frequency domain.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat] = None\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue = None\n    Unique name for monitor.\nfreqs : Union[List[float], tidynumpy, NumpyArray, List] = None\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\nfields : List[Literal['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']] = ['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']\n    Collection of field components to store in the monitor.\n\nExample\n-------\n>>> monitor = FieldMonitor(\n...     center=(1,2,3),\n...     size=(2,2,2),\n...     fields=['Hx'],\n...     freqs=[250e12, 300e12],\n...     name='steady_state_monitor')",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "FieldMonitor",
          "enum": [
            "FieldMonitor"
          ],
          "type": "string"
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "title": "NumpyArray",
              "description": "Wrapper around numpy arrays that has a well defined json schema.",
              "type": "object",
              "properties": {
                "data_list": {
                  "title": "Data List",
                  "type": "array",
                  "items": {}
                }
              },
              "required": [
                "data_list"
              ]
            },
            {
              "$ref": "#/definitions/NumpyArray"
            },
            {
              "type": "array",
              "items": {}
            }
          ]
        },
        "fields": {
          "title": "Field Components",
          "description": "Collection of field components to store in the monitor.",
          "default": [
            "Ex",
            "Ey",
            "Ez",
            "Hx",
            "Hy",
            "Hz"
          ],
          "type": "array",
          "items": {
            "enum": [
              "Ex",
              "Ey",
              "Ez",
              "Hx",
              "Hy",
              "Hz"
            ],
            "type": "string"
          }
        }
      },
      "required": [
        "size",
        "name",
        "freqs"
      ],
      "additionalProperties": false
    },
    "FieldTimeMonitor": {
      "title": "FieldTimeMonitor",
      "description": ":class:`Monitor` that records electromagnetic fields in the time domain.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat] = None\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue = None\n    Unique name for monitor.\nstart : NonNegativeFloat = 0.0\n    [units = sec].  Time at which to start monitor recording.\nstop : Optional[NonNegativeFloat] = None\n    [units = sec].  Time at which to stop monitor recording.  If not specified, record until end of simulation.\ninterval : PositiveInt = 1\n    Number of time step intervals between monitor recordings.\nfields : List[Literal['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']] = ['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']\n    Collection of field components to store in the monitor.\n\nExample\n-------\n>>> monitor = FieldTimeMonitor(\n...     center=(1,2,3),\n...     size=(2,2,2),\n...     fields=['Hx'],\n...     start=1e-13,\n...     stop=5e-13,\n...     interval=2,\n...     name='movie_monitor')",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "FieldTimeMonitor",
          "enum": [
            "FieldTimeMonitor"
          ],
          "type": "string"
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "start": {
          "title": "Start time",
          "description": "Time at which to start monitor recording.",
          "default": 0.0,
          "units": "sec",
          "minimum": 0,
          "type": "number"
        },
        "stop": {
          "title": "Stop time",
          "description": "Time at which to stop monitor recording.  If not specified, record until end of simulation.",
          "units": "sec",
          "minimum": 0,
          "type": "number"
        },
        "interval": {
          "title": "Time interval",
          "description": "Number of time step intervals between monitor recordings.",
          "default": 1,
          "exclusiveMinimum": 0,
          "type": "integer"
        },
        "fields": {
          "title": "Field Components",
          "description": "Collection of field components to store in the monitor.",
          "default": [
            "Ex",
            "Ey",
            "Ez",
            "Hx",
            "Hy",
            "Hz"
          ],
          "type": "array",
          "items": {
            "enum": [
              "Ex",
              "Ey",
              "Ez",
              "Hx",
              "Hy",
              "Hz"
            ],
            "type": "string"
          }
        }
      },
      "required": [
        "size",
        "name"
      ],
      "additionalProperties": false
    },
    "PermittivityMonitor": {
      "title": "PermittivityMonitor",
      "description": ":class:`Monitor` that records the diagonal components of the complex-valued relative\npermittivity tensor in the frequency domain. The recorded data has the same shape as a\n:class:`.FieldMonitor` of the same geometry: the permittivity values are saved at the\nYee grid locations, and can be interpolated to any point inside the monitor.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat] = None\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue = None\n    Unique name for monitor.\nfreqs : Union[List[float], tidynumpy, NumpyArray, List] = None\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\n\nExample\n-------\n>>> monitor = PermittivityMonitor(\n...     center=(1,2,3),\n...     size=(2,2,2),\n...     freqs=[250e12, 300e12],\n...     name='eps_monitor')",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "PermittivityMonitor",
          "enum": [
            "PermittivityMonitor"
          ],
          "type": "string"
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "title": "NumpyArray",
              "description": "Wrapper around numpy arrays that has a well defined json schema.",
              "type": "object",
              "properties": {
                "data_list": {
                  "title": "Data List",
                  "type": "array",
                  "items": {}
                }
              },
              "required": [
                "data_list"
              ]
            },
            {
              "$ref": "#/definitions/NumpyArray"
            },
            {
              "type": "array",
              "items": {}
            }
          ]
        }
      },
      "required": [
        "size",
        "name",
        "freqs"
      ],
      "additionalProperties": false
    },
    "FluxMonitor": {
      "title": "FluxMonitor",
      "description": ":class:`Monitor` that records power flux through a plane in the frequency domain.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat] = None\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue = None\n    Unique name for monitor.\nfreqs : Union[List[float], tidynumpy, NumpyArray, List] = None\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\n\nExample\n-------\n>>> monitor = FluxMonitor(\n...     center=(1,2,3),\n...     size=(2,2,0),\n...     freqs=[200e12, 210e12],\n...     name='flux_monitor')",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "FluxMonitor",
          "enum": [
            "FluxMonitor"
          ],
          "type": "string"
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "title": "NumpyArray",
              "description": "Wrapper around numpy arrays that has a well defined json schema.",
              "type": "object",
              "properties": {
                "data_list": {
                  "title": "Data List",
                  "type": "array",
                  "items": {}
                }
              },
              "required": [
                "data_list"
              ]
            },
            {
              "$ref": "#/definitions/NumpyArray"
            },
            {
              "type": "array",
              "items": {}
            }
          ]
        }
      },
      "required": [
        "size",
        "name",
        "freqs"
      ],
      "additionalProperties": false
    },
    "FluxTimeMonitor": {
      "title": "FluxTimeMonitor",
      "description": ":class:`Monitor` that records power flux through a plane in the time domain.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat] = None\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue = None\n    Unique name for monitor.\nstart : NonNegativeFloat = 0.0\n    [units = sec].  Time at which to start monitor recording.\nstop : Optional[NonNegativeFloat] = None\n    [units = sec].  Time at which to stop monitor recording.  If not specified, record until end of simulation.\ninterval : PositiveInt = 1\n    Number of time step intervals between monitor recordings.\n\nExample\n-------\n>>> monitor = FluxTimeMonitor(\n...     center=(1,2,3),\n...     size=(2,2,0),\n...     start=1e-13,\n...     stop=5e-13,\n...     interval=2,\n...     name='flux_vs_time')",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "FluxTimeMonitor",
          "enum": [
            "FluxTimeMonitor"
          ],
          "type": "string"
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "start": {
          "title": "Start time",
          "description": "Time at which to start monitor recording.",
          "default": 0.0,
          "units": "sec",
          "minimum": 0,
          "type": "number"
        },
        "stop": {
          "title": "Stop time",
          "description": "Time at which to stop monitor recording.  If not specified, record until end of simulation.",
          "units": "sec",
          "minimum": 0,
          "type": "number"
        },
        "interval": {
          "title": "Time interval",
          "description": "Number of time step intervals between monitor recordings.",
          "default": 1,
          "exclusiveMinimum": 0,
          "type": "integer"
        }
      },
      "required": [
        "size",
        "name"
      ],
      "additionalProperties": false
    },
    "ModeMonitor": {
      "title": "ModeMonitor",
      "description": ":class:`Monitor` that records amplitudes from modal decomposition of fields on plane.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat] = None\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue = None\n    Unique name for monitor.\nfreqs : Union[List[float], tidynumpy, NumpyArray, List] = None\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\nmode_spec : ModeSpec = None\n    Parameters to feed to mode solver which determine modes measured by monitor.\n\nExample\n-------\n>>> mode_spec = ModeSpec(num_modes=3)\n>>> monitor = ModeMonitor(\n...     center=(1,2,3),\n...     size=(2,2,0),\n...     freqs=[200e12, 210e12],\n...     mode_spec=mode_spec,\n...     name='mode_monitor')",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "ModeMonitor",
          "enum": [
            "ModeMonitor"
          ],
          "type": "string"
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "title": "NumpyArray",
              "description": "Wrapper around numpy arrays that has a well defined json schema.",
              "type": "object",
              "properties": {
                "data_list": {
                  "title": "Data List",
                  "type": "array",
                  "items": {}
                }
              },
              "required": [
                "data_list"
              ]
            },
            {
              "$ref": "#/definitions/NumpyArray"
            },
            {
              "type": "array",
              "items": {}
            }
          ]
        },
        "mode_spec": {
          "title": "Mode Specification",
          "description": "Parameters to feed to mode solver which determine modes measured by monitor.",
          "allOf": [
            {
              "$ref": "#/definitions/ModeSpec"
            }
          ]
        }
      },
      "required": [
        "size",
        "name",
        "freqs",
        "mode_spec"
      ],
      "additionalProperties": false
    },
    "ModeFieldMonitor": {
      "title": "ModeFieldMonitor",
      "description": ":class:`Monitor` that stores the mode field profiles returned by the mode solver in the\nmonitor plane.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat] = None\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue = None\n    Unique name for monitor.\nfreqs : Union[List[float], tidynumpy, NumpyArray, List] = None\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\nmode_spec : ModeSpec = None\n    Parameters to feed to mode solver which determine modes measured by monitor.\n\nExample\n-------\n>>> mode_spec = ModeSpec(num_modes=3)\n>>> monitor = ModeFieldMonitor(\n...     center=(1,2,3),\n...     size=(2,2,0),\n...     freqs=[200e12, 210e12],\n...     mode_spec=mode_spec,\n...     name='mode_monitor')",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "ModeFieldMonitor",
          "enum": [
            "ModeFieldMonitor"
          ],
          "type": "string"
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "title": "NumpyArray",
              "description": "Wrapper around numpy arrays that has a well defined json schema.",
              "type": "object",
              "properties": {
                "data_list": {
                  "title": "Data List",
                  "type": "array",
                  "items": {}
                }
              },
              "required": [
                "data_list"
              ]
            },
            {
              "$ref": "#/definitions/NumpyArray"
            },
            {
              "type": "array",
              "items": {}
            }
          ]
        },
        "mode_spec": {
          "title": "Mode Specification",
          "description": "Parameters to feed to mode solver which determine modes measured by monitor.",
          "allOf": [
            {
              "$ref": "#/definitions/ModeSpec"
            }
          ]
        }
      },
      "required": [
        "size",
        "name",
        "freqs",
        "mode_spec"
      ],
      "additionalProperties": false
    },
    "PMLParams": {
      "title": "PMLParams",
      "description": "Specifies full set of parameters needed for complex, frequency-shifted PML.\n\nParameters\n----------\nsigma_order : NonNegativeInt = 3\n    Order of the polynomial describing the absorber profile (~dist^sigma_order).\nsigma_min : NonNegativeFloat = 0.0\n    [units = 2*EPSILON_0/dt].  Minimum value of the absorber conductivity.\nsigma_max : NonNegativeFloat = 1.5\n    [units = 2*EPSILON_0/dt].  Maximum value of the absorber conductivity.\nkappa_order : NonNegativeInt = 3\n    Order of the polynomial describing the PML kappa profile (kappa~dist^kappa_order).\nkappa_min : NonNegativeFloat = 0.0\n    \nkappa_max : NonNegativeFloat = 1.5\n    \nalpha_order : NonNegativeInt = 3\n    Order of the polynomial describing the PML alpha profile (alpha~dist^alpha_order).\nalpha_min : NonNegativeFloat = 0.0\n    [units = 2*EPSILON_0/dt].  Minimum value of the PML alpha.\nalpha_max : NonNegativeFloat = 1.5\n    [units = 2*EPSILON_0/dt].  Maximum value of the PML alpha.\n\nExample\n-------\n>>> params = PMLParams(sigma_order=3, sigma_min=0.0, sigma_max=1.5, kappa_min=0.0)",
      "type": "object",
      "properties": {
        "sigma_order": {
          "title": "Sigma Order",
          "description": "Order of the polynomial describing the absorber profile (~dist^sigma_order).",
          "default": 3,
          "minimum": 0,
          "type": "integer"
        },
        "sigma_min": {
          "title": "Sigma Minimum",
          "description": "Minimum value of the absorber conductivity.",
          "default": 0.0,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        },
        "sigma_max": {
          "title": "Sigma Maximum",
          "description": "Maximum value of the absorber conductivity.",
          "default": 1.5,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        },
        "type": {
          "title": "Type",
          "default": "PMLParams",
          "enum": [
            "PMLParams"
          ],
          "type": "string"
        },
        "kappa_order": {
          "title": "Kappa Order",
          "description": "Order of the polynomial describing the PML kappa profile (kappa~dist^kappa_order).",
          "default": 3,
          "minimum": 0,
          "type": "integer"
        },
        "kappa_min": {
          "title": "Kappa Minimum",
          "default": 0.0,
          "minimum": 0,
          "type": "number"
        },
        "kappa_max": {
          "title": "Kappa Maximum",
          "default": 1.5,
          "minimum": 0,
          "type": "number"
        },
        "alpha_order": {
          "title": "Alpha Order",
          "description": "Order of the polynomial describing the PML alpha profile (alpha~dist^alpha_order).",
          "default": 3,
          "minimum": 0,
          "type": "integer"
        },
        "alpha_min": {
          "title": "Alpha Minimum",
          "description": "Minimum value of the PML alpha.",
          "default": 0.0,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        },
        "alpha_max": {
          "title": "Alpha Maximum",
          "description": "Maximum value of the PML alpha.",
          "default": 1.5,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        }
      },
      "additionalProperties": false
    },
    "PML": {
      "title": "PML",
      "description": "Specifies a standard PML along a single dimension.\n\nParameters\n----------\nnum_layers : NonNegativeInt = 12\n    Number of layers of standard PML to add to + and - boundaries.\nparameters : PMLParams = PMLParams(sigma_order=3, sigma_min=0.0, sigma_max=1.5, type='PMLParams', kappa_order=3, kappa_min=1.0, kappa_max=3.0, alpha_order=1, alpha_min=0.0, alpha_max=0.0)\n    Parameters of the complex frequency-shifted absorption poles.\n\nExample\n-------\n>>> pml = PML(num_layers=10)",
      "type": "object",
      "properties": {
        "num_layers": {
          "title": "Number of Layers",
          "description": "Number of layers of standard PML to add to + and - boundaries.",
          "default": 12,
          "minimum": 0,
          "type": "integer"
        },
        "parameters": {
          "title": "PML Parameters",
          "description": "Parameters of the complex frequency-shifted absorption poles.",
          "default": {
            "sigma_order": 3,
            "sigma_min": 0.0,
            "sigma_max": 1.5,
            "type": "PMLParams",
            "kappa_order": 3,
            "kappa_min": 1.0,
            "kappa_max": 3.0,
            "alpha_order": 1,
            "alpha_min": 0.0,
            "alpha_max": 0.0
          },
          "allOf": [
            {
              "$ref": "#/definitions/PMLParams"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "PML",
          "enum": [
            "PML"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "StablePML": {
      "title": "StablePML",
      "description": "Specifies a 'stable' PML along a single dimension.\nThis PML deals handles possbly divergent simulations better, but at the expense of more layers.\n\nParameters\n----------\nnum_layers : NonNegativeInt = 40\n    Number of layers of 'stable' PML.\nparameters : PMLParams = PMLParams(sigma_order=3, sigma_min=0.0, sigma_max=1.0, type='PMLParams', kappa_order=3, kappa_min=1.0, kappa_max=5.0, alpha_order=1, alpha_min=0.0, alpha_max=0.9)\n    'Stable' parameters of the complex frequency-shifted absorption poles.\n\nExample\n-------\n>>> pml = StablePML(num_layers=40)",
      "type": "object",
      "properties": {
        "num_layers": {
          "title": "Number of Layers",
          "description": "Number of layers of 'stable' PML.",
          "default": 40,
          "minimum": 0,
          "type": "integer"
        },
        "parameters": {
          "title": "Stable PML Parameters",
          "description": "'Stable' parameters of the complex frequency-shifted absorption poles.",
          "default": {
            "sigma_order": 3,
            "sigma_min": 0.0,
            "sigma_max": 1.0,
            "type": "PMLParams",
            "kappa_order": 3,
            "kappa_min": 1.0,
            "kappa_max": 5.0,
            "alpha_order": 1,
            "alpha_min": 0.0,
            "alpha_max": 0.9
          },
          "allOf": [
            {
              "$ref": "#/definitions/PMLParams"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "StablePML",
          "enum": [
            "StablePML"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "AbsorberParams": {
      "title": "AbsorberParams",
      "description": "Specifies parameters common to Absorbers and PMLs.\n\nParameters\n----------\nsigma_order : NonNegativeInt = 3\n    Order of the polynomial describing the absorber profile (~dist^sigma_order).\nsigma_min : NonNegativeFloat = 0.0\n    [units = 2*EPSILON_0/dt].  Minimum value of the absorber conductivity.\nsigma_max : NonNegativeFloat = 1.5\n    [units = 2*EPSILON_0/dt].  Maximum value of the absorber conductivity.\n\nExample\n-------\n>>> params = AbsorberParams(sigma_order=3, sigma_min=0.0, sigma_max=1.5)",
      "type": "object",
      "properties": {
        "sigma_order": {
          "title": "Sigma Order",
          "description": "Order of the polynomial describing the absorber profile (~dist^sigma_order).",
          "default": 3,
          "minimum": 0,
          "type": "integer"
        },
        "sigma_min": {
          "title": "Sigma Minimum",
          "description": "Minimum value of the absorber conductivity.",
          "default": 0.0,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        },
        "sigma_max": {
          "title": "Sigma Maximum",
          "description": "Maximum value of the absorber conductivity.",
          "default": 1.5,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        },
        "type": {
          "title": "Type",
          "default": "AbsorberParams",
          "enum": [
            "AbsorberParams"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "Absorber": {
      "title": "Absorber",
      "description": "Specifies an adiabatic absorber along a single dimension.\nThis absorber is well-suited for dispersive materials\nintersecting with absorbing edges of the simulation at the expense of more layers.\n\nParameters\n----------\nnum_layers : NonNegativeInt = 40\n    Number of layers of absorber to add to + and - boundaries.\nparameters : AbsorberParams = AbsorberParams(sigma_order=3, sigma_min=0.0, sigma_max=6.4, type='AbsorberParams')\n    Adiabatic absorber parameters.\n\nExample\n-------\n>>> pml = Absorber(num_layers=40)",
      "type": "object",
      "properties": {
        "num_layers": {
          "title": "Number of Layers",
          "description": "Number of layers of absorber to add to + and - boundaries.",
          "default": 40,
          "minimum": 0,
          "type": "integer"
        },
        "parameters": {
          "title": "Absorber Parameters",
          "description": "Adiabatic absorber parameters.",
          "default": {
            "sigma_order": 3,
            "sigma_min": 0.0,
            "sigma_max": 6.4,
            "type": "AbsorberParams"
          },
          "allOf": [
            {
              "$ref": "#/definitions/AbsorberParams"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Absorber",
          "enum": [
            "Absorber"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    }
  }
}
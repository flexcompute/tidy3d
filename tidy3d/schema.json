{
  "title": "Simulation",
  "description": "Contains all information about Tidy3d simulation.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat] = None\n    [units = um].  Size in x, y, and z directions.\ngrid_size : Tuple[Union[PositiveFloat, List[pydantic.types.PositiveFloat]], Union[PositiveFloat, List[pydantic.types.PositiveFloat]], Union[PositiveFloat, List[pydantic.types.PositiveFloat]]] = None\n    [units = um].  If components are float, uniform grid size along x, y, and z. If components are array like, defines an array of nonuniform grid sizes centered at the simulation center . Note: if supplied sizes do not cover the simulation size, the first and last sizes are repeated to cover size. \nmedium : Union[Medium, AnisotropicMedium, PECMedium, PoleResidue, Sellmeier, Lorentz, Debye, Drude] = Medium(name=None, frequency_range=None, type='Medium', permittivity=1.0, conductivity=0.0)\n    Background medium of simulation, defaults to vacuum if not specified.\nrun_time : NonNegativeFloat = 0.0\n    [units = sec].  Total electromagnetic evolution time in seconds. Note: If simulation 'shutoff' is specified, simulation will terminate early when shutoff condition met.\nsymmetry : Tuple[Literal[0, -1, 1], Literal[0, -1, 1], Literal[0, -1, 1]] = (0, 0, 0)\n    Tuple of integers defining reflection symmetry across a plane bisecting the simulation domain normal to the x-, y-, and z-axis, respectvely. Each element can be ``0`` (no symmetry), ``1`` (even, i.e. 'PMC' symmetry) or ``-1`` (odd, i.e. 'PEC' symmetry). Note that the vectorial nature of the fields must be taken into account to correctly determine the symmetry value.\nstructures : List[Structure] = []\n    List of structures present in simulation. Note: Structures defined later in this list override the simulation material properties in regions of spatial overlap.\nsources : List[Union[VolumeSource, PlaneWave, ModeSource, GaussianBeam]] = []\n    List of electric current sources injecting fields into the simulation.\nmonitors : List[Union[FieldMonitor, FieldTimeMonitor, FluxMonitor, FluxTimeMonitor, ModeMonitor]] = []\n    List of monitors in the simulation. Note: monitor names are used to access data after simulation is run.\npml_layers : Tuple[Union[PML, StablePML, Absorber, NoneType], Union[PML, StablePML, Absorber, NoneType], Union[PML, StablePML, Absorber, NoneType]] = (None, None, None)\n    Specifications for the absorbing layers on x, y, and z edges. If ``None``, no absorber will be added on that dimension and periodic boundary conditions will be used.\nshutoff : NonNegativeFloat = 1e-05\n    Ratio of the instantaneous integrated E-field intensity to the maximum value at which the simulation will automatically terminate time stepping. Used to prevent extraneous run time of simulations with fully decayed fields. Set to ``0`` to disable this feature.\nsubpixel : bool = True\n    If ``True``, uses subpixel averaging of the permittivity based on structure definition, resulting in much higher accuracy for a given grid size.\ncourant : ConstrainedFloatValue = 0.9\n    Courant stability factor, controls time step to spatial step ratio. Lower values lead to more stable simulations for dispersive materials, but result in longer simulation times.\nversion : str = 1.1.1\n    String specifying the front end version number.\n\nExample\n-------\n>>> sim = Simulation(\n...     size=(2.0, 2.0, 2.0),\n...     grid_size=(0.1, 0.1, 0.1),\n...     run_time=40e-11,\n...     structures=[\n...         Structure(\n...             geometry=Box(size=(1, 1, 1), center=(-1, 0, 0)),\n...             medium=Medium(permittivity=2.0),\n...         ),\n...     ],\n...     sources=[\n...         VolumeSource(\n...             size=(0, 0, 0),\n...             center=(0, 0.5, 0),\n...             polarization=\"Hx\",\n...             source_time=GaussianPulse(\n...                 freq0=2e14,\n...                 fwidth=4e13,\n...             ),\n...         )\n...     ],\n...     monitors=[\n...         FieldMonitor(size=(0, 0, 0), center=(0, 0, 0), freqs=[1.5e14, 2e14], name='point'),\n...         FluxMonitor(size=(1, 1, 0), center=(0, 0, 0), freqs=[2e14, 2.5e14], name='flux'),\n...     ],\n...     symmetry=(0, 0, 0),\n...     pml_layers=(\n...         PML(num_layers=20),\n...         PML(num_layers=30),\n...         None,\n...     ),\n...     shutoff=1e-6,\n...     courant=0.8,\n...     subpixel=False,\n... )",
  "type": "object",
  "properties": {
    "center": {
      "title": "Center",
      "description": "Center of object in x, y, and z.",
      "default": [
        0.0,
        0.0,
        0.0
      ],
      "units": "um",
      "type": "array",
      "minItems": 3,
      "maxItems": 3,
      "items": [
        {
          "type": "number"
        },
        {
          "type": "number"
        },
        {
          "type": "number"
        }
      ]
    },
    "type": {
      "title": "Type",
      "default": "Simulation",
      "enum": [
        "Simulation"
      ],
      "type": "string"
    },
    "size": {
      "title": "Size",
      "description": "Size in x, y, and z directions.",
      "units": "um",
      "type": "array",
      "minItems": 3,
      "maxItems": 3,
      "items": [
        {
          "type": "number",
          "minimum": 0
        },
        {
          "type": "number",
          "minimum": 0
        },
        {
          "type": "number",
          "minimum": 0
        }
      ]
    },
    "grid_size": {
      "title": "Grid Size",
      "description": "If components are float, uniform grid size along x, y, and z. If components are array like, defines an array of nonuniform grid sizes centered at the simulation center . Note: if supplied sizes do not cover the simulation size, the first and last sizes are repeated to cover size. ",
      "units": "um",
      "type": "array",
      "minItems": 3,
      "maxItems": 3,
      "items": [
        {
          "anyOf": [
            {
              "type": "number",
              "exclusiveMinimum": 0
            },
            {
              "type": "array",
              "items": {
                "type": "number",
                "exclusiveMinimum": 0
              }
            }
          ]
        },
        {
          "anyOf": [
            {
              "type": "number",
              "exclusiveMinimum": 0
            },
            {
              "type": "array",
              "items": {
                "type": "number",
                "exclusiveMinimum": 0
              }
            }
          ]
        },
        {
          "anyOf": [
            {
              "type": "number",
              "exclusiveMinimum": 0
            },
            {
              "type": "array",
              "items": {
                "type": "number",
                "exclusiveMinimum": 0
              }
            }
          ]
        }
      ]
    },
    "medium": {
      "title": "Background Medium",
      "description": "Background medium of simulation, defaults to vacuum if not specified.",
      "default": {
        "name": null,
        "frequency_range": null,
        "type": "Medium",
        "permittivity": 1.0,
        "conductivity": 0.0
      },
      "anyOf": [
        {
          "$ref": "#/definitions/Medium"
        },
        {
          "$ref": "#/definitions/AnisotropicMedium"
        },
        {
          "$ref": "#/definitions/PECMedium"
        },
        {
          "$ref": "#/definitions/PoleResidue"
        },
        {
          "$ref": "#/definitions/Sellmeier"
        },
        {
          "$ref": "#/definitions/Lorentz"
        },
        {
          "$ref": "#/definitions/Debye"
        },
        {
          "$ref": "#/definitions/Drude"
        }
      ]
    },
    "run_time": {
      "title": "Run Time",
      "description": "Total electromagnetic evolution time in seconds. Note: If simulation 'shutoff' is specified, simulation will terminate early when shutoff condition met.",
      "default": 0.0,
      "units": "sec",
      "minimum": 0,
      "type": "number"
    },
    "symmetry": {
      "title": "Symmetries",
      "description": "Tuple of integers defining reflection symmetry across a plane bisecting the simulation domain normal to the x-, y-, and z-axis, respectvely. Each element can be ``0`` (no symmetry), ``1`` (even, i.e. 'PMC' symmetry) or ``-1`` (odd, i.e. 'PEC' symmetry). Note that the vectorial nature of the fields must be taken into account to correctly determine the symmetry value.",
      "default": [
        0,
        0,
        0
      ],
      "type": "array",
      "minItems": 3,
      "maxItems": 3,
      "items": [
        {
          "enum": [
            0,
            -1,
            1
          ],
          "type": "integer"
        },
        {
          "enum": [
            0,
            -1,
            1
          ],
          "type": "integer"
        },
        {
          "enum": [
            0,
            -1,
            1
          ],
          "type": "integer"
        }
      ]
    },
    "structures": {
      "title": "Structures",
      "description": "List of structures present in simulation. Note: Structures defined later in this list override the simulation material properties in regions of spatial overlap.",
      "default": [],
      "type": "array",
      "items": {
        "$ref": "#/definitions/Structure"
      }
    },
    "sources": {
      "title": "Sources",
      "description": "List of electric current sources injecting fields into the simulation.",
      "default": [],
      "type": "array",
      "items": {
        "anyOf": [
          {
            "$ref": "#/definitions/VolumeSource"
          },
          {
            "$ref": "#/definitions/PlaneWave"
          },
          {
            "$ref": "#/definitions/ModeSource"
          },
          {
            "$ref": "#/definitions/GaussianBeam"
          }
        ]
      }
    },
    "monitors": {
      "title": "Monitors",
      "description": "List of monitors in the simulation. Note: monitor names are used to access data after simulation is run.",
      "default": [],
      "type": "array",
      "items": {
        "anyOf": [
          {
            "$ref": "#/definitions/FieldMonitor"
          },
          {
            "$ref": "#/definitions/FieldTimeMonitor"
          },
          {
            "$ref": "#/definitions/FluxMonitor"
          },
          {
            "$ref": "#/definitions/FluxTimeMonitor"
          },
          {
            "$ref": "#/definitions/ModeMonitor"
          }
        ]
      }
    },
    "pml_layers": {
      "title": "Absorbing Layers",
      "description": "Specifications for the absorbing layers on x, y, and z edges. If ``None``, no absorber will be added on that dimension and periodic boundary conditions will be used.",
      "default": [
        null,
        null,
        null
      ],
      "type": "array",
      "minItems": 3,
      "maxItems": 3,
      "items": [
        {
          "anyOf": [
            {
              "$ref": "#/definitions/PML"
            },
            {
              "$ref": "#/definitions/StablePML"
            },
            {
              "$ref": "#/definitions/Absorber"
            }
          ]
        },
        {
          "anyOf": [
            {
              "$ref": "#/definitions/PML"
            },
            {
              "$ref": "#/definitions/StablePML"
            },
            {
              "$ref": "#/definitions/Absorber"
            }
          ]
        },
        {
          "anyOf": [
            {
              "$ref": "#/definitions/PML"
            },
            {
              "$ref": "#/definitions/StablePML"
            },
            {
              "$ref": "#/definitions/Absorber"
            }
          ]
        }
      ]
    },
    "shutoff": {
      "title": "Shutoff Condition",
      "description": "Ratio of the instantaneous integrated E-field intensity to the maximum value at which the simulation will automatically terminate time stepping. Used to prevent extraneous run time of simulations with fully decayed fields. Set to ``0`` to disable this feature.",
      "default": 1e-05,
      "minimum": 0,
      "type": "number"
    },
    "subpixel": {
      "title": "Subpixel Averaging",
      "description": "If ``True``, uses subpixel averaging of the permittivity based on structure definition, resulting in much higher accuracy for a given grid size.",
      "default": true,
      "type": "boolean"
    },
    "courant": {
      "title": "Courant Factor",
      "description": "Courant stability factor, controls time step to spatial step ratio. Lower values lead to more stable simulations for dispersive materials, but result in longer simulation times.",
      "default": 0.9,
      "exclusiveMinimum": 0.0,
      "maximum": 1.0,
      "type": "number"
    },
    "version": {
      "title": "Version",
      "description": "String specifying the front end version number.",
      "default": "1.1.1",
      "type": "string"
    }
  },
  "required": [
    "size",
    "grid_size"
  ],
  "additionalProperties": false,
  "definitions": {
    "Medium": {
      "title": "Medium",
      "description": "Dispersionless medium.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = Hz].  Optional range of validity for the medium.\npermittivity : ConstrainedFloatValue = 1.0\n    [units = None (relative permittivity)].  Relative permittivity.\nconductivity : ConstrainedFloatValue = 0.0\n    [units = S/m].  Electric conductivity.  Defined such that the imaginary part of the complex permittivity at angular frequency omega is given by conductivity/omega.\n\nExample\n-------\n>>> dielectric = Medium(permittivity=4.0, name='my_medium')\n>>> eps = dielectric.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": "Hz",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Medium",
          "enum": [
            "Medium"
          ],
          "type": "string"
        },
        "permittivity": {
          "title": "Permittivity",
          "description": "Relative permittivity.",
          "default": 1.0,
          "minimum": 1.0,
          "units": "None (relative permittivity)",
          "type": "number"
        },
        "conductivity": {
          "title": "Conductivity",
          "description": "Electric conductivity.  Defined such that the imaginary part of the complex permittivity at angular frequency omega is given by conductivity/omega.",
          "default": 0.0,
          "minimum": 0.0,
          "units": "S/m",
          "type": "number"
        }
      },
      "additionalProperties": false
    },
    "AnisotropicMedium": {
      "title": "AnisotropicMedium",
      "description": "Diagonally anisotripic medium.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = Hz].  Optional range of validity for the medium.\nxx : Medium = None\n    Medium describing the xx-component of the diagonal permittivity tensor.\nyy : Medium = None\n    Medium describing the yy-component of the diagonal permittivity tensor.\nzz : Medium = None\n    Medium describing the zz-component of the diagonal permittivity tensor.\n\nNote\n----\nOnly diagonal anisotropy and non-dispersive components are currently supported.\n\nExample\n-------\n>>> medium_xx = Medium(permittivity=4.0)\n>>> medium_yy = Medium(permittivity=4.1)\n>>> medium_zz = Medium(permittivity=3.9)\n>>> anisotropic_dielectric = AnisotropicMedium(xx=medium_xx, yy=medium_yy, zz=medium_zz)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": "Hz",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "AnisotropicMedium",
          "enum": [
            "AnisotropicMedium"
          ],
          "type": "string"
        },
        "xx": {
          "title": "XX Component",
          "description": "Medium describing the xx-component of the diagonal permittivity tensor.",
          "allOf": [
            {
              "$ref": "#/definitions/Medium"
            }
          ]
        },
        "yy": {
          "title": "YY Component",
          "description": "Medium describing the yy-component of the diagonal permittivity tensor.",
          "allOf": [
            {
              "$ref": "#/definitions/Medium"
            }
          ]
        },
        "zz": {
          "title": "ZZ Component",
          "description": "Medium describing the zz-component of the diagonal permittivity tensor.",
          "allOf": [
            {
              "$ref": "#/definitions/Medium"
            }
          ]
        }
      },
      "required": [
        "xx",
        "yy",
        "zz"
      ],
      "additionalProperties": false
    },
    "PECMedium": {
      "title": "PECMedium",
      "description": "Perfect electrical conductor class.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = Hz].  Optional range of validity for the medium.\n\nNote\n----\nTo avoid confusion from duplicate PECs, should import ``tidy3d.PEC`` instance directly.",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": "Hz",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "PECMedium",
          "enum": [
            "PECMedium"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "ComplexNumber": {
      "title": "ComplexNumber",
      "description": "Complex number with a well defined schema.",
      "type": "object",
      "properties": {
        "real": {
          "title": "Real",
          "type": "number"
        },
        "imag": {
          "title": "Imag",
          "type": "number"
        }
      },
      "required": [
        "real",
        "imag"
      ]
    },
    "PoleResidue": {
      "title": "PoleResidue",
      "description": "A dispersive medium described by the pole-residue pair model.\nThe frequency-dependence of the complex-valued permittivity is described by:\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = Hz].  Optional range of validity for the medium.\neps_inf : float = 1.0\n    Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\npoles : List[Tuple[Union[tidy3d.components.types.tidycomplex, tidy3d.components.types.ComplexNumber], Union[tidy3d.components.types.tidycomplex, tidy3d.components.types.ComplexNumber]]] = []\n    [units = rad/sec].  List of complex-valued (:math:`a_i, c_i`) poles for the model.\n\nNote\n----\n.. math::\n\n    \\epsilon(\\omega) = \\epsilon_\\infty - \\sum_i\n    \\left[\\frac{c_i}{j \\omega + a_i} +\n    \\frac{c_i^*}{j \\omega + a_i^*}\\right]\n\nExample\n-------\n>>> pole_res = PoleResidue(eps_inf=2.0, poles=[((1+2j), (3+4j)), ((5+6j), (7+8j))])\n>>> eps = pole_res.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": "Hz",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "PoleResidue",
          "enum": [
            "PoleResidue"
          ],
          "type": "string"
        },
        "eps_inf": {
          "title": "Epsilon at Infinity",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "default": 1.0,
          "type": "number"
        },
        "poles": {
          "title": "Poles",
          "description": "List of complex-valued (:math:`a_i, c_i`) poles for the model.",
          "default": [],
          "units": "rad/sec",
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "anyOf": [
                  {
                    "title": "ComplexNumber",
                    "description": "Complex number with a well defined schema.",
                    "type": "object",
                    "properties": {
                      "real": {
                        "title": "Real",
                        "type": "number"
                      },
                      "imag": {
                        "title": "Imag",
                        "type": "number"
                      }
                    },
                    "required": [
                      "real",
                      "imag"
                    ]
                  },
                  {
                    "$ref": "#/definitions/ComplexNumber"
                  }
                ]
              },
              {
                "anyOf": [
                  {
                    "title": "ComplexNumber",
                    "description": "Complex number with a well defined schema.",
                    "type": "object",
                    "properties": {
                      "real": {
                        "title": "Real",
                        "type": "number"
                      },
                      "imag": {
                        "title": "Imag",
                        "type": "number"
                      }
                    },
                    "required": [
                      "real",
                      "imag"
                    ]
                  },
                  {
                    "$ref": "#/definitions/ComplexNumber"
                  }
                ]
              }
            ]
          }
        }
      },
      "additionalProperties": false
    },
    "Sellmeier": {
      "title": "Sellmeier",
      "description": "A dispersive medium described by the Sellmeier model.\nThe frequency-dependence of the refractive index is described by:\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = Hz].  Optional range of validity for the medium.\ncoeffs : List[Tuple[float, pydantic.types.PositiveFloat]] = None\n    List of Sellmeier (:math:`B_i, C_i`) coefficients (unitless, microns^2).\n\nNote\n----\n.. math::\n\n    n(\\lambda)^2 = 1 + \\sum_i \\frac{B_i \\lambda^2}{\\lambda^2 - C_i}\n\nExample\n-------\n>>> sellmeier_medium = Sellmeier(coeffs=[(1,2), (3,4)])\n>>> eps = sellmeier_medium.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": "Hz",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Sellmeier",
          "enum": [
            "Sellmeier"
          ],
          "type": "string"
        },
        "coeffs": {
          "title": "Coefficients",
          "description": "List of Sellmeier (:math:`B_i, C_i`) coefficients (unitless, microns^2).",
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "type": "number"
              },
              {
                "type": "number",
                "exclusiveMinimum": 0
              }
            ]
          }
        }
      },
      "required": [
        "coeffs"
      ],
      "additionalProperties": false
    },
    "Lorentz": {
      "title": "Lorentz",
      "description": "A dispersive medium described by the Lorentz model.\nThe frequency-dependence of the complex-valued permittivity is described by:\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = Hz].  Optional range of validity for the medium.\neps_inf : float = 1.0\n    Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\ncoeffs : List[Tuple[float, float, float]] = None\n    List of (:math:`\\Delta\\epsilon_i, f_i, \\delta_i`) values for model (Hz).\n\nNote\n----\n.. math::\n\n    \\epsilon(f) = \\epsilon_\\infty + \\sum_i\n    \\frac{\\Delta\\epsilon_i f_i^2}{f_i^2 - 2jf\\delta_i - f^2}\n\nExample\n-------\n>>> lorentz_medium = Lorentz(eps_inf=2.0, coeffs=[(1,2,3), (4,5,6)])\n>>> eps = lorentz_medium.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": "Hz",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Lorentz",
          "enum": [
            "Lorentz"
          ],
          "type": "string"
        },
        "eps_inf": {
          "title": "Epsilon at Infinity",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "default": 1.0,
          "type": "number"
        },
        "coeffs": {
          "title": "Epsilon at Infinity",
          "description": "List of (:math:`\\Delta\\epsilon_i, f_i, \\delta_i`) values for model (Hz).",
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 3,
            "maxItems": 3,
            "items": [
              {
                "type": "number"
              },
              {
                "type": "number"
              },
              {
                "type": "number"
              }
            ]
          }
        }
      },
      "required": [
        "coeffs"
      ],
      "additionalProperties": false
    },
    "Debye": {
      "title": "Debye",
      "description": "A dispersive medium described by the Debye model.\nThe frequency-dependence of the complex-valued permittivity is described by:\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = Hz].  Optional range of validity for the medium.\neps_inf : float = 1.0\n    Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\ncoeffs : List[Tuple[float, pydantic.types.PositiveFloat]] = None\n    List of (:math:`\\Delta\\epsilon_i, \\tau_i`) values for model (Hz, sec).\n\nNote\n----\n.. math::\n\n    \\epsilon(f) = \\epsilon_\\infty + \\sum_i\n    \\frac{\\Delta\\epsilon_i}{1 - jf\\tau_i}\n\nExample\n-------\n>>> debye_medium = Debye(eps_inf=2.0, coeffs=[(1,2),(3,4)])\n>>> eps = debye_medium.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": "Hz",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Debye",
          "enum": [
            "Debye"
          ],
          "type": "string"
        },
        "eps_inf": {
          "title": "Epsilon at Infinity",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "default": 1.0,
          "type": "number"
        },
        "coeffs": {
          "title": "Coefficients",
          "description": "List of (:math:`\\Delta\\epsilon_i, \\tau_i`) values for model (Hz, sec).",
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "type": "number"
              },
              {
                "type": "number",
                "exclusiveMinimum": 0
              }
            ]
          }
        }
      },
      "required": [
        "coeffs"
      ],
      "additionalProperties": false
    },
    "Drude": {
      "title": "Drude",
      "description": "A dispersive medium described by the Drude model.\nThe frequency-dependence of the complex-valued permittivity is described by:\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = Hz].  Optional range of validity for the medium.\neps_inf : float = 1.0\n    Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\ncoeffs : List[Tuple[float, pydantic.types.PositiveFloat]] = None\n    List of (:math:`f_i, \\delta_i`) values for model (Hz).\n\nNote\n----\n.. math::\n\n    \\epsilon(f) = \\epsilon_\\infty - \\sum_i\n    \\frac{ f_i^2}{f^2 + jf\\delta_i}\n\nExample\n-------\n>>> drude_medium = Drude(eps_inf=2.0, coeffs=[(1,2), (3,4)])\n>>> eps = drude_medium.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": "Hz",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Drude",
          "enum": [
            "Drude"
          ],
          "type": "string"
        },
        "eps_inf": {
          "title": "Epsilon at Infinity",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "default": 1.0,
          "type": "number"
        },
        "coeffs": {
          "title": "Coefficients",
          "description": "List of (:math:`f_i, \\delta_i`) values for model (Hz).",
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "type": "number"
              },
              {
                "type": "number",
                "exclusiveMinimum": 0
              }
            ]
          }
        }
      },
      "required": [
        "coeffs"
      ],
      "additionalProperties": false
    },
    "Box": {
      "title": "Box",
      "description": "Rectangular prism.\n   Also base class for :class:`Simulation`, :class:`Monitor`, and :class:`Source`.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat] = None\n    [units = um].  Size in x, y, and z directions.\n\nExample\n-------\n>>> b = Box(center=(1,2,3), size=(2,2,2))",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Box",
          "enum": [
            "Box"
          ],
          "type": "string"
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        }
      },
      "required": [
        "size"
      ],
      "additionalProperties": false
    },
    "Sphere": {
      "title": "Sphere",
      "description": "Spherical geometry.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nradius : NonNegativeFloat = None\n    [units = um].  Radius of geometry.\n\nExample\n-------\n>>> b = Sphere(center=(1,2,3), radius=2)",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Sphere",
          "enum": [
            "Sphere"
          ],
          "type": "string"
        },
        "radius": {
          "title": "Radius",
          "description": "Radius of geometry.",
          "units": "um",
          "minimum": 0,
          "type": "number"
        }
      },
      "required": [
        "radius"
      ],
      "additionalProperties": false
    },
    "Cylinder": {
      "title": "Cylinder",
      "description": "Cylindrical geometry.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\naxis : Literal[0, 1, 2] = 2\n    Specifies dimension of the planar axis (0,1,2) -> (x,y,z).\nlength : NonNegativeFloat = None\n    [units = um].  Defines thickness of cylinder along axis dimension.\nradius : NonNegativeFloat = None\n    [units = um].  Radius of geometry.\n\nExample\n-------\n>>> c = Cylinder(center=(1,2,3), radius=2, length=5, axis=2)",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Cylinder",
          "enum": [
            "Cylinder"
          ],
          "type": "string"
        },
        "axis": {
          "title": "Axis",
          "description": "Specifies dimension of the planar axis (0,1,2) -> (x,y,z).",
          "default": 2,
          "enum": [
            0,
            1,
            2
          ],
          "type": "integer"
        },
        "length": {
          "title": "Length",
          "description": "Defines thickness of cylinder along axis dimension.",
          "units": "um",
          "minimum": 0,
          "type": "number"
        },
        "radius": {
          "title": "Radius",
          "description": "Radius of geometry.",
          "units": "um",
          "minimum": 0,
          "type": "number"
        }
      },
      "required": [
        "length",
        "radius"
      ],
      "additionalProperties": false
    },
    "PolySlab": {
      "title": "PolySlab",
      "description": "Polygon with constant thickness (slab) along axis direction.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\naxis : Literal[0, 1, 2] = 2\n    Specifies dimension of the planar axis (0,1,2) -> (x,y,z).\nlength : Optional[NonNegativeFloat] = None\n    [units = um].  Defines thickness of geometry along axis dimension.\nslab_bounds : Tuple[float, float] = None\n    [units = um].  Minimum and maximum positions of the slab along axis dimension.\nvertices : Union[List[Tuple[float, float]], tidynumpy] = None\n    [units = um].  List of (d1, d2) defining the 2 dimensional positions of the polygon face vertices along dimensions parallel to slab normal axis.\n\nExample\n-------\n>>> vertices = np.array([(0,0), (1,0), (1,1)])\n>>> p = PolySlab(vertices=vertices, axis=2, slab_bounds=(-1, 1))",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "PolySlab",
          "enum": [
            "PolySlab"
          ],
          "type": "string"
        },
        "axis": {
          "title": "Axis",
          "description": "Specifies dimension of the planar axis (0,1,2) -> (x,y,z).",
          "default": 2,
          "enum": [
            0,
            1,
            2
          ],
          "type": "integer"
        },
        "length": {
          "title": "Length",
          "description": "Defines thickness of geometry along axis dimension.",
          "units": "um",
          "minimum": 0,
          "type": "number"
        },
        "slab_bounds": {
          "title": "Slab Bounds",
          "description": "Minimum and maximum positions of the slab along axis dimension.",
          "units": "um",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "vertices": {
          "title": "Vertices",
          "description": "List of (d1, d2) defining the 2 dimensional positions of the polygon face vertices along dimensions parallel to slab normal axis.",
          "units": "um",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "array",
                "minItems": 2,
                "maxItems": 2,
                "items": [
                  {
                    "type": "number"
                  },
                  {
                    "type": "number"
                  }
                ]
              }
            },
            {
              "title": "NumpyArray",
              "description": "Wrapper around numpy arrays that has a well defined json schema.",
              "type": "object",
              "properties": {
                "data_list": {
                  "title": "Data List",
                  "type": "array",
                  "items": {}
                }
              },
              "required": [
                "data_list"
              ]
            }
          ]
        }
      },
      "required": [
        "slab_bounds",
        "vertices"
      ],
      "additionalProperties": false
    },
    "Structure": {
      "title": "Structure",
      "description": "Defines a physical object that interacts with the electromagnetic fields.\nA :class:`Structure` is a combination of a material property (:class:`AbstractMedium`)\nand a :class:`Geometry`.\n\nParameters\n----------\ngeometry : Union[Box, Sphere, Cylinder, PolySlab] = None\n    Defines spatial extent of the structure.\nmedium : Union[Medium, AnisotropicMedium, PECMedium, PoleResidue, Sellmeier, Lorentz, Debye, Drude] = None\n    Defines the electromagnetic properties of the structure material.\nname : Optional[str] = None\n    Optional name for the structure.\n\nExample\n-------\n>>> box = Box(center=(0,0,1), size=(2, 2, 2))\n>>> glass = Medium(permittivity=3.9)\n>>> struct = Structure(geometry=box, medium=glass, name='glass_box')",
      "type": "object",
      "properties": {
        "geometry": {
          "title": "Geometry",
          "description": "Defines spatial extent of the structure.",
          "anyOf": [
            {
              "$ref": "#/definitions/Box"
            },
            {
              "$ref": "#/definitions/Sphere"
            },
            {
              "$ref": "#/definitions/Cylinder"
            },
            {
              "$ref": "#/definitions/PolySlab"
            }
          ]
        },
        "medium": {
          "title": "Medium",
          "description": "Defines the electromagnetic properties of the structure material.",
          "anyOf": [
            {
              "$ref": "#/definitions/Medium"
            },
            {
              "$ref": "#/definitions/AnisotropicMedium"
            },
            {
              "$ref": "#/definitions/PECMedium"
            },
            {
              "$ref": "#/definitions/PoleResidue"
            },
            {
              "$ref": "#/definitions/Sellmeier"
            },
            {
              "$ref": "#/definitions/Lorentz"
            },
            {
              "$ref": "#/definitions/Debye"
            },
            {
              "$ref": "#/definitions/Drude"
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Optional name for the structure.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "Structure",
          "enum": [
            "Structure"
          ],
          "type": "string"
        }
      },
      "required": [
        "geometry",
        "medium"
      ],
      "additionalProperties": false
    },
    "GaussianPulse": {
      "title": "GaussianPulse",
      "description": "Source time dependence that describes a Gaussian pulse.\n\nParameters\n----------\namplitude : NonNegativeFloat = 1.0\n    Real-valued maximum amplitude of the time dependence.\nphase : float = 0.0\n    [units = rad].  Phase shift of the time dependence.\nfreq0 : PositiveFloat = None\n    [units = Hz].  Central frequency of the pulse.\nfwidth : PositiveFloat = None\n    [units = Hz].  Standard deviation of the frequency content of the pulse.\noffset : ConstrainedFloatValue = 5.0\n    Time delay of the maximum value of the pulse in units of 1 / ``fwidth``.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)",
      "type": "object",
      "properties": {
        "amplitude": {
          "title": "Amplitude",
          "description": "Real-valued maximum amplitude of the time dependence.",
          "default": 1.0,
          "minimum": 0,
          "type": "number"
        },
        "phase": {
          "title": "Phase",
          "description": "Phase shift of the time dependence.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "type": {
          "title": "Type",
          "default": "GaussianPulse",
          "enum": [
            "GaussianPulse"
          ],
          "type": "string"
        },
        "freq0": {
          "title": "Central Frequency",
          "description": "Central frequency of the pulse.",
          "units": "Hz",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "fwidth": {
          "title": "Fwidth",
          "description": "Standard deviation of the frequency content of the pulse.",
          "units": "Hz",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "offset": {
          "title": "Offset",
          "description": "Time delay of the maximum value of the pulse in units of 1 / ``fwidth``.",
          "default": 5.0,
          "minimum": 2.5,
          "type": "number"
        }
      },
      "required": [
        "freq0",
        "fwidth"
      ],
      "additionalProperties": false
    },
    "ContinuousWave": {
      "title": "ContinuousWave",
      "description": "Source time dependence that ramps up to continuous oscillation\nand holds until end of simulation.\n\nParameters\n----------\namplitude : NonNegativeFloat = 1.0\n    Real-valued maximum amplitude of the time dependence.\nphase : float = 0.0\n    [units = rad].  Phase shift of the time dependence.\nfreq0 : PositiveFloat = None\n    [units = Hz].  Central frequency of the pulse.\nfwidth : PositiveFloat = None\n    [units = Hz].  Standard deviation of the frequency content of the pulse.\noffset : ConstrainedFloatValue = 5.0\n    Time delay of the maximum value of the pulse in units of 1 / ``fwidth``.\n\nExample\n-------\n>>> cw = ContinuousWave(freq0=200e12, fwidth=20e12)",
      "type": "object",
      "properties": {
        "amplitude": {
          "title": "Amplitude",
          "description": "Real-valued maximum amplitude of the time dependence.",
          "default": 1.0,
          "minimum": 0,
          "type": "number"
        },
        "phase": {
          "title": "Phase",
          "description": "Phase shift of the time dependence.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "type": {
          "title": "Type",
          "default": "ContinuousWave",
          "enum": [
            "ContinuousWave"
          ],
          "type": "string"
        },
        "freq0": {
          "title": "Central Frequency",
          "description": "Central frequency of the pulse.",
          "units": "Hz",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "fwidth": {
          "title": "Fwidth",
          "description": "Standard deviation of the frequency content of the pulse.",
          "units": "Hz",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "offset": {
          "title": "Offset",
          "description": "Time delay of the maximum value of the pulse in units of 1 / ``fwidth``.",
          "default": 5.0,
          "minimum": 2.5,
          "type": "number"
        }
      },
      "required": [
        "freq0",
        "fwidth"
      ],
      "additionalProperties": false
    },
    "VolumeSource": {
      "title": "VolumeSource",
      "description": "Source in a rectangular volume with uniform time dependence. size=(0,0,0) gives point source.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat] = None\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave] = None\n    Specification of the source time-dependence.\nname : Optional[str] = None\n    Optional name for the source.\npolarization : Literal['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz'] = None\n    Specifies the direction and type of current component.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> pt_source = VolumeSource(size=(0,0,0), source_time=pulse, polarization='Ex')",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "VolumeSource",
          "enum": [
            "VolumeSource"
          ],
          "type": "string"
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "anyOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "polarization": {
          "title": "Polarization",
          "description": "Specifies the direction and type of current component.",
          "enum": [
            "Ex",
            "Ey",
            "Ez",
            "Hx",
            "Hy",
            "Hz"
          ],
          "type": "string"
        }
      },
      "required": [
        "size",
        "source_time",
        "polarization"
      ],
      "additionalProperties": false
    },
    "PlaneWave": {
      "title": "PlaneWave",
      "description": "Uniform current distribution on an infinite extent plane.  One element of size must be zero.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat] = None\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave] = None\n    Specification of the source time-dependence.\nname : Optional[str] = None\n    Optional name for the source.\ndirection : Literal['+', '-'] = None\n    Specifies propagation in positive or negative direction of the normal axis.\npol_angle : float = 0\n    [units = rad].  Specifies the angle between the electric field polarization of the source and the plane defined by the normal axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> pw_source = PlaneWave(size=(inf,0,inf), source_time=pulse, pol_angle=0.1, direction='+')",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "PlaneWave",
          "enum": [
            "PlaneWave"
          ],
          "type": "string"
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "anyOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "direction": {
          "title": "Direction",
          "description": "Specifies propagation in positive or negative direction of the normal axis.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "pol_angle": {
          "title": "Polarization Angle",
          "description": "Specifies the angle between the electric field polarization of the source and the plane defined by the normal axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.",
          "default": 0,
          "units": "rad",
          "type": "number"
        }
      },
      "required": [
        "size",
        "source_time",
        "direction"
      ],
      "additionalProperties": false
    },
    "ModeSpec": {
      "title": "ModeSpec",
      "description": "Stores specifications for the mode solver to find an electromagntic mode.\nNote, the planar axes are found by popping the propagation axis from {x,y,z}.\nFor example, if propagation axis is y, the planar axes are ordered {x,z}.\n\nParameters\n----------\nnum_modes : PositiveInt = 1\n    Number of modes returned by mode solver.\ntarget_neff : Optional[PositiveFloat] = None\n    Guess for effective index of the mode.\nnum_pml : Tuple[NonNegativeInt, NonNegativeInt] = (0, 0)\n    Number of standard pml layers to add in the two tangential axes.\nbend_radius : Optional[float] = None\n    [units = um].  A curvature radius for simulation of waveguide bends. Can be negative, in which case the mode plane center has a smaller value than the curvature center along the tangential axis perpendicular to the bend axis.\nbend_axis : Optional[Literal[0, 1]] = None\n    Index into the first two non-propagating axes defining the normal to the plane in which the bend lies. This must be provided if ``bend_radius`` is not ``None``. For example, for a ring in the global xy-plane, and a mode plane in either the xz or the yz plane, the ``bend_axis`` is always 1 (the global z axis).\n\nExample\n-------\n>>> mode_spec = ModeSpec(num_modes=3, target_neff=1.5)",
      "type": "object",
      "properties": {
        "num_modes": {
          "title": "Number of modes",
          "description": "Number of modes returned by mode solver.",
          "default": 1,
          "exclusiveMinimum": 0,
          "type": "integer"
        },
        "target_neff": {
          "title": "Target effective index",
          "description": "Guess for effective index of the mode.",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "num_pml": {
          "title": "Number of PML layers",
          "description": "Number of standard pml layers to add in the two tangential axes.",
          "default": [
            0,
            0
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "integer",
              "minimum": 0
            },
            {
              "type": "integer",
              "minimum": 0
            }
          ]
        },
        "bend_radius": {
          "title": "Bend radius",
          "description": "A curvature radius for simulation of waveguide bends. Can be negative, in which case the mode plane center has a smaller value than the curvature center along the tangential axis perpendicular to the bend axis.",
          "units": "um",
          "type": "number"
        },
        "bend_axis": {
          "title": "Bend axis",
          "description": "Index into the first two non-propagating axes defining the normal to the plane in which the bend lies. This must be provided if ``bend_radius`` is not ``None``. For example, for a ring in the global xy-plane, and a mode plane in either the xz or the yz plane, the ``bend_axis`` is always 1 (the global z axis).",
          "enum": [
            0,
            1
          ],
          "type": "integer"
        },
        "type": {
          "title": "Type",
          "default": "ModeSpec",
          "enum": [
            "ModeSpec"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "ModeSource": {
      "title": "ModeSource",
      "description": "Injects current source to excite modal profile on finite extent plane.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat] = None\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave] = None\n    Specification of the source time-dependence.\nname : Optional[str] = None\n    Optional name for the source.\ndirection : Literal['+', '-'] = None\n    Specifies propagation in positive or negative direction of the normal axis.\nmode_spec : ModeSpec = ModeSpec(num_modes=1, target_neff=None, num_pml=(0,, 0), bend_radius=None, bend_axis=None, type='ModeSpec')\n    Parameters to feed to mode solver which determine modes measured by monitor.\nmode_index : NonNegativeInt = 0\n    Index into the collection of modes returned by mode solver.  Specifies which mode to inject using this source. If larger than ``mode_spec.num_modes``, ``num_modes`` in the solver will be set to ``mode_index + 1``.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> mode_spec = ModeSpec(target_neff=2.)\n>>> mode_source = ModeSource(\n...     size=(10,10,0),\n...     source_time=pulse,\n...     mode_spec=mode_spec,\n...     mode_index=1,\n...     direction='-')",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "ModeSource",
          "enum": [
            "ModeSource"
          ],
          "type": "string"
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "anyOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "direction": {
          "title": "Direction",
          "description": "Specifies propagation in positive or negative direction of the normal axis.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "mode_spec": {
          "title": "Mode Specification",
          "description": "Parameters to feed to mode solver which determine modes measured by monitor.",
          "default": {
            "num_modes": 1,
            "target_neff": null,
            "num_pml": [
              0,
              0
            ],
            "bend_radius": null,
            "bend_axis": null,
            "type": "ModeSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ModeSpec"
            }
          ]
        },
        "mode_index": {
          "title": "Mode Index",
          "description": "Index into the collection of modes returned by mode solver.  Specifies which mode to inject using this source. If larger than ``mode_spec.num_modes``, ``num_modes`` in the solver will be set to ``mode_index + 1``.",
          "default": 0,
          "minimum": 0,
          "type": "integer"
        }
      },
      "required": [
        "size",
        "source_time",
        "direction"
      ],
      "additionalProperties": false
    },
    "GaussianBeam": {
      "title": "GaussianBeam",
      "description": "Guassian distribution on finite extent plane.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat] = None\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave] = None\n    Specification of the source time-dependence.\nname : Optional[str] = None\n    Optional name for the source.\ndirection : Literal['+', '-'] = None\n    Specifies propagation in positive or negative direction of the normal axis.\npol_angle : float = 0\n    [units = rad].  Specifies the angle between the electric field polarization of the source and the plane defined by the normal axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.\nwaist_radius : PositiveFloat = 1.0\n    [units = um].  Radius of the beam at the waist.\nwaist_distance : float = 0.0\n    [units = um].  Distance from the beam waist along the propagation direction.\nangle_theta : float = 0.0\n    [units = rad].  Polar angle from the normal axis.\nangle_phi : float = 0.0\n    [units = rad].  Azimuth angle in the plane orthogonal to the normal axis.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> gauss = GaussianBeam(\n...     size=(0,3,3),\n...     source_time=pulse,\n...     pol_angle=np.pi / 2,\n...     direction='+',\n...     waist_radius=1.0)",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "GaussianBeam",
          "enum": [
            "GaussianBeam"
          ],
          "type": "string"
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "anyOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "direction": {
          "title": "Direction",
          "description": "Specifies propagation in positive or negative direction of the normal axis.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "pol_angle": {
          "title": "Polarization Angle",
          "description": "Specifies the angle between the electric field polarization of the source and the plane defined by the normal axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.",
          "default": 0,
          "units": "rad",
          "type": "number"
        },
        "waist_radius": {
          "title": "Waist Radius",
          "description": "Radius of the beam at the waist.",
          "default": 1.0,
          "units": "um",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "waist_distance": {
          "title": "Waist Distance",
          "description": "Distance from the beam waist along the propagation direction.",
          "default": 0.0,
          "units": "um",
          "type": "number"
        },
        "angle_theta": {
          "title": "Polar Angle",
          "description": "Polar angle from the normal axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "angle_phi": {
          "title": "Azimuth Angle",
          "description": "Azimuth angle in the plane orthogonal to the normal axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        }
      },
      "required": [
        "size",
        "source_time",
        "direction"
      ],
      "additionalProperties": false
    },
    "NumpyArray": {
      "title": "NumpyArray",
      "description": "Wrapper around numpy arrays that has a well defined json schema.",
      "type": "object",
      "properties": {
        "data_list": {
          "title": "Data List",
          "type": "array",
          "items": {}
        }
      },
      "required": [
        "data_list"
      ]
    },
    "FieldMonitor": {
      "title": "FieldMonitor",
      "description": ":class:`Monitor` that records electromagnetic fields in the frequency domain.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat] = None\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue = None\n    Unique name for monitor.\nfreqs : Union[List[float], tidynumpy, NumpyArray, List] = None\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\nfields : List[Literal['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']] = ['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']\n    Collection of field components to store in the monitor.\n\nExample\n-------\n>>> monitor = FieldMonitor(\n...     center=(1,2,3),\n...     size=(2,2,2),\n...     fields=['Hx'],\n...     freqs=[250e12, 300e12],\n...     name='steady_state_monitor')",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "FieldMonitor",
          "enum": [
            "FieldMonitor"
          ],
          "type": "string"
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "title": "NumpyArray",
              "description": "Wrapper around numpy arrays that has a well defined json schema.",
              "type": "object",
              "properties": {
                "data_list": {
                  "title": "Data List",
                  "type": "array",
                  "items": {}
                }
              },
              "required": [
                "data_list"
              ]
            },
            {
              "$ref": "#/definitions/NumpyArray"
            },
            {
              "type": "array",
              "items": {}
            }
          ]
        },
        "fields": {
          "title": "Field Components",
          "description": "Collection of field components to store in the monitor.",
          "default": [
            "Ex",
            "Ey",
            "Ez",
            "Hx",
            "Hy",
            "Hz"
          ],
          "type": "array",
          "items": {
            "enum": [
              "Ex",
              "Ey",
              "Ez",
              "Hx",
              "Hy",
              "Hz"
            ],
            "type": "string"
          }
        }
      },
      "required": [
        "size",
        "name",
        "freqs"
      ],
      "additionalProperties": false
    },
    "FieldTimeMonitor": {
      "title": "FieldTimeMonitor",
      "description": ":class:`Monitor` that records electromagnetic fields in the time domain.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat] = None\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue = None\n    Unique name for monitor.\nstart : NonNegativeFloat = 0.0\n    [units = sec].  Time at which to start monitor recording.\nstop : Optional[NonNegativeFloat] = None\n    [units = sec].  Time at which to stop monitor recording.  If not specified, record until end of simulation.\ninterval : PositiveInt = 1\n    Number of time step intervals between monitor recordings.\nfields : List[Literal['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']] = ['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']\n    Collection of field components to store in the monitor.\n\nExample\n-------\n>>> monitor = FieldTimeMonitor(\n...     center=(1,2,3),\n...     size=(2,2,2),\n...     fields=['Hx'],\n...     start=1e-13,\n...     stop=5e-13,\n...     interval=2,\n...     name='movie_monitor')",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "FieldTimeMonitor",
          "enum": [
            "FieldTimeMonitor"
          ],
          "type": "string"
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "start": {
          "title": "Start time",
          "description": "Time at which to start monitor recording.",
          "default": 0.0,
          "units": "sec",
          "minimum": 0,
          "type": "number"
        },
        "stop": {
          "title": "Stop time",
          "description": "Time at which to stop monitor recording.  If not specified, record until end of simulation.",
          "units": "sec",
          "minimum": 0,
          "type": "number"
        },
        "interval": {
          "title": "Time interval",
          "description": "Number of time step intervals between monitor recordings.",
          "default": 1,
          "exclusiveMinimum": 0,
          "type": "integer"
        },
        "fields": {
          "title": "Field Components",
          "description": "Collection of field components to store in the monitor.",
          "default": [
            "Ex",
            "Ey",
            "Ez",
            "Hx",
            "Hy",
            "Hz"
          ],
          "type": "array",
          "items": {
            "enum": [
              "Ex",
              "Ey",
              "Ez",
              "Hx",
              "Hy",
              "Hz"
            ],
            "type": "string"
          }
        }
      },
      "required": [
        "size",
        "name"
      ],
      "additionalProperties": false
    },
    "FluxMonitor": {
      "title": "FluxMonitor",
      "description": ":class:`Monitor` that records power flux through a plane in the frequency domain.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat] = None\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue = None\n    Unique name for monitor.\nfreqs : Union[List[float], tidynumpy, NumpyArray, List] = None\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\n\nExample\n-------\n>>> monitor = FluxMonitor(\n...     center=(1,2,3),\n...     size=(2,2,0),\n...     freqs=[200e12, 210e12],\n...     name='flux_monitor')",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "FluxMonitor",
          "enum": [
            "FluxMonitor"
          ],
          "type": "string"
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "title": "NumpyArray",
              "description": "Wrapper around numpy arrays that has a well defined json schema.",
              "type": "object",
              "properties": {
                "data_list": {
                  "title": "Data List",
                  "type": "array",
                  "items": {}
                }
              },
              "required": [
                "data_list"
              ]
            },
            {
              "$ref": "#/definitions/NumpyArray"
            },
            {
              "type": "array",
              "items": {}
            }
          ]
        }
      },
      "required": [
        "size",
        "name",
        "freqs"
      ],
      "additionalProperties": false
    },
    "FluxTimeMonitor": {
      "title": "FluxTimeMonitor",
      "description": ":class:`Monitor` that records power flux through a plane in the time domain.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat] = None\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue = None\n    Unique name for monitor.\nstart : NonNegativeFloat = 0.0\n    [units = sec].  Time at which to start monitor recording.\nstop : Optional[NonNegativeFloat] = None\n    [units = sec].  Time at which to stop monitor recording.  If not specified, record until end of simulation.\ninterval : PositiveInt = 1\n    Number of time step intervals between monitor recordings.\n\nExample\n-------\n>>> monitor = FluxTimeMonitor(\n...     center=(1,2,3),\n...     size=(2,2,0),\n...     start=1e-13,\n...     stop=5e-13,\n...     interval=2,\n...     name='flux_vs_time')",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "FluxTimeMonitor",
          "enum": [
            "FluxTimeMonitor"
          ],
          "type": "string"
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "start": {
          "title": "Start time",
          "description": "Time at which to start monitor recording.",
          "default": 0.0,
          "units": "sec",
          "minimum": 0,
          "type": "number"
        },
        "stop": {
          "title": "Stop time",
          "description": "Time at which to stop monitor recording.  If not specified, record until end of simulation.",
          "units": "sec",
          "minimum": 0,
          "type": "number"
        },
        "interval": {
          "title": "Time interval",
          "description": "Number of time step intervals between monitor recordings.",
          "default": 1,
          "exclusiveMinimum": 0,
          "type": "integer"
        }
      },
      "required": [
        "size",
        "name"
      ],
      "additionalProperties": false
    },
    "ModeMonitor": {
      "title": "ModeMonitor",
      "description": ":class:`Monitor` that records amplitudes from modal decomposition of fields on plane.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat] = None\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue = None\n    Unique name for monitor.\nfreqs : Union[List[float], tidynumpy, NumpyArray, List] = None\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\nmode_spec : ModeSpec = None\n    Parameters to feed to mode solver which determine modes measured by monitor.\n\nExample\n-------\n>>> mode_spec = ModeSpec(num_modes=3)\n>>> monitor = ModeMonitor(\n...     center=(1,2,3),\n...     size=(2,2,0),\n...     freqs=[200e12, 210e12],\n...     mode_spec=mode_spec,\n...     name='mode_monitor')",
      "type": "object",
      "properties": {
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "ModeMonitor",
          "enum": [
            "ModeMonitor"
          ],
          "type": "string"
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "title": "NumpyArray",
              "description": "Wrapper around numpy arrays that has a well defined json schema.",
              "type": "object",
              "properties": {
                "data_list": {
                  "title": "Data List",
                  "type": "array",
                  "items": {}
                }
              },
              "required": [
                "data_list"
              ]
            },
            {
              "$ref": "#/definitions/NumpyArray"
            },
            {
              "type": "array",
              "items": {}
            }
          ]
        },
        "mode_spec": {
          "title": "Mode Specification",
          "description": "Parameters to feed to mode solver which determine modes measured by monitor.",
          "allOf": [
            {
              "$ref": "#/definitions/ModeSpec"
            }
          ]
        }
      },
      "required": [
        "size",
        "name",
        "freqs",
        "mode_spec"
      ],
      "additionalProperties": false
    },
    "PMLParams": {
      "title": "PMLParams",
      "description": "Specifies full set of parameters needed for complex, frequency-shifted PML.\n\nParameters\n----------\nsigma_order : NonNegativeInt = 3\n    Order of the polynomial describing the absorber profile (~dist^sigma_order).\nsigma_min : NonNegativeFloat = 0.0\n    [units = 2*EPSILON_0/dt].  Minimum value of the absorber conductivity.\nsigma_max : NonNegativeFloat = 1.5\n    [units = 2*EPSILON_0/dt].  Maximum value of the absorber conductivity.\nkappa_order : NonNegativeInt = 3\n    Order of the polynomial describing the PML kappa profile (kappa~dist^kappa_order).\nkappa_min : NonNegativeFloat = 0.0\n    \nkappa_max : NonNegativeFloat = 1.5\n    \nalpha_order : NonNegativeInt = 3\n    Order of the polynomial describing the PML alpha profile (alpha~dist^alpha_order).\nalpha_min : NonNegativeFloat = 0.0\n    [units = 2*EPSILON_0/dt].  Minimum value of the PML alpha.\nalpha_max : NonNegativeFloat = 1.5\n    [units = 2*EPSILON_0/dt].  Maximum value of the PML alpha.\n\nExample\n-------\n>>> params = PMLParams(sigma_order=3, sigma_min=0.0, sigma_max=1.5, kappa_min=0.0)",
      "type": "object",
      "properties": {
        "sigma_order": {
          "title": "Sigma Order",
          "description": "Order of the polynomial describing the absorber profile (~dist^sigma_order).",
          "default": 3,
          "minimum": 0,
          "type": "integer"
        },
        "sigma_min": {
          "title": "Sigma Minimum",
          "description": "Minimum value of the absorber conductivity.",
          "default": 0.0,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        },
        "sigma_max": {
          "title": "Sigma Maximum",
          "description": "Maximum value of the absorber conductivity.",
          "default": 1.5,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        },
        "type": {
          "title": "Type",
          "default": "PMLParams",
          "enum": [
            "PMLParams"
          ],
          "type": "string"
        },
        "kappa_order": {
          "title": "Kappa Order",
          "description": "Order of the polynomial describing the PML kappa profile (kappa~dist^kappa_order).",
          "default": 3,
          "minimum": 0,
          "type": "integer"
        },
        "kappa_min": {
          "title": "Kappa Minimum",
          "default": 0.0,
          "minimum": 0,
          "type": "number"
        },
        "kappa_max": {
          "title": "Kappa Maximum",
          "default": 1.5,
          "minimum": 0,
          "type": "number"
        },
        "alpha_order": {
          "title": "Alpha Order",
          "description": "Order of the polynomial describing the PML alpha profile (alpha~dist^alpha_order).",
          "default": 3,
          "minimum": 0,
          "type": "integer"
        },
        "alpha_min": {
          "title": "Alpha Minimum",
          "description": "Minimum value of the PML alpha.",
          "default": 0.0,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        },
        "alpha_max": {
          "title": "Alpha Maximum",
          "description": "Maximum value of the PML alpha.",
          "default": 1.5,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        }
      },
      "additionalProperties": false
    },
    "PML": {
      "title": "PML",
      "description": "Specifies a standard PML along a single dimension.\n\nParameters\n----------\nnum_layers : NonNegativeInt = 12\n    Number of layers of standard PML to add to + and - boundaries.\nparameters : PMLParams = PMLParams(sigma_order=3, sigma_min=0.0, sigma_max=1.5, type='PMLParams', kappa_order=3, kappa_min=1.0, kappa_max=3.0, alpha_order=1, alpha_min=0.0, alpha_max=0.0)\n    Parameters of the complex frequency-shifted absorption poles.\n\nExample\n-------\n>>> pml = PML(num_layers=10)",
      "type": "object",
      "properties": {
        "num_layers": {
          "title": "Number of Layers",
          "description": "Number of layers of standard PML to add to + and - boundaries.",
          "default": 12,
          "minimum": 0,
          "type": "integer"
        },
        "parameters": {
          "title": "PML Parameters",
          "description": "Parameters of the complex frequency-shifted absorption poles.",
          "default": {
            "sigma_order": 3,
            "sigma_min": 0.0,
            "sigma_max": 1.5,
            "type": "PMLParams",
            "kappa_order": 3,
            "kappa_min": 1.0,
            "kappa_max": 3.0,
            "alpha_order": 1,
            "alpha_min": 0.0,
            "alpha_max": 0.0
          },
          "allOf": [
            {
              "$ref": "#/definitions/PMLParams"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "PML",
          "enum": [
            "PML"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "StablePML": {
      "title": "StablePML",
      "description": "Specifies a 'stable' PML along a single dimension.\nThis PML deals handles possbly divergent simulations better, but at the expense of more layers.\n\nParameters\n----------\nnum_layers : NonNegativeInt = 40\n    Number of layers of 'stable' PML.\nparameters : PMLParams = PMLParams(sigma_order=3, sigma_min=0.0, sigma_max=1.0, type='PMLParams', kappa_order=3, kappa_min=1.0, kappa_max=5.0, alpha_order=1, alpha_min=0.0, alpha_max=0.9)\n    'Stable' parameters of the complex frequency-shifted absorption poles.\n\nExample\n-------\n>>> pml = StablePML(num_layers=40)",
      "type": "object",
      "properties": {
        "num_layers": {
          "title": "Number of Layers",
          "description": "Number of layers of 'stable' PML.",
          "default": 40,
          "minimum": 0,
          "type": "integer"
        },
        "parameters": {
          "title": "Stable PML Parameters",
          "description": "'Stable' parameters of the complex frequency-shifted absorption poles.",
          "default": {
            "sigma_order": 3,
            "sigma_min": 0.0,
            "sigma_max": 1.0,
            "type": "PMLParams",
            "kappa_order": 3,
            "kappa_min": 1.0,
            "kappa_max": 5.0,
            "alpha_order": 1,
            "alpha_min": 0.0,
            "alpha_max": 0.9
          },
          "allOf": [
            {
              "$ref": "#/definitions/PMLParams"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "StablePML",
          "enum": [
            "StablePML"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "AbsorberParams": {
      "title": "AbsorberParams",
      "description": "Specifies parameters common to Absorbers and PMLs.\n\nParameters\n----------\nsigma_order : NonNegativeInt = 3\n    Order of the polynomial describing the absorber profile (~dist^sigma_order).\nsigma_min : NonNegativeFloat = 0.0\n    [units = 2*EPSILON_0/dt].  Minimum value of the absorber conductivity.\nsigma_max : NonNegativeFloat = 1.5\n    [units = 2*EPSILON_0/dt].  Maximum value of the absorber conductivity.\n\nExample\n-------\n>>> params = AbsorberParams(sigma_order=3, sigma_min=0.0, sigma_max=1.5)",
      "type": "object",
      "properties": {
        "sigma_order": {
          "title": "Sigma Order",
          "description": "Order of the polynomial describing the absorber profile (~dist^sigma_order).",
          "default": 3,
          "minimum": 0,
          "type": "integer"
        },
        "sigma_min": {
          "title": "Sigma Minimum",
          "description": "Minimum value of the absorber conductivity.",
          "default": 0.0,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        },
        "sigma_max": {
          "title": "Sigma Maximum",
          "description": "Maximum value of the absorber conductivity.",
          "default": 1.5,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        },
        "type": {
          "title": "Type",
          "default": "AbsorberParams",
          "enum": [
            "AbsorberParams"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "Absorber": {
      "title": "Absorber",
      "description": "Specifies an adiabatic absorber along a single dimension.\nThis absorber is well-suited for dispersive materials\nintersecting with absorbing edges of the simulation at the expense of more layers.\n\nParameters\n----------\nnum_layers : NonNegativeInt = 40\n    Number of layers of absorber to add to + and - boundaries.\nparameters : AbsorberParams = AbsorberParams(sigma_order=3, sigma_min=0.0, sigma_max=6.4, type='AbsorberParams')\n    Adiabatic absorber parameters.\n\nExample\n-------\n>>> pml = Absorber(num_layers=40)",
      "type": "object",
      "properties": {
        "num_layers": {
          "title": "Number of Layers",
          "description": "Number of layers of absorber to add to + and - boundaries.",
          "default": 40,
          "minimum": 0,
          "type": "integer"
        },
        "parameters": {
          "title": "Absorber Parameters",
          "description": "Adiabatic absorber parameters.",
          "default": {
            "sigma_order": 3,
            "sigma_min": 0.0,
            "sigma_max": 6.4,
            "type": "AbsorberParams"
          },
          "allOf": [
            {
              "$ref": "#/definitions/AbsorberParams"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Absorber",
          "enum": [
            "Absorber"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    }
  }
}
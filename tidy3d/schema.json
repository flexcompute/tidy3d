{
  "title": "Simulation",
  "description": "Custom implementation of Maxwell\u2019s equations which represents the physical model to be solved using the FDTD\nmethod.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nmedium : Union[Medium, AnisotropicMedium, PECMedium, PoleResidue, Sellmeier, Lorentz, Debye, Drude, FullyAnisotropicMedium, CustomMedium, CustomPoleResidue, CustomSellmeier, CustomLorentz, CustomDebye, CustomDrude, CustomAnisotropicMedium, PerturbationMedium, PerturbationPoleResidue] = Medium(name=None, frequency_range=None, allow_gain=False, nonlinear_spec=None, modulation_spec=None, heat_spec=None, type='Medium', permittivity=1.0, conductivity=0.0)\n    Background medium of simulation, defaults to vacuum if not specified.\nstructures : Tuple[Structure, ...] = ()\n    Tuple of structures present in simulation. Note: Structures defined later in this list override the simulation material properties in regions of spatial overlap.\nsymmetry : Tuple[Literal[0, -1, 1], Literal[0, -1, 1], Literal[0, -1, 1]] = (0, 0, 0)\n    Tuple of integers defining reflection symmetry across a plane bisecting the simulation domain normal to the x-, y-, and z-axis at the simulation center of each axis, respectively. Each element can be ``0`` (no symmetry), ``1`` (even, i.e. 'PMC' symmetry) or ``-1`` (odd, i.e. 'PEC' symmetry). Note that the vectorial nature of the fields must be taken into account to correctly determine the symmetry value.\nsources : Tuple[Annotated[Union[tidy3d.components.source.UniformCurrentSource, tidy3d.components.source.PointDipole, tidy3d.components.source.GaussianBeam, tidy3d.components.source.AstigmaticGaussianBeam, tidy3d.components.source.ModeSource, tidy3d.components.source.PlaneWave, tidy3d.components.source.CustomFieldSource, tidy3d.components.source.CustomCurrentSource, tidy3d.components.source.TFSF], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})], ...] = ()\n    Tuple of electric current sources injecting fields into the simulation.\nboundary_spec : BoundarySpec = BoundarySpec(x=Boundary(plus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)),, minus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)),, type='Boundary'), y=Boundary(plus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)),, minus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)),, type='Boundary'), z=Boundary(plus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)),, minus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)),, type='Boundary'), type='BoundarySpec')\n    Specification of boundary conditions along each dimension. If ``None``, PML boundary conditions are applied on all sides.\nmonitors : Tuple[Annotated[Union[tidy3d.components.monitor.FieldMonitor, tidy3d.components.monitor.FieldTimeMonitor, tidy3d.components.monitor.PermittivityMonitor, tidy3d.components.monitor.FluxMonitor, tidy3d.components.monitor.FluxTimeMonitor, tidy3d.components.monitor.ModeMonitor, tidy3d.components.monitor.ModeSolverMonitor, tidy3d.components.monitor.FieldProjectionAngleMonitor, tidy3d.components.monitor.FieldProjectionCartesianMonitor, tidy3d.components.monitor.FieldProjectionKSpaceMonitor, tidy3d.components.monitor.DiffractionMonitor], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})], ...] = ()\n    Tuple of monitors in the simulation. Note: monitor names are used to access data after simulation is run.\ngrid_spec : GridSpec = GridSpec(grid_x=AutoGrid(type='AutoGrid',, min_steps_per_wvl=10.0,, max_scale=1.4,, dl_min=0.0,, mesher=GradedMesher(type='GradedMesher')), grid_y=AutoGrid(type='AutoGrid',, min_steps_per_wvl=10.0,, max_scale=1.4,, dl_min=0.0,, mesher=GradedMesher(type='GradedMesher')), grid_z=AutoGrid(type='AutoGrid',, min_steps_per_wvl=10.0,, max_scale=1.4,, dl_min=0.0,, mesher=GradedMesher(type='GradedMesher')), wavelength=None, override_structures=(), type='GridSpec')\n    Specifications for the simulation grid along each of the three directions.\nversion : str = 2.6.4\n    String specifying the front end version number.\ncourant : ConstrainedFloatValue = 0.99\n    Courant stability factor, controls time step to spatial step ratio. Lower values lead to more stable simulations for dispersive materials, but result in longer simulation times. This factor is normalized to no larger than 1 when CFL stability condition is met in 3D.\nnormalize_index : Optional[NonNegativeInt] = 0\n    Index of the source in the tuple of sources whose spectrum will be used to normalize the frequency-dependent data. If ``None``, the raw field data is returned unnormalized.\nshutoff : NonNegativeFloat = 1e-05\n    Ratio of the instantaneous integrated E-field intensity to the maximum value at which the simulation will automatically terminate time stepping. Used to prevent extraneous run time of simulations with fully decayed fields. Set to ``0`` to disable this feature.\nsubpixel : bool = True\n    If ``True``, uses subpixel averaging of the permittivity based on structure definition, resulting in much higher accuracy for a given grid size.\nrun_time : PositiveFloat\n    [units = sec].  Total electromagnetic evolution time in seconds. Note: If simulation 'shutoff' is specified, simulation will terminate early when shutoff condition met. \n\nNotes\n-----\n\n    A ``Simulation`` defines a custom implementation of Maxwell's equations which represents the physical model\n    to be solved using `the Finite-Difference Time-Domain (FDTD) method\n    <https://www.flexcompute.com/fdtd101/Lecture-1-Introduction-to-FDTD-Simulation/>`_. ``tidy3d`` simulations\n    run very quickly in the cloud through GPU parallelization.\n\n    .. image:: ../../_static/img/field_update_fdtd.png\n        :width: 50%\n        :align: left\n\n    FDTD is a method for simulating the interaction of electromagnetic waves with structures and materials. It is\n    the most widely used method in photonics design. The Maxwell's\n    equations implemented in the ``Simulation`` are solved per time-step in the order shown in this image.\n\n    The simplified input to FDTD solver consists of the permittivity distribution defined by :attr:`structures`\n    which describe the device and :attr:`sources` of electromagnetic excitation. This information is used to\n    computate the time dynamics of the electric and magnetic fields in this system. From these time-domain\n    results, frequency-domain information of the simulation can also be extracted, and used for device design and\n    optimization.\n\n    If you are new to the FDTD method, we recommend you get started with the `FDTD 101 Lecture Series\n    <https://www.flexcompute.com/tidy3d/learning-center/fdtd101/>`_\n\n    **Dimensions Selection**\n\n    By default, simulations are defined as 3D. To make the simulation 2D, we can just set the simulation\n    :attr:`size` in one of the dimensions to be 0. However, note that we still have to define a grid size (eg.\n    ``tidy3d.Simulation(size=[size_x, size_y, 0])``) and specify a periodic boundary condition in that direction.\n\n    .. TODO sort out inheritance problem https://aware-moon.cloudvent.net/tidy3d/examples/notebooks/RingResonator/\n\n    See further parameter explanations below.\n\nExample\n-------\n>>> from tidy3d import Sphere, Cylinder, PolySlab\n>>> from tidy3d import UniformCurrentSource, GaussianPulse\n>>> from tidy3d import FieldMonitor, FluxMonitor\n>>> from tidy3d import GridSpec, AutoGrid\n>>> from tidy3d import BoundarySpec, Boundary\n>>> from tidy3d import Medium\n>>> sim = Simulation(\n...     size=(3.0, 3.0, 3.0),\n...     grid_spec=GridSpec(\n...         grid_x = AutoGrid(min_steps_per_wvl = 20),\n...         grid_y = AutoGrid(min_steps_per_wvl = 20),\n...         grid_z = AutoGrid(min_steps_per_wvl = 20)\n...     ),\n...     run_time=40e-11,\n...     structures=[\n...         Structure(\n...             geometry=Box(size=(1, 1, 1), center=(0, 0, 0)),\n...             medium=Medium(permittivity=2.0),\n...         ),\n...     ],\n...     sources=[\n...         UniformCurrentSource(\n...             size=(0, 0, 0),\n...             center=(0, 0.5, 0),\n...             polarization=\"Hx\",\n...             source_time=GaussianPulse(\n...                 freq0=2e14,\n...                 fwidth=4e13,\n...             ),\n...         )\n...     ],\n...     monitors=[\n...         FluxMonitor(size=(1, 1, 0), center=(0, 0, 0), freqs=[2e14, 2.5e14], name='flux'),\n...     ],\n...     symmetry=(0, 0, 0),\n...     boundary_spec=BoundarySpec(\n...         x = Boundary.pml(num_layers=20),\n...         y = Boundary.pml(num_layers=30),\n...         z = Boundary.periodic(),\n...     ),\n...     shutoff=1e-6,\n...     courant=0.8,\n...     subpixel=False,\n... )\n\nSee Also\n--------\n\n**Notebooks:**\n    * `Quickstart <../../notebooks/StartHere.html>`_: Usage in a basic simulation flow.\n    * `Using automatic nonuniform meshing <../../notebooks/AutoGrid.html>`_\n    * See nearly all notebooks for :class:`Simulation` applications.\n\n**Lectures:**\n    * `Introduction to FDTD Simulation <https://www.flexcompute.com/fdtd101/Lecture-1-Introduction-to-FDTD-Simulation/#presentation-slides>`_: Usage in a basic simulation flow.\n    * `Prelude to Integrated Photonics Simulation: Mode Injection <https://www.flexcompute.com/fdtd101/Lecture-4-Prelude-to-Integrated-Photonics-Simulation-Mode-Injection/>`_\n\n**GUI:**\n    * `FDTD Walkthrough <https://www.flexcompute.com/tidy3d/learning-center/tidy3d-gui/Lecture-1-FDTD-Walkthrough/#presentation-slides>`_",
  "type": "object",
  "properties": {
    "type": {
      "title": "Type",
      "default": "Simulation",
      "enum": [
        "Simulation"
      ],
      "type": "string"
    },
    "center": {
      "title": "Center",
      "description": "Center of object in x, y, and z.",
      "default": [
        0.0,
        0.0,
        0.0
      ],
      "units": "um",
      "type": "array",
      "minItems": 3,
      "maxItems": 3,
      "items": [
        {
          "type": "number"
        },
        {
          "type": "number"
        },
        {
          "type": "number"
        }
      ]
    },
    "size": {
      "title": "Size",
      "description": "Size in x, y, and z directions.",
      "units": "um",
      "type": "array",
      "minItems": 3,
      "maxItems": 3,
      "items": [
        {
          "type": "number",
          "minimum": 0
        },
        {
          "type": "number",
          "minimum": 0
        },
        {
          "type": "number",
          "minimum": 0
        }
      ]
    },
    "medium": {
      "title": "Background Medium",
      "description": "Background medium of simulation, defaults to vacuum if not specified.",
      "default": {
        "name": null,
        "frequency_range": null,
        "allow_gain": false,
        "nonlinear_spec": null,
        "modulation_spec": null,
        "heat_spec": null,
        "type": "Medium",
        "permittivity": 1.0,
        "conductivity": 0.0
      },
      "discriminator": {
        "propertyName": "type",
        "mapping": {
          "Medium": "#/definitions/Medium",
          "AnisotropicMedium": "#/definitions/AnisotropicMedium",
          "PECMedium": "#/definitions/PECMedium",
          "PoleResidue": "#/definitions/PoleResidue",
          "Sellmeier": "#/definitions/Sellmeier",
          "Lorentz": "#/definitions/Lorentz",
          "Debye": "#/definitions/Debye",
          "Drude": "#/definitions/Drude",
          "FullyAnisotropicMedium": "#/definitions/FullyAnisotropicMedium",
          "CustomMedium": "#/definitions/CustomMedium",
          "CustomPoleResidue": "#/definitions/CustomPoleResidue",
          "CustomSellmeier": "#/definitions/CustomSellmeier",
          "CustomLorentz": "#/definitions/CustomLorentz",
          "CustomDebye": "#/definitions/CustomDebye",
          "CustomDrude": "#/definitions/CustomDrude",
          "CustomAnisotropicMedium": "#/definitions/CustomAnisotropicMedium",
          "PerturbationMedium": "#/definitions/PerturbationMedium",
          "PerturbationPoleResidue": "#/definitions/PerturbationPoleResidue"
        }
      },
      "oneOf": [
        {
          "$ref": "#/definitions/Medium"
        },
        {
          "$ref": "#/definitions/AnisotropicMedium"
        },
        {
          "$ref": "#/definitions/PECMedium"
        },
        {
          "$ref": "#/definitions/PoleResidue"
        },
        {
          "$ref": "#/definitions/Sellmeier"
        },
        {
          "$ref": "#/definitions/Lorentz"
        },
        {
          "$ref": "#/definitions/Debye"
        },
        {
          "$ref": "#/definitions/Drude"
        },
        {
          "$ref": "#/definitions/FullyAnisotropicMedium"
        },
        {
          "$ref": "#/definitions/CustomMedium"
        },
        {
          "$ref": "#/definitions/CustomPoleResidue"
        },
        {
          "$ref": "#/definitions/CustomSellmeier"
        },
        {
          "$ref": "#/definitions/CustomLorentz"
        },
        {
          "$ref": "#/definitions/CustomDebye"
        },
        {
          "$ref": "#/definitions/CustomDrude"
        },
        {
          "$ref": "#/definitions/CustomAnisotropicMedium"
        },
        {
          "$ref": "#/definitions/PerturbationMedium"
        },
        {
          "$ref": "#/definitions/PerturbationPoleResidue"
        }
      ]
    },
    "structures": {
      "title": "Structures",
      "description": "Tuple of structures present in simulation. Note: Structures defined later in this list override the simulation material properties in regions of spatial overlap.",
      "default": [],
      "type": "array",
      "items": {
        "$ref": "#/definitions/Structure"
      }
    },
    "symmetry": {
      "title": "Symmetries",
      "description": "Tuple of integers defining reflection symmetry across a plane bisecting the simulation domain normal to the x-, y-, and z-axis at the simulation center of each axis, respectively. Each element can be ``0`` (no symmetry), ``1`` (even, i.e. 'PMC' symmetry) or ``-1`` (odd, i.e. 'PEC' symmetry). Note that the vectorial nature of the fields must be taken into account to correctly determine the symmetry value.",
      "default": [
        0,
        0,
        0
      ],
      "type": "array",
      "minItems": 3,
      "maxItems": 3,
      "items": [
        {
          "enum": [
            0,
            -1,
            1
          ],
          "type": "integer"
        },
        {
          "enum": [
            0,
            -1,
            1
          ],
          "type": "integer"
        },
        {
          "enum": [
            0,
            -1,
            1
          ],
          "type": "integer"
        }
      ]
    },
    "sources": {
      "title": "Sources",
      "description": "Tuple of electric current sources injecting fields into the simulation.",
      "default": [],
      "type": "array",
      "items": {
        "discriminator": {
          "propertyName": "type",
          "mapping": {
            "UniformCurrentSource": "#/definitions/UniformCurrentSource",
            "PointDipole": "#/definitions/PointDipole",
            "GaussianBeam": "#/definitions/GaussianBeam",
            "AstigmaticGaussianBeam": "#/definitions/AstigmaticGaussianBeam",
            "ModeSource": "#/definitions/ModeSource",
            "PlaneWave": "#/definitions/PlaneWave",
            "CustomFieldSource": "#/definitions/CustomFieldSource",
            "CustomCurrentSource": "#/definitions/CustomCurrentSource",
            "TFSF": "#/definitions/TFSF"
          }
        },
        "oneOf": [
          {
            "$ref": "#/definitions/UniformCurrentSource"
          },
          {
            "$ref": "#/definitions/PointDipole"
          },
          {
            "$ref": "#/definitions/GaussianBeam"
          },
          {
            "$ref": "#/definitions/AstigmaticGaussianBeam"
          },
          {
            "$ref": "#/definitions/ModeSource"
          },
          {
            "$ref": "#/definitions/PlaneWave"
          },
          {
            "$ref": "#/definitions/CustomFieldSource"
          },
          {
            "$ref": "#/definitions/CustomCurrentSource"
          },
          {
            "$ref": "#/definitions/TFSF"
          }
        ]
      }
    },
    "boundary_spec": {
      "title": "Boundaries",
      "description": "Specification of boundary conditions along each dimension. If ``None``, PML boundary conditions are applied on all sides.",
      "default": {
        "x": {
          "plus": {
            "name": null,
            "type": "PML",
            "num_layers": 12,
            "parameters": {
              "sigma_order": 3,
              "sigma_min": 0.0,
              "sigma_max": 1.5,
              "type": "PMLParams",
              "kappa_order": 3,
              "kappa_min": 1.0,
              "kappa_max": 3.0,
              "alpha_order": 1,
              "alpha_min": 0.0,
              "alpha_max": 0.0
            }
          },
          "minus": {
            "name": null,
            "type": "PML",
            "num_layers": 12,
            "parameters": {
              "sigma_order": 3,
              "sigma_min": 0.0,
              "sigma_max": 1.5,
              "type": "PMLParams",
              "kappa_order": 3,
              "kappa_min": 1.0,
              "kappa_max": 3.0,
              "alpha_order": 1,
              "alpha_min": 0.0,
              "alpha_max": 0.0
            }
          },
          "type": "Boundary"
        },
        "y": {
          "plus": {
            "name": null,
            "type": "PML",
            "num_layers": 12,
            "parameters": {
              "sigma_order": 3,
              "sigma_min": 0.0,
              "sigma_max": 1.5,
              "type": "PMLParams",
              "kappa_order": 3,
              "kappa_min": 1.0,
              "kappa_max": 3.0,
              "alpha_order": 1,
              "alpha_min": 0.0,
              "alpha_max": 0.0
            }
          },
          "minus": {
            "name": null,
            "type": "PML",
            "num_layers": 12,
            "parameters": {
              "sigma_order": 3,
              "sigma_min": 0.0,
              "sigma_max": 1.5,
              "type": "PMLParams",
              "kappa_order": 3,
              "kappa_min": 1.0,
              "kappa_max": 3.0,
              "alpha_order": 1,
              "alpha_min": 0.0,
              "alpha_max": 0.0
            }
          },
          "type": "Boundary"
        },
        "z": {
          "plus": {
            "name": null,
            "type": "PML",
            "num_layers": 12,
            "parameters": {
              "sigma_order": 3,
              "sigma_min": 0.0,
              "sigma_max": 1.5,
              "type": "PMLParams",
              "kappa_order": 3,
              "kappa_min": 1.0,
              "kappa_max": 3.0,
              "alpha_order": 1,
              "alpha_min": 0.0,
              "alpha_max": 0.0
            }
          },
          "minus": {
            "name": null,
            "type": "PML",
            "num_layers": 12,
            "parameters": {
              "sigma_order": 3,
              "sigma_min": 0.0,
              "sigma_max": 1.5,
              "type": "PMLParams",
              "kappa_order": 3,
              "kappa_min": 1.0,
              "kappa_max": 3.0,
              "alpha_order": 1,
              "alpha_min": 0.0,
              "alpha_max": 0.0
            }
          },
          "type": "Boundary"
        },
        "type": "BoundarySpec"
      },
      "allOf": [
        {
          "$ref": "#/definitions/BoundarySpec"
        }
      ]
    },
    "monitors": {
      "title": "Monitors",
      "description": "Tuple of monitors in the simulation. Note: monitor names are used to access data after simulation is run.",
      "default": [],
      "type": "array",
      "items": {
        "discriminator": {
          "propertyName": "type",
          "mapping": {
            "FieldMonitor": "#/definitions/FieldMonitor",
            "FieldTimeMonitor": "#/definitions/FieldTimeMonitor",
            "PermittivityMonitor": "#/definitions/PermittivityMonitor",
            "FluxMonitor": "#/definitions/FluxMonitor",
            "FluxTimeMonitor": "#/definitions/FluxTimeMonitor",
            "ModeMonitor": "#/definitions/ModeMonitor",
            "ModeSolverMonitor": "#/definitions/ModeSolverMonitor",
            "FieldProjectionAngleMonitor": "#/definitions/FieldProjectionAngleMonitor",
            "FieldProjectionCartesianMonitor": "#/definitions/FieldProjectionCartesianMonitor",
            "FieldProjectionKSpaceMonitor": "#/definitions/FieldProjectionKSpaceMonitor",
            "DiffractionMonitor": "#/definitions/DiffractionMonitor"
          }
        },
        "oneOf": [
          {
            "$ref": "#/definitions/FieldMonitor"
          },
          {
            "$ref": "#/definitions/FieldTimeMonitor"
          },
          {
            "$ref": "#/definitions/PermittivityMonitor"
          },
          {
            "$ref": "#/definitions/FluxMonitor"
          },
          {
            "$ref": "#/definitions/FluxTimeMonitor"
          },
          {
            "$ref": "#/definitions/ModeMonitor"
          },
          {
            "$ref": "#/definitions/ModeSolverMonitor"
          },
          {
            "$ref": "#/definitions/FieldProjectionAngleMonitor"
          },
          {
            "$ref": "#/definitions/FieldProjectionCartesianMonitor"
          },
          {
            "$ref": "#/definitions/FieldProjectionKSpaceMonitor"
          },
          {
            "$ref": "#/definitions/DiffractionMonitor"
          }
        ]
      }
    },
    "grid_spec": {
      "title": "Grid Specification",
      "description": "Specifications for the simulation grid along each of the three directions.",
      "default": {
        "grid_x": {
          "type": "AutoGrid",
          "min_steps_per_wvl": 10.0,
          "max_scale": 1.4,
          "dl_min": 0.0,
          "mesher": {
            "type": "GradedMesher"
          }
        },
        "grid_y": {
          "type": "AutoGrid",
          "min_steps_per_wvl": 10.0,
          "max_scale": 1.4,
          "dl_min": 0.0,
          "mesher": {
            "type": "GradedMesher"
          }
        },
        "grid_z": {
          "type": "AutoGrid",
          "min_steps_per_wvl": 10.0,
          "max_scale": 1.4,
          "dl_min": 0.0,
          "mesher": {
            "type": "GradedMesher"
          }
        },
        "wavelength": null,
        "override_structures": [],
        "type": "GridSpec"
      },
      "allOf": [
        {
          "$ref": "#/definitions/GridSpec"
        }
      ]
    },
    "version": {
      "title": "Version",
      "description": "String specifying the front end version number.",
      "default": "2.6.4",
      "type": "string"
    },
    "courant": {
      "title": "Courant Factor",
      "description": "Courant stability factor, controls time step to spatial step ratio. Lower values lead to more stable simulations for dispersive materials, but result in longer simulation times. This factor is normalized to no larger than 1 when CFL stability condition is met in 3D.",
      "default": 0.99,
      "exclusiveMinimum": 0.0,
      "maximum": 1.0,
      "type": "number"
    },
    "normalize_index": {
      "title": "Normalization index",
      "description": "Index of the source in the tuple of sources whose spectrum will be used to normalize the frequency-dependent data. If ``None``, the raw field data is returned unnormalized.",
      "default": 0,
      "minimum": 0,
      "type": "integer"
    },
    "shutoff": {
      "title": "Shutoff Condition",
      "description": "Ratio of the instantaneous integrated E-field intensity to the maximum value at which the simulation will automatically terminate time stepping. Used to prevent extraneous run time of simulations with fully decayed fields. Set to ``0`` to disable this feature.",
      "default": 1e-05,
      "minimum": 0,
      "type": "number"
    },
    "subpixel": {
      "title": "Subpixel Averaging",
      "description": "If ``True``, uses subpixel averaging of the permittivity based on structure definition, resulting in much higher accuracy for a given grid size.",
      "default": true,
      "type": "boolean"
    },
    "run_time": {
      "title": "Run Time",
      "description": "Total electromagnetic evolution time in seconds. Note: If simulation 'shutoff' is specified, simulation will terminate early when shutoff condition met. ",
      "units": "sec",
      "exclusiveMinimum": 0,
      "type": "number"
    }
  },
  "required": [
    "size",
    "run_time"
  ],
  "additionalProperties": false,
  "definitions": {
    "NonlinearSusceptibility": {
      "title": "NonlinearSusceptibility",
      "description": "Model for an instantaneous nonlinear chi3 susceptibility.\nThe expression for the instantaneous nonlinear polarization is given below.\n\nParameters\n----------\nchi3 : float = 0\n    [units = um^2 / V^2].  Chi3 nonlinear susceptibility.\nnumiters : Optional[PositiveInt] = None\n    Deprecated. The old usage 'nonlinear_spec=model' with 'model.numiters' is deprecated and will be removed in a future release. The new usage is 'nonlinear_spec=NonlinearSpec(models=\\[model], num_iters=num_iters)'. Under the new usage, this parameter is ignored, and 'NonlinearSpec.num_iters' is used instead.\n\nNotes\n-----\n\n    This model uses real time-domain fields, so :math:`\\chi_3` must be real.\n\n    .. math::\n\n        P_{NL} = \\varepsilon_0 \\chi_3 |E|^2 E\n\n    The nonlinear constitutive relation is solved iteratively; it may not converge\n    for strong nonlinearities. Increasing :attr:`tidy3d.NonlinearSpec.num_iters` can\n    help with convergence.\n\n    For complex fields (e.g. when using Bloch boundary conditions), the nonlinearity\n    is applied separately to the real and imaginary parts, so that the above equation\n    holds when both :math:`E` and :math:`P_{NL}` are replaced by their real or imaginary parts.\n    The nonlinearity is only applied to the real-valued fields since they are the\n    physical fields.\n\n    Different field components do not interact nonlinearly. For example,\n    when calculating :math:`P_{NL, x}`, we approximate :math:`|E|^2 \\approx |E_x|^2`.\n    This approximation is valid when the :math:`E` field is predominantly polarized along one\n    of the ``x``, ``y``, or ``z`` axes.\n\n    .. TODO add links to notebooks here.\n\nExample\n-------\n>>> nonlinear_susceptibility = NonlinearSusceptibility(chi3=1)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "NonlinearSusceptibility",
          "enum": [
            "NonlinearSusceptibility"
          ],
          "type": "string"
        },
        "chi3": {
          "title": "Chi3",
          "description": "Chi3 nonlinear susceptibility.",
          "default": 0,
          "units": "um^2 / V^2",
          "type": "number"
        },
        "numiters": {
          "title": "Number of iterations",
          "description": "Deprecated. The old usage 'nonlinear_spec=model' with 'model.numiters' is deprecated and will be removed in a future release. The new usage is 'nonlinear_spec=NonlinearSpec(models=\\[model], num_iters=num_iters)'. Under the new usage, this parameter is ignored, and 'NonlinearSpec.num_iters' is used instead.",
          "exclusiveMinimum": 0,
          "type": "integer"
        }
      },
      "additionalProperties": false
    },
    "ComplexNumber": {
      "title": "ComplexNumber",
      "description": "Complex number with a well defined schema.",
      "type": "object",
      "properties": {
        "real": {
          "title": "Real",
          "type": "number"
        },
        "imag": {
          "title": "Imag",
          "type": "number"
        }
      },
      "required": [
        "real",
        "imag"
      ]
    },
    "TwoPhotonAbsorption": {
      "title": "TwoPhotonAbsorption",
      "description": "Model for two-photon absorption (TPA) nonlinearity which gives an intensity-dependent\nabsorption of the form :math:`\\alpha = \\alpha_0 + \\beta I`.\nAlso includes free-carrier absorption (FCA) and free-carrier plasma dispersion (FCPD) effects.\nThe expression for the nonlinear polarization is given below.\n\nParameters\n----------\nbeta : Union[float, tidycomplex, ComplexNumber] = 0\n    [units = um / W].  Coefficient for two-photon absorption (TPA).\ntau : NonNegativeFloat = 0\n    [units = sec].  Lifetime for the free carriers created by two-photon absorption (TPA).\nsigma : NonNegativeFloat = 0\n    [units = um^2].  Total cross section for free-carrier absorption (FCA). Contains contributions from electrons and from holes.\ne_e : NonNegativeFloat = 1\n    Exponent for the free electron refractive index shift in the free-carrier plasma dispersion (FCPD).\ne_h : NonNegativeFloat = 1\n    Exponent for the free hole refractive index shift in the free-carrier plasma dispersion (FCPD).\nc_e : float = 0\n    [units = um^(3 e_e)].  Coefficient for the free electron refractive index shift in the free-carrier plasma dispersion (FCPD).\nc_h : float = 0\n    [units = um^(3 e_h)].  Coefficient for the free hole refractive index shift in the free-carrier plasma dispersion (FCPD).\nn0 : Union[tidycomplex, ComplexNumber, NoneType] = None\n    Complex linear refractive index of the medium, computed for instance using 'medium.nk_model'. If not provided, it is calculated automatically using the central frequencies of the simulation sources (as long as these are all equal).\nfreq0 : Optional[PositiveFloat] = None\n    Central frequency, used to calculate the energy of the free-carriers excited by two-photon absorption. If not provided, it is obtained automatically from the simulation sources (as long as these are all equal).\n\nNote\n----\n.. math::\n\n    P_{NL} = P_{TPA} + P_{FCA} + P_{FCPD} \\\\\n    P_{TPA} = -\\frac{c_0^2 \\varepsilon_0^2 n_0 \\operatorname{Re}(n_0) \\beta}{2 i \\omega} |E|^2 E \\\\\n    P_{FCA} = -\\frac{c_0 \\varepsilon_0 n_0 \\sigma N_f}{i \\omega} E \\\\\n    \\frac{dN_f}{dt} = \\frac{c_0^2 \\varepsilon_0^2 n_0^2 \\beta}{8 q_e \\hbar \\omega} |E|^4 - \\frac{N_f}{\\tau} \\\\\n    N_e = N_h = N_f \\\\\n    P_{FCPD} = \\varepsilon_0 2 n_0 \\Delta n (N_f) E \\\\\n    \\Delta n (N_f) = (c_e N_e^{e_e} + c_h N_h^{e_h})\n\nNote\n----\nThis frequency-domain equation is implemented in the time domain using complex-valued fields.\n\nNote\n----\nDifferent field components do not interact nonlinearly. For example,\nwhen calculating :math:`P_{NL, x}`, we approximate :math:`|E|^2 \\approx |E_x|^2`.\nThis approximation is valid when the E field is predominantly polarized along one\nof the x, y, or z axes.\n\nNote\n----\nThe implementation is described in::\n\n    N. Suzuki, \"FDTD Analysis of Two-Photon Absorption and Free-Carrier Absorption in Si\n    High-Index-Contrast Waveguides,\" J. Light. Technol. 25, 9 (2007).\n\nExample\n-------\n>>> tpa_model = TwoPhotonAbsorption(beta=1)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "TwoPhotonAbsorption",
          "enum": [
            "TwoPhotonAbsorption"
          ],
          "type": "string"
        },
        "beta": {
          "title": "TPA coefficient",
          "description": "Coefficient for two-photon absorption (TPA).",
          "default": 0,
          "units": "um / W",
          "anyOf": [
            {
              "type": "number"
            },
            {
              "title": "ComplexNumber",
              "description": "Complex number with a well defined schema.",
              "type": "object",
              "properties": {
                "real": {
                  "title": "Real",
                  "type": "number"
                },
                "imag": {
                  "title": "Imag",
                  "type": "number"
                }
              },
              "required": [
                "real",
                "imag"
              ]
            },
            {
              "$ref": "#/definitions/ComplexNumber"
            }
          ]
        },
        "tau": {
          "title": "Carrier lifetime",
          "description": "Lifetime for the free carriers created by two-photon absorption (TPA).",
          "default": 0,
          "units": "sec",
          "minimum": 0,
          "type": "number"
        },
        "sigma": {
          "title": "FCA cross section",
          "description": "Total cross section for free-carrier absorption (FCA). Contains contributions from electrons and from holes.",
          "default": 0,
          "units": "um^2",
          "minimum": 0,
          "type": "number"
        },
        "e_e": {
          "title": "Electron exponent",
          "description": "Exponent for the free electron refractive index shift in the free-carrier plasma dispersion (FCPD).",
          "default": 1,
          "minimum": 0,
          "type": "number"
        },
        "e_h": {
          "title": "Hole exponent",
          "description": "Exponent for the free hole refractive index shift in the free-carrier plasma dispersion (FCPD).",
          "default": 1,
          "minimum": 0,
          "type": "number"
        },
        "c_e": {
          "title": "Electron coefficient",
          "description": "Coefficient for the free electron refractive index shift in the free-carrier plasma dispersion (FCPD).",
          "default": 0,
          "units": "um^(3 e_e)",
          "type": "number"
        },
        "c_h": {
          "title": "Hole coefficient",
          "description": "Coefficient for the free hole refractive index shift in the free-carrier plasma dispersion (FCPD).",
          "default": 0,
          "units": "um^(3 e_h)",
          "type": "number"
        },
        "n0": {
          "title": "Complex linear refractive index",
          "description": "Complex linear refractive index of the medium, computed for instance using 'medium.nk_model'. If not provided, it is calculated automatically using the central frequencies of the simulation sources (as long as these are all equal).",
          "anyOf": [
            {
              "title": "ComplexNumber",
              "description": "Complex number with a well defined schema.",
              "type": "object",
              "properties": {
                "real": {
                  "title": "Real",
                  "type": "number"
                },
                "imag": {
                  "title": "Imag",
                  "type": "number"
                }
              },
              "required": [
                "real",
                "imag"
              ]
            },
            {
              "$ref": "#/definitions/ComplexNumber"
            }
          ]
        },
        "freq0": {
          "title": "Central frequency",
          "description": "Central frequency, used to calculate the energy of the free-carriers excited by two-photon absorption. If not provided, it is obtained automatically from the simulation sources (as long as these are all equal).",
          "exclusiveMinimum": 0,
          "type": "number"
        }
      },
      "additionalProperties": false
    },
    "KerrNonlinearity": {
      "title": "KerrNonlinearity",
      "description": "Model for Kerr nonlinearity which gives an intensity-dependent refractive index\nof the form :math:`n = n_0 + n_2 I`. The expression for the nonlinear polarization\nis given below.\n\nParameters\n----------\nn2 : Union[tidycomplex, ComplexNumber] = 0\n    [units = um^2 / W].  Nonlinear refractive index in the Kerr nonlinearity.\nn0 : Union[tidycomplex, ComplexNumber, NoneType] = None\n    Complex linear refractive index of the medium, computed for instance using 'medium.nk_model'. If not provided, it is calculated automatically using the central frequencies of the simulation sources (as long as these are all equal).\n\nNote\n----\n.. math::\n\n    P_{NL} = \\varepsilon_0 c_0 n_0 \\operatorname{Re}(n_0) n_2 |E|^2 E\n\nNote\n----\nThe fields in this equation are complex-valued, allowing a direct implementation of the Kerr\nnonlinearity. In contrast, the model :class:`.NonlinearSusceptibility` implements a\nchi3 nonlinear susceptibility using real-valued fields, giving rise to Kerr nonlinearity\nas well as third-harmonic generation. The relationship between the parameters is given by\n:math:`n_2 = \\frac{3}{4} \\frac{1}{\\varepsilon_0 c_0 n_0 \\operatorname{Re}(n_0)} \\chi_3`. The additional\nfactor of :math:`\\frac{3}{4}` comes from the usage of complex-valued fields for the Kerr\nnonlinearity and real-valued fields for the nonlinear susceptibility.\n\nNote\n----\nDifferent field components do not interact nonlinearly. For example,\nwhen calculating :math:`P_{NL, x}`, we approximate :math:`|E|^2 \\approx |E_x|^2`.\nThis approximation is valid when the E field is predominantly polarized along one\nof the x, y, or z axes.\n\nExample\n-------\n>>> kerr_model = KerrNonlinearity(n2=1)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "KerrNonlinearity",
          "enum": [
            "KerrNonlinearity"
          ],
          "type": "string"
        },
        "n2": {
          "title": "Nonlinear refractive index",
          "description": "Nonlinear refractive index in the Kerr nonlinearity.",
          "default": 0,
          "units": "um^2 / W",
          "anyOf": [
            {
              "title": "ComplexNumber",
              "description": "Complex number with a well defined schema.",
              "type": "object",
              "properties": {
                "real": {
                  "title": "Real",
                  "type": "number"
                },
                "imag": {
                  "title": "Imag",
                  "type": "number"
                }
              },
              "required": [
                "real",
                "imag"
              ]
            },
            {
              "$ref": "#/definitions/ComplexNumber"
            }
          ]
        },
        "n0": {
          "title": "Complex linear refractive index",
          "description": "Complex linear refractive index of the medium, computed for instance using 'medium.nk_model'. If not provided, it is calculated automatically using the central frequencies of the simulation sources (as long as these are all equal).",
          "anyOf": [
            {
              "title": "ComplexNumber",
              "description": "Complex number with a well defined schema.",
              "type": "object",
              "properties": {
                "real": {
                  "title": "Real",
                  "type": "number"
                },
                "imag": {
                  "title": "Imag",
                  "type": "number"
                }
              },
              "required": [
                "real",
                "imag"
              ]
            },
            {
              "$ref": "#/definitions/ComplexNumber"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "NonlinearSpec": {
      "title": "NonlinearSpec",
      "description": "Abstract specification for adding nonlinearities to a medium.\n\nParameters\n----------\nmodels : Tuple[Union[NonlinearSusceptibility, TwoPhotonAbsorption, KerrNonlinearity], ...] = ()\n    The nonlinear models present in this nonlinear spec. Nonlinear models of different types are additive. Multiple nonlinear models of the same type are not allowed.\nnum_iters : PositiveInt = 5\n    Number of iterations for solving nonlinear constitutive relation.\n\nNote\n----\nThe nonlinear constitutive relation is solved iteratively; it may not converge\nfor strong nonlinearities. Increasing ``num_iters`` can help with convergence.\n\nExample\n-------\n>>> nonlinear_susceptibility = NonlinearSusceptibility(chi3=1)\n>>> nonlinear_spec = NonlinearSpec(models=[nonlinear_susceptibility])\n>>> medium = Medium(permittivity=2, nonlinear_spec=nonlinear_spec)",
      "type": "object",
      "properties": {
        "models": {
          "title": "Nonlinear models",
          "description": "The nonlinear models present in this nonlinear spec. Nonlinear models of different types are additive. Multiple nonlinear models of the same type are not allowed.",
          "default": [],
          "type": "array",
          "items": {
            "anyOf": [
              {
                "$ref": "#/definitions/NonlinearSusceptibility"
              },
              {
                "$ref": "#/definitions/TwoPhotonAbsorption"
              },
              {
                "$ref": "#/definitions/KerrNonlinearity"
              }
            ]
          }
        },
        "num_iters": {
          "title": "Number of iterations",
          "description": "Number of iterations for solving nonlinear constitutive relation.",
          "default": 5,
          "exclusiveMinimum": 0,
          "type": "integer"
        },
        "type": {
          "title": "Type",
          "default": "NonlinearSpec",
          "enum": [
            "NonlinearSpec"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "SpaceModulation": {
      "title": "SpaceModulation",
      "description": "The modulation profile with a user-supplied spatial distribution of\namplitude and phase.\n\nParameters\n----------\namplitude : Union[float, SpatialDataArray] = 1\n    Amplitude of modulation that can vary spatially. It takes the unit of whatever is being modulated.\nphase : Union[float, SpatialDataArray] = 0\n    [units = rad].  Phase of modulation that can vary spatially.\ninterp_method : Literal['nearest', 'linear'] = nearest\n    Method of interpolation to use to obtain values at spatial locations on the Yee grids.\n\nNote\n----\n.. math::\n\n    amp\\_space(r) = amplitude(r) \\cdot e^{i \\cdot phase(r)}\n\nThe full space-time modulation is,\n\n.. math::\n\n    amp(r, t) = \\Re[amp\\_time(t) \\cdot amp\\_space(r)]\n\nExample\n-------\n>>> Nx, Ny, Nz = 10, 9, 8\n>>> X = np.linspace(-1, 1, Nx)\n>>> Y = np.linspace(-1, 1, Ny)\n>>> Z = np.linspace(-1, 1, Nz)\n>>> coords = dict(x=X, y=Y, z=Z)\n>>> amp = SpatialDataArray(np.random.random((Nx, Ny, Nz)), coords=coords)\n>>> phase = SpatialDataArray(np.random.random((Nx, Ny, Nz)), coords=coords)\n>>> space = SpaceModulation(amplitude=amp, phase=phase)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "SpaceModulation",
          "enum": [
            "SpaceModulation"
          ],
          "type": "string"
        },
        "amplitude": {
          "title": "Amplitude of modulation in space",
          "description": "Amplitude of modulation that can vary spatially. It takes the unit of whatever is being modulated.",
          "default": 1,
          "anyOf": [
            {
              "type": "number"
            },
            {
              "title": "DataArray",
              "type": "xr.DataArray",
              "properties": {
                "_dims": {
                  "title": "_dims",
                  "type": "Tuple[str, ...]"
                }
              },
              "required": [
                "_dims"
              ]
            }
          ]
        },
        "phase": {
          "title": "Phase of modulation in space",
          "description": "Phase of modulation that can vary spatially.",
          "default": 0,
          "units": "rad",
          "anyOf": [
            {
              "type": "number"
            },
            {
              "title": "DataArray",
              "type": "xr.DataArray",
              "properties": {
                "_dims": {
                  "title": "_dims",
                  "type": "Tuple[str, ...]"
                }
              },
              "required": [
                "_dims"
              ]
            }
          ]
        },
        "interp_method": {
          "title": "Interpolation method",
          "description": "Method of interpolation to use to obtain values at spatial locations on the Yee grids.",
          "default": "nearest",
          "enum": [
            "nearest",
            "linear"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "ContinuousWaveTimeModulation": {
      "title": "ContinuousWaveTimeModulation",
      "description": "Class describing modulation with a harmonic time dependence.\n\nParameters\n----------\namplitude : NonNegativeFloat = 1.0\n    Real-valued maximum amplitude of the time dependence.\nphase : float = 0.0\n    [units = rad].  Phase shift of the time dependence.\nfreq0 : PositiveFloat\n    [units = Hz].  Modulation frequency.\n\nNote\n----\n.. math::\n\n    amp\\_time(t) = amplitude \\cdot \\\n            e^{i \\cdot phase - 2 \\pi i \\cdot freq0 \\cdot t}\n\nNote\n----\nThe full space-time modulation is,\n\n.. math::\n\n    amp(r, t) = \\Re[amp\\_time(t) \\cdot amp\\_space(r)]\n\n\nExample\n-------\n>>> cw = ContinuousWaveTimeModulation(freq0=200e12, amplitude=1, phase=0)",
      "type": "object",
      "properties": {
        "amplitude": {
          "title": "Amplitude",
          "description": "Real-valued maximum amplitude of the time dependence.",
          "default": 1.0,
          "minimum": 0,
          "type": "number"
        },
        "phase": {
          "title": "Phase",
          "description": "Phase shift of the time dependence.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "type": {
          "title": "Type",
          "default": "ContinuousWaveTimeModulation",
          "enum": [
            "ContinuousWaveTimeModulation"
          ],
          "type": "string"
        },
        "freq0": {
          "title": "Modulation Frequency",
          "description": "Modulation frequency.",
          "units": "Hz",
          "exclusiveMinimum": 0,
          "type": "number"
        }
      },
      "required": [
        "freq0"
      ],
      "additionalProperties": false
    },
    "SpaceTimeModulation": {
      "title": "SpaceTimeModulation",
      "description": "Space-time modulation applied to a medium, adding\non top of the time-independent part.\n\nParameters\n----------\nspace_modulation : SpaceModulation = SpaceModulation(type='SpaceModulation', amplitude=1.0, phase=0.0, interp_method='nearest')\n    Space modulation part from the separable SpaceTimeModulation.\ntime_modulation : ContinuousWaveTimeModulation\n    Time modulation part from the separable SpaceTimeModulation.\n\n\nNote\n----\nThe space-time modulation must be separable in space and time.\ne.g. when applied to permittivity,\n\n.. math::\n\n    \\delta \\epsilon(r, t) = \\Re[amp\\_time(t) \\cdot amp\\_space(r)]",
      "type": "object",
      "properties": {
        "space_modulation": {
          "title": "Space modulation",
          "description": "Space modulation part from the separable SpaceTimeModulation.",
          "default": {
            "type": "SpaceModulation",
            "amplitude": 1.0,
            "phase": 0.0,
            "interp_method": "nearest"
          },
          "allOf": [
            {
              "$ref": "#/definitions/SpaceModulation"
            }
          ]
        },
        "time_modulation": {
          "title": "Time modulation",
          "description": "Time modulation part from the separable SpaceTimeModulation.",
          "allOf": [
            {
              "$ref": "#/definitions/ContinuousWaveTimeModulation"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "SpaceTimeModulation",
          "enum": [
            "SpaceTimeModulation"
          ],
          "type": "string"
        }
      },
      "required": [
        "time_modulation"
      ],
      "additionalProperties": false
    },
    "ModulationSpec": {
      "title": "ModulationSpec",
      "description": "Specification adding space-time modulation to the non-dispersive part of medium\nincluding relative permittivity at infinite frequency and electric conductivity.\n\n\nParameters\n----------\npermittivity : Optional[SpaceTimeModulation] = None\n    Space-time modulation of relative permittivity at infinite frequency applied on top of the base permittivity at infinite frequency.\nconductivity : Optional[SpaceTimeModulation] = None\n    Space-time modulation of electric conductivity applied on top of the base conductivity.",
      "type": "object",
      "properties": {
        "permittivity": {
          "title": "Space-time modulation of relative permittivity",
          "description": "Space-time modulation of relative permittivity at infinite frequency applied on top of the base permittivity at infinite frequency.",
          "allOf": [
            {
              "$ref": "#/definitions/SpaceTimeModulation"
            }
          ]
        },
        "conductivity": {
          "title": "Space-time modulation of conductivity",
          "description": "Space-time modulation of electric conductivity applied on top of the base conductivity.",
          "allOf": [
            {
              "$ref": "#/definitions/SpaceTimeModulation"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "ModulationSpec",
          "enum": [
            "ModulationSpec"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "FluidSpec": {
      "title": "FluidSpec",
      "description": "Fluid medium.\n\nParameters\n----------\n\nExample\n-------\n>>> solid = FluidSpec()",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "FluidSpec",
          "enum": [
            "FluidSpec"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "SolidSpec": {
      "title": "SolidSpec",
      "description": "Solid medium.\n\nParameters\n----------\ncapacity : PositiveFloat\n    [units = J/(kg*K)].  Volumetric heat capacity in unit of J/(kg*K).\nconductivity : PositiveFloat\n    [units = W/(um*K)].  Thermal conductivity of material in units of W/(um*K).\n\nExample\n-------\n>>> solid = SolidSpec(\n...     capacity=2,\n...     conductivity=3,\n... )",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "SolidSpec",
          "enum": [
            "SolidSpec"
          ],
          "type": "string"
        },
        "capacity": {
          "title": "Heat capacity",
          "description": "Volumetric heat capacity in unit of J/(kg*K).",
          "units": "J/(kg*K)",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "conductivity": {
          "title": "Thermal conductivity",
          "description": "Thermal conductivity of material in units of W/(um*K).",
          "units": "W/(um*K)",
          "exclusiveMinimum": 0,
          "type": "number"
        }
      },
      "required": [
        "capacity",
        "conductivity"
      ],
      "additionalProperties": false
    },
    "Medium": {
      "title": "Medium",
      "description": "Dispersionless medium. Mediums define the optical properties of the materials within the simulation.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\npermittivity : ConstrainedFloatValue = 1.0\n    [units = None (relative permittivity)].  Relative permittivity.\nconductivity : float = 0.0\n    [units = S/um].  Electric conductivity. Defined such that the imaginary part of the complex permittivity at angular frequency omega is given by conductivity/omega.\n\nNotes\n-----\n\n    In a dispersion-less medium, the displacement field :math:`D(t)` reacts instantaneously to the applied\n    electric field :math:`E(t)`.\n\n    .. math::\n\n        D(t) = \\epsilon E(t)\n\nExample\n-------\n>>> dielectric = Medium(permittivity=4.0, name='my_medium')\n>>> eps = dielectric.eps_model(200e12)\n\nSee Also\n--------\n\n**Notebooks**\n    * `Introduction on Tidy3D working principles <../../notebooks/Primer.html#Mediums>`_\n    * `Index <../../notebooks/docs/features/medium.html>`_\n\n**Lectures**\n    * `Modeling dispersive material in FDTD <https://www.flexcompute.com/fdtd101/Lecture-5-Modeling-dispersive-material-in-FDTD/>`_\n\n**GUI**\n    * `Mediums <https://www.flexcompute.com/tidy3d/learning-center/tidy3d-gui/Lecture-2-Mediums/>`_",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Medium",
          "enum": [
            "Medium"
          ],
          "type": "string"
        },
        "permittivity": {
          "title": "Permittivity",
          "description": "Relative permittivity.",
          "default": 1.0,
          "minimum": 1.0,
          "units": "None (relative permittivity)",
          "type": "number"
        },
        "conductivity": {
          "title": "Conductivity",
          "description": "Electric conductivity. Defined such that the imaginary part of the complex permittivity at angular frequency omega is given by conductivity/omega.",
          "default": 0.0,
          "units": "S/um",
          "type": "number"
        }
      },
      "additionalProperties": false
    },
    "PoleResidue": {
      "title": "PoleResidue",
      "description": "A dispersive medium described by the pole-residue pair model.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\neps_inf : PositiveFloat = 1.0\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\npoles : Tuple[Tuple[Union[tidy3d.components.types.tidycomplex, tidy3d.components.types.ComplexNumber], Union[tidy3d.components.types.tidycomplex, tidy3d.components.types.ComplexNumber]], ...] = ()\n    [units = (rad/sec, rad/sec)].  Tuple of complex-valued (:math:`a_i, c_i`) poles for the model.\n\nNotes\n-----\n\n    The frequency-dependence of the complex-valued permittivity is described by:\n\n    .. math::\n\n        \\epsilon(\\omega) = \\epsilon_\\infty - \\sum_i\n        \\left[\\frac{c_i}{j \\omega + a_i} +\n        \\frac{c_i^*}{j \\omega + a_i^*}\\right]\n\nExample\n-------\n>>> pole_res = PoleResidue(eps_inf=2.0, poles=[((-1+2j), (3+4j)), ((-5+6j), (7+8j))])\n>>> eps = pole_res.eps_model(200e12)\n\nSee Also\n--------\n\n:class:`CustomPoleResidue`:\n    A spatially varying dispersive medium described by the pole-residue pair model.\n\n**Notebooks**\n    * `Fitting dispersive material models <../../notebooks/Fitting.html>`_\n\n**Lectures**\n    * `Modeling dispersive material in FDTD <https://www.flexcompute.com/fdtd101/Lecture-5-Modeling-dispersive-material-in-FDTD/>`_",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "PoleResidue",
          "enum": [
            "PoleResidue"
          ],
          "type": "string"
        },
        "eps_inf": {
          "title": "Epsilon at Infinity",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "default": 1.0,
          "units": "None (relative permittivity)",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "poles": {
          "title": "Poles",
          "description": "Tuple of complex-valued (:math:`a_i, c_i`) poles for the model.",
          "default": [],
          "units": [
            "rad/sec",
            "rad/sec"
          ],
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "anyOf": [
                  {
                    "title": "ComplexNumber",
                    "description": "Complex number with a well defined schema.",
                    "type": "object",
                    "properties": {
                      "real": {
                        "title": "Real",
                        "type": "number"
                      },
                      "imag": {
                        "title": "Imag",
                        "type": "number"
                      }
                    },
                    "required": [
                      "real",
                      "imag"
                    ]
                  },
                  {
                    "$ref": "#/definitions/ComplexNumber"
                  }
                ]
              },
              {
                "anyOf": [
                  {
                    "title": "ComplexNumber",
                    "description": "Complex number with a well defined schema.",
                    "type": "object",
                    "properties": {
                      "real": {
                        "title": "Real",
                        "type": "number"
                      },
                      "imag": {
                        "title": "Imag",
                        "type": "number"
                      }
                    },
                    "required": [
                      "real",
                      "imag"
                    ]
                  },
                  {
                    "$ref": "#/definitions/ComplexNumber"
                  }
                ]
              }
            ]
          }
        }
      },
      "additionalProperties": false
    },
    "Sellmeier": {
      "title": "Sellmeier",
      "description": "A dispersive medium described by the Sellmeier model.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\ncoeffs : Tuple[Tuple[float, pydantic.v1.types.PositiveFloat], ...]\n    [units = (None, um^2)].  List of Sellmeier (:math:`B_i, C_i`) coefficients.\n\nNotes\n-----\n\n    The frequency-dependence of the refractive index is described by:\n\n    .. math::\n\n        n(\\lambda)^2 = 1 + \\sum_i \\frac{B_i \\lambda^2}{\\lambda^2 - C_i}\n\n    For lossless, weakly dispersive materials, the best way to incorporate the dispersion without doing\n    complicated fits and without slowing the simulation down significantly is to provide the value of the\n    refractive index dispersion :math:`\\frac{dn}{d\\lambda}` in :meth:`tidy3d.Sellmeier.from_dispersion`. The\n    value is assumed to be at the central frequency or wavelength (whichever is provided), and a one-pole model\n    for the material is generated.\n\nExample\n-------\n>>> sellmeier_medium = Sellmeier(coeffs=[(1,2), (3,4)])\n>>> eps = sellmeier_medium.eps_model(200e12)\n\nSee Also\n--------\n\n:class:`CustomSellmeier`\n    A spatially varying dispersive medium described by the Sellmeier model.\n\n**Notebooks**\n\n* `Fitting dispersive material models <../../notebooks/Fitting.html>`_\n\n**Lectures**\n\n* `Modeling dispersive material in FDTD <https://www.flexcompute.com/fdtd101/Lecture-5-Modeling-dispersive-material-in-FDTD/>`_",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Sellmeier",
          "enum": [
            "Sellmeier"
          ],
          "type": "string"
        },
        "coeffs": {
          "title": "Coefficients",
          "description": "List of Sellmeier (:math:`B_i, C_i`) coefficients.",
          "units": [
            null,
            "um^2"
          ],
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "type": "number"
              },
              {
                "type": "number",
                "exclusiveMinimum": 0
              }
            ]
          }
        }
      },
      "required": [
        "coeffs"
      ],
      "additionalProperties": false
    },
    "Lorentz": {
      "title": "Lorentz",
      "description": "A dispersive medium described by the Lorentz model.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\neps_inf : PositiveFloat = 1.0\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\ncoeffs : Tuple[Tuple[float, float, pydantic.v1.types.NonNegativeFloat], ...]\n    [units = (None (relative permittivity), Hz, Hz)].  List of (:math:`\\Delta\\epsilon_i, f_i, \\delta_i`) values for model.\n\nNotes\n-----\n\n    The frequency-dependence of the complex-valued permittivity is described by:\n\n    .. math::\n\n        \\epsilon(f) = \\epsilon_\\infty + \\sum_i\n        \\frac{\\Delta\\epsilon_i f_i^2}{f_i^2 - 2jf\\delta_i - f^2}\n\nExample\n-------\n>>> lorentz_medium = Lorentz(eps_inf=2.0, coeffs=[(1,2,3), (4,5,6)])\n>>> eps = lorentz_medium.eps_model(200e12)\n\nSee Also\n--------\n\n**Notebooks**\n    * `Fitting dispersive material models <../../notebooks/Fitting.html>`_\n\n**Lectures**\n    * `Modeling dispersive material in FDTD <https://www.flexcompute.com/fdtd101/Lecture-5-Modeling-dispersive-material-in-FDTD/>`_",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Lorentz",
          "enum": [
            "Lorentz"
          ],
          "type": "string"
        },
        "eps_inf": {
          "title": "Epsilon at Infinity",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "default": 1.0,
          "units": "None (relative permittivity)",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "coeffs": {
          "title": "Coefficients",
          "description": "List of (:math:`\\Delta\\epsilon_i, f_i, \\delta_i`) values for model.",
          "units": [
            "None (relative permittivity)",
            "Hz",
            "Hz"
          ],
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 3,
            "maxItems": 3,
            "items": [
              {
                "type": "number"
              },
              {
                "type": "number"
              },
              {
                "type": "number",
                "minimum": 0
              }
            ]
          }
        }
      },
      "required": [
        "coeffs"
      ],
      "additionalProperties": false
    },
    "Debye": {
      "title": "Debye",
      "description": "A dispersive medium described by the Debye model.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\neps_inf : PositiveFloat = 1.0\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\ncoeffs : Tuple[Tuple[float, pydantic.v1.types.PositiveFloat], ...]\n    [units = (None (relative permittivity), sec)].  List of (:math:`\\Delta\\epsilon_i, \\tau_i`) values for model.\n\nNotes\n-----\n\n    The frequency-dependence of the complex-valued permittivity is described by:\n\n    .. math::\n\n        \\epsilon(f) = \\epsilon_\\infty + \\sum_i\n        \\frac{\\Delta\\epsilon_i}{1 - jf\\tau_i}\n\nExample\n-------\n>>> debye_medium = Debye(eps_inf=2.0, coeffs=[(1,2),(3,4)])\n>>> eps = debye_medium.eps_model(200e12)\n\nSee Also\n--------\n\n:class:`CustomDebye`\n    A spatially varying dispersive medium described by the Debye model.\n\n**Notebooks**\n    * `Fitting dispersive material models <../../notebooks/Fitting.html>`_\n\n**Lectures**\n    * `Modeling dispersive material in FDTD <https://www.flexcompute.com/fdtd101/Lecture-5-Modeling-dispersive-material-in-FDTD/>`_",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Debye",
          "enum": [
            "Debye"
          ],
          "type": "string"
        },
        "eps_inf": {
          "title": "Epsilon at Infinity",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "default": 1.0,
          "units": "None (relative permittivity)",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "coeffs": {
          "title": "Coefficients",
          "description": "List of (:math:`\\Delta\\epsilon_i, \\tau_i`) values for model.",
          "units": [
            "None (relative permittivity)",
            "sec"
          ],
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "type": "number"
              },
              {
                "type": "number",
                "exclusiveMinimum": 0
              }
            ]
          }
        }
      },
      "required": [
        "coeffs"
      ],
      "additionalProperties": false
    },
    "Drude": {
      "title": "Drude",
      "description": "A dispersive medium described by the Drude model.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\neps_inf : PositiveFloat = 1.0\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\ncoeffs : Tuple[Tuple[float, pydantic.v1.types.PositiveFloat], ...]\n    [units = (Hz, Hz)].  List of (:math:`f_i, \\delta_i`) values for model.\n\nNotes\n-----\n\n    The frequency-dependence of the complex-valued permittivity is described by:\n\n    .. math::\n\n        \\epsilon(f) = \\epsilon_\\infty - \\sum_i\n        \\frac{ f_i^2}{f^2 + jf\\delta_i}\n\nExample\n-------\n>>> drude_medium = Drude(eps_inf=2.0, coeffs=[(1,2), (3,4)])\n>>> eps = drude_medium.eps_model(200e12)\n\nSee Also\n--------\n\n:class:`CustomDrude`:\n    A spatially varying dispersive medium described by the Drude model.\n\n**Notebooks**\n    * `Fitting dispersive material models <../../notebooks/Fitting.html>`_\n\n**Lectures**\n    * `Modeling dispersive material in FDTD <https://www.flexcompute.com/fdtd101/Lecture-5-Modeling-dispersive-material-in-FDTD/>`_",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Drude",
          "enum": [
            "Drude"
          ],
          "type": "string"
        },
        "eps_inf": {
          "title": "Epsilon at Infinity",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "default": 1.0,
          "units": "None (relative permittivity)",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "coeffs": {
          "title": "Coefficients",
          "description": "List of (:math:`f_i, \\delta_i`) values for model.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "type": "number"
              },
              {
                "type": "number",
                "exclusiveMinimum": 0
              }
            ]
          }
        }
      },
      "required": [
        "coeffs"
      ],
      "additionalProperties": false
    },
    "PECMedium": {
      "title": "PECMedium",
      "description": "Perfect electrical conductor class.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\n\nNote\n----\n\n    To avoid confusion from duplicate PECs, must import ``tidy3d.PEC`` instance directly.",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "PECMedium",
          "enum": [
            "PECMedium"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "AnisotropicMedium": {
      "title": "AnisotropicMedium",
      "description": "Diagonally anisotropic medium.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : Optional[bool] = None\n    This field is ignored. Please set ``allow_gain`` in each component\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\nxx : Union[Medium, PoleResidue, Sellmeier, Lorentz, Debye, Drude, PECMedium]\n    Medium describing the xx-component of the diagonal permittivity tensor.\nyy : Union[Medium, PoleResidue, Sellmeier, Lorentz, Debye, Drude, PECMedium]\n    Medium describing the yy-component of the diagonal permittivity tensor.\nzz : Union[Medium, PoleResidue, Sellmeier, Lorentz, Debye, Drude, PECMedium]\n    Medium describing the zz-component of the diagonal permittivity tensor.\n\nNotes\n-----\n\n    Only diagonal anisotropy is currently supported.\n\nExample\n-------\n>>> medium_xx = Medium(permittivity=4.0)\n>>> medium_yy = Medium(permittivity=4.1)\n>>> medium_zz = Medium(permittivity=3.9)\n>>> anisotropic_dielectric = AnisotropicMedium(xx=medium_xx, yy=medium_yy, zz=medium_zz)\n\nSee Also\n--------\n\n:class:`CustomAnisotropicMedium`\n    Diagonally anisotropic medium with spatially varying permittivity in each component.\n\n:class:`FullyAnisotropicMedium`\n    Fully anisotropic medium including all 9 components of the permittivity and conductivity tensors.\n\n**Notebooks**\n    * `Broadband polarizer assisted by anisotropic metamaterial <../../notebooks/SWGBroadbandPolarizer.html>`_\n    * `Thin film lithium niobate adiabatic waveguide coupler <../../notebooks/AdiabaticCouplerLN.html>`_",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "This field is ignored. Please set ``allow_gain`` in each component",
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "AnisotropicMedium",
          "enum": [
            "AnisotropicMedium"
          ],
          "type": "string"
        },
        "xx": {
          "title": "XX Component",
          "description": "Medium describing the xx-component of the diagonal permittivity tensor.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "Medium": "#/definitions/Medium",
              "PoleResidue": "#/definitions/PoleResidue",
              "Sellmeier": "#/definitions/Sellmeier",
              "Lorentz": "#/definitions/Lorentz",
              "Debye": "#/definitions/Debye",
              "Drude": "#/definitions/Drude",
              "PECMedium": "#/definitions/PECMedium"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/Medium"
            },
            {
              "$ref": "#/definitions/PoleResidue"
            },
            {
              "$ref": "#/definitions/Sellmeier"
            },
            {
              "$ref": "#/definitions/Lorentz"
            },
            {
              "$ref": "#/definitions/Debye"
            },
            {
              "$ref": "#/definitions/Drude"
            },
            {
              "$ref": "#/definitions/PECMedium"
            }
          ]
        },
        "yy": {
          "title": "YY Component",
          "description": "Medium describing the yy-component of the diagonal permittivity tensor.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "Medium": "#/definitions/Medium",
              "PoleResidue": "#/definitions/PoleResidue",
              "Sellmeier": "#/definitions/Sellmeier",
              "Lorentz": "#/definitions/Lorentz",
              "Debye": "#/definitions/Debye",
              "Drude": "#/definitions/Drude",
              "PECMedium": "#/definitions/PECMedium"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/Medium"
            },
            {
              "$ref": "#/definitions/PoleResidue"
            },
            {
              "$ref": "#/definitions/Sellmeier"
            },
            {
              "$ref": "#/definitions/Lorentz"
            },
            {
              "$ref": "#/definitions/Debye"
            },
            {
              "$ref": "#/definitions/Drude"
            },
            {
              "$ref": "#/definitions/PECMedium"
            }
          ]
        },
        "zz": {
          "title": "ZZ Component",
          "description": "Medium describing the zz-component of the diagonal permittivity tensor.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "Medium": "#/definitions/Medium",
              "PoleResidue": "#/definitions/PoleResidue",
              "Sellmeier": "#/definitions/Sellmeier",
              "Lorentz": "#/definitions/Lorentz",
              "Debye": "#/definitions/Debye",
              "Drude": "#/definitions/Drude",
              "PECMedium": "#/definitions/PECMedium"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/Medium"
            },
            {
              "$ref": "#/definitions/PoleResidue"
            },
            {
              "$ref": "#/definitions/Sellmeier"
            },
            {
              "$ref": "#/definitions/Lorentz"
            },
            {
              "$ref": "#/definitions/Debye"
            },
            {
              "$ref": "#/definitions/Drude"
            },
            {
              "$ref": "#/definitions/PECMedium"
            }
          ]
        }
      },
      "required": [
        "xx",
        "yy",
        "zz"
      ],
      "additionalProperties": false
    },
    "FullyAnisotropicMedium": {
      "title": "FullyAnisotropicMedium",
      "description": "Fully anisotropic medium including all 9 components of the permittivity and conductivity\ntensors.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\npermittivity : ArrayLike[dtype=float, ndim=2, shape=(3, 3)] = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    [units = None (relative permittivity)].  Relative permittivity tensor.\nconductivity : ArrayLike[dtype=float, ndim=2, shape=(3, 3)] = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    [units = S/um].  Electric conductivity tensor. Defined such that the imaginary part of the complex permittivity at angular frequency omega is given by conductivity/omega.\n\nNotes\n-----\n\n    Provided permittivity tensor and the symmetric part of the conductivity tensor must\n    have coinciding main directions. A non-symmetric conductivity tensor can be used to model\n    magneto-optic effects. Note that dispersive properties and subpixel averaging are currently not\n    supported for fully anisotropic materials.\n\nNote\n----\n\n    Simulations involving fully anisotropic materials are computationally more intensive, thus,\n    they take longer time to complete. This increase strongly depends on the filling fraction of\n    the simulation domain by fully anisotropic materials, varying approximately in the range from\n    1.5 to 5. The cost of running a simulation is adjusted correspondingly.\n\nExample\n-------\n>>> perm = [[2, 0, 0], [0, 1, 0], [0, 0, 3]]\n>>> cond = [[0.1, 0, 0], [0, 0, 0], [0, 0, 0]]\n>>> anisotropic_dielectric = FullyAnisotropicMedium(permittivity=perm, conductivity=cond)\n\nSee Also\n--------\n\n:class:`CustomAnisotropicMedium`\n    Diagonally anisotropic medium with spatially varying permittivity in each component.\n\n:class:`AnisotropicMedium`\n    Diagonally anisotropic medium.\n\n**Notebooks**\n    * `Broadband polarizer assisted by anisotropic metamaterial <../../notebooks/SWGBroadbandPolarizer.html>`_\n    * `Thin film lithium niobate adiabatic waveguide coupler <../../notebooks/AdiabaticCouplerLN.html>`_\n    * `Defining fully anisotropic materials <../../notebooks/FullyAnisotropic.html>`_",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "FullyAnisotropicMedium",
          "enum": [
            "FullyAnisotropicMedium"
          ],
          "type": "string"
        },
        "permittivity": {
          "title": "Permittivity",
          "description": "Relative permittivity tensor.",
          "default": [
            [
              1,
              0,
              0
            ],
            [
              0,
              1,
              0
            ],
            [
              0,
              0,
              1
            ]
          ],
          "units": "None (relative permittivity)",
          "type": "ArrayLike"
        },
        "conductivity": {
          "title": "Conductivity",
          "description": "Electric conductivity tensor. Defined such that the imaginary part of the complex permittivity at angular frequency omega is given by conductivity/omega.",
          "default": [
            [
              0,
              0,
              0
            ],
            [
              0,
              0,
              0
            ],
            [
              0,
              0,
              0
            ]
          ],
          "units": "S/um",
          "type": "ArrayLike"
        }
      },
      "additionalProperties": false
    },
    "PermittivityDataset": {
      "title": "PermittivityDataset",
      "description": "Dataset storing the diagonal components of the permittivity tensor.\n\nParameters\n----------\neps_xx : ScalarFieldDataArray\n    Spatial distribution of the xx-component of the relative permittivity.\neps_yy : ScalarFieldDataArray\n    Spatial distribution of the yy-component of the relative permittivity.\neps_zz : ScalarFieldDataArray\n    Spatial distribution of the zz-component of the relative permittivity.\n\nExample\n-------\n>>> x = [-1,1]\n>>> y = [-2,0,2]\n>>> z = [-3,-1,1,3]\n>>> f = [2e14, 3e14]\n>>> coords = dict(x=x, y=y, z=z, f=f)\n>>> sclr_fld = ScalarFieldDataArray((1+1j) * np.random.random((2,3,4,2)), coords=coords)\n>>> data = PermittivityDataset(eps_xx=sclr_fld, eps_yy=sclr_fld, eps_zz=sclr_fld)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "PermittivityDataset",
          "enum": [
            "PermittivityDataset"
          ],
          "type": "string"
        },
        "eps_xx": {
          "title": "DataArray",
          "description": "Spatial distribution of the xx-component of the relative permittivity.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "eps_yy": {
          "title": "DataArray",
          "description": "Spatial distribution of the yy-component of the relative permittivity.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "eps_zz": {
          "title": "DataArray",
          "description": "Spatial distribution of the zz-component of the relative permittivity.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        }
      },
      "required": [
        "eps_xx",
        "eps_yy",
        "eps_zz"
      ],
      "additionalProperties": false
    },
    "CustomMedium": {
      "title": "CustomMedium",
      "description": ":class:`.Medium` with user-supplied permittivity distribution.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\ninterp_method : Literal['nearest', 'linear'] = nearest\n    Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.\nsubpixel : bool = False\n    If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.\neps_dataset : Optional[PermittivityDataset] = None\n    [To be deprecated] User-supplied dataset containing complex-valued permittivity as a function of space. Permittivity distribution over the Yee-grid will be interpolated based on ``interp_method``.\npermittivity : Optional[SpatialDataArray] = None\n    [units = None (relative permittivity)].  Spatial profile of relative permittivity.\nconductivity : Optional[SpatialDataArray] = None\n    [units = S/um].  Spatial profile Electric conductivity. Defined such that the imaginary part of the complex permittivity at angular frequency omega is given by conductivity/omega.\n\nExample\n-------\n>>> Nx, Ny, Nz = 10, 9, 8\n>>> X = np.linspace(-1, 1, Nx)\n>>> Y = np.linspace(-1, 1, Ny)\n>>> Z = np.linspace(-1, 1, Nz)\n>>> coords = dict(x=X, y=Y, z=Z)\n>>> permittivity= SpatialDataArray(np.ones((Nx, Ny, Nz)), coords=coords)\n>>> conductivity= SpatialDataArray(np.ones((Nx, Ny, Nz)), coords=coords)\n>>> dielectric = CustomMedium(permittivity=permittivity, conductivity=conductivity)\n>>> eps = dielectric.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "CustomMedium",
          "enum": [
            "CustomMedium"
          ],
          "type": "string"
        },
        "interp_method": {
          "title": "Interpolation method",
          "description": "Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.",
          "default": "nearest",
          "enum": [
            "nearest",
            "linear"
          ],
          "type": "string"
        },
        "subpixel": {
          "title": "Subpixel averaging",
          "description": "If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.",
          "default": false,
          "type": "boolean"
        },
        "eps_dataset": {
          "title": "Permittivity Dataset",
          "description": "[To be deprecated] User-supplied dataset containing complex-valued permittivity as a function of space. Permittivity distribution over the Yee-grid will be interpolated based on ``interp_method``.",
          "allOf": [
            {
              "$ref": "#/definitions/PermittivityDataset"
            }
          ]
        },
        "permittivity": {
          "title": "DataArray",
          "description": "Spatial profile of relative permittivity.",
          "units": "None (relative permittivity)",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "conductivity": {
          "title": "DataArray",
          "description": "Spatial profile Electric conductivity. Defined such that the imaginary part of the complex permittivity at angular frequency omega is given by conductivity/omega.",
          "units": "S/um",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        }
      },
      "additionalProperties": false
    },
    "CustomPoleResidue": {
      "title": "CustomPoleResidue",
      "description": "A spatially varying dispersive medium described by the pole-residue pair model.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\neps_inf : SpatialDataArray\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\npoles : Tuple[Tuple[tidy3d.components.data.data_array.SpatialDataArray, tidy3d.components.data.data_array.SpatialDataArray], ...] = ()\n    [units = (rad/sec, rad/sec)].  Tuple of complex-valued (:math:`a_i, c_i`) poles for the model.\ninterp_method : Literal['nearest', 'linear'] = nearest\n    Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.\nsubpixel : bool = False\n    If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.\n\nNotes\n-----\n\n    In this method, the frequency-dependent permittivity :math:`\\epsilon(\\omega)` is expressed as a sum of\n    resonant material poles _`[1]`.\n\n    .. math::\n\n        \\epsilon(\\omega) = \\epsilon_\\infty - \\sum_i\n        \\left[\\frac{c_i}{j \\omega + a_i} +\n        \\frac{c_i^*}{j \\omega + a_i^*}\\right]\n\n    For each of these resonant poles identified by the index :math:`i`, an auxiliary differential equation is\n    used to relate the auxiliary current :math:`J_i(t)` to the applied electric field :math:`E(t)`.\n    The sum of all these auxiliary current contributions describes the total dielectric response of the material.\n\n    .. math::\n\n        \\frac{d}{dt} J_i (t) - a_i J_i (t) = \\epsilon_0 c_i \\frac{d}{dt} E (t)\n\n    Hence, the computational cost increases with the number of poles.\n\n    **References**\n\n    .. [1]   M. Han, R.W. Dutton and S. Fan, IEEE Microwave and Wireless Component Letters, 16, 119 (2006).\n\n    .. TODO add links to notebooks using this.\n\nExample\n-------\n>>> x = np.linspace(-1, 1, 5)\n>>> y = np.linspace(-1, 1, 6)\n>>> z = np.linspace(-1, 1, 7)\n>>> coords = dict(x=x, y=y, z=z)\n>>> eps_inf = SpatialDataArray(np.ones((5, 6, 7)), coords=coords)\n>>> a1 = SpatialDataArray(-np.random.random((5, 6, 7)), coords=coords)\n>>> c1 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> a2 = SpatialDataArray(-np.random.random((5, 6, 7)), coords=coords)\n>>> c2 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> pole_res = CustomPoleResidue(eps_inf=eps_inf, poles=[(a1, c1), (a2, c2)])\n>>> eps = pole_res.eps_model(200e12)\n\nSee Also\n--------\n\n**Notebooks**\n\n* `Fitting dispersive material models <../../notebooks/Fitting.html>`_\n\n**Lectures**\n\n* `Modeling dispersive material in FDTD <https://www.flexcompute.com/fdtd101/Lecture-5-Modeling-dispersive-material-in-FDTD/>`_",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "CustomPoleResidue",
          "enum": [
            "CustomPoleResidue"
          ],
          "type": "string"
        },
        "eps_inf": {
          "title": "DataArray",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "units": "None (relative permittivity)",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "poles": {
          "title": "Poles",
          "description": "Tuple of complex-valued (:math:`a_i, c_i`) poles for the model.",
          "default": [],
          "units": [
            "rad/sec",
            "rad/sec"
          ],
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "title": "DataArray",
                "type": "xr.DataArray",
                "properties": {
                  "_dims": {
                    "title": "_dims",
                    "type": "Tuple[str, ...]"
                  }
                },
                "required": [
                  "_dims"
                ]
              },
              {
                "title": "DataArray",
                "type": "xr.DataArray",
                "properties": {
                  "_dims": {
                    "title": "_dims",
                    "type": "Tuple[str, ...]"
                  }
                },
                "required": [
                  "_dims"
                ]
              }
            ]
          }
        },
        "interp_method": {
          "title": "Interpolation method",
          "description": "Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.",
          "default": "nearest",
          "enum": [
            "nearest",
            "linear"
          ],
          "type": "string"
        },
        "subpixel": {
          "title": "Subpixel averaging",
          "description": "If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.",
          "default": false,
          "type": "boolean"
        }
      },
      "required": [
        "eps_inf"
      ],
      "additionalProperties": false
    },
    "CustomSellmeier": {
      "title": "CustomSellmeier",
      "description": "A spatially varying dispersive medium described by the Sellmeier model.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\ncoeffs : Tuple[Tuple[tidy3d.components.data.data_array.SpatialDataArray, tidy3d.components.data.data_array.SpatialDataArray], ...]\n    [units = (None, um^2)].  List of Sellmeier (:math:`B_i, C_i`) coefficients.\ninterp_method : Literal['nearest', 'linear'] = nearest\n    Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.\nsubpixel : bool = False\n    If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.\n\nNotes\n-----\n\n    The frequency-dependence of the refractive index is described by:\n\n    .. math::\n\n        n(\\lambda)^2 = 1 + \\sum_i \\frac{B_i \\lambda^2}{\\lambda^2 - C_i}\n\nExample\n-------\n>>> x = np.linspace(-1, 1, 5)\n>>> y = np.linspace(-1, 1, 6)\n>>> z = np.linspace(-1, 1, 7)\n>>> coords = dict(x=x, y=y, z=z)\n>>> b1 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> c1 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> sellmeier_medium = CustomSellmeier(coeffs=[(b1,c1),])\n>>> eps = sellmeier_medium.eps_model(200e12)\n\nSee Also\n--------\n\n:class:`Sellmeier`\n    A dispersive medium described by the Sellmeier model.\n\n**Notebooks**\n    * `Fitting dispersive material models <../../notebooks/Fitting.html>`_\n\n**Lectures**\n    * `Modeling dispersive material in FDTD <https://www.flexcompute.com/fdtd101/Lecture-5-Modeling-dispersive-material-in-FDTD/>`_",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "CustomSellmeier",
          "enum": [
            "CustomSellmeier"
          ],
          "type": "string"
        },
        "coeffs": {
          "title": "Coefficients",
          "description": "List of Sellmeier (:math:`B_i, C_i`) coefficients.",
          "units": [
            null,
            "um^2"
          ],
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "title": "DataArray",
                "type": "xr.DataArray",
                "properties": {
                  "_dims": {
                    "title": "_dims",
                    "type": "Tuple[str, ...]"
                  }
                },
                "required": [
                  "_dims"
                ]
              },
              {
                "title": "DataArray",
                "type": "xr.DataArray",
                "properties": {
                  "_dims": {
                    "title": "_dims",
                    "type": "Tuple[str, ...]"
                  }
                },
                "required": [
                  "_dims"
                ]
              }
            ]
          }
        },
        "interp_method": {
          "title": "Interpolation method",
          "description": "Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.",
          "default": "nearest",
          "enum": [
            "nearest",
            "linear"
          ],
          "type": "string"
        },
        "subpixel": {
          "title": "Subpixel averaging",
          "description": "If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.",
          "default": false,
          "type": "boolean"
        }
      },
      "required": [
        "coeffs"
      ],
      "additionalProperties": false
    },
    "CustomLorentz": {
      "title": "CustomLorentz",
      "description": "A spatially varying dispersive medium described by the Lorentz model.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\neps_inf : SpatialDataArray\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\ncoeffs : Tuple[Tuple[tidy3d.components.data.data_array.SpatialDataArray, tidy3d.components.data.data_array.SpatialDataArray, tidy3d.components.data.data_array.SpatialDataArray], ...]\n    [units = (None (relative permittivity), Hz, Hz)].  List of (:math:`\\Delta\\epsilon_i, f_i, \\delta_i`) values for model.\ninterp_method : Literal['nearest', 'linear'] = nearest\n    Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.\nsubpixel : bool = False\n    If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.\n\nNotes\n-----\n\n    The frequency-dependence of the complex-valued permittivity is described by:\n\n    .. math::\n\n        \\epsilon(f) = \\epsilon_\\infty + \\sum_i\n        \\frac{\\Delta\\epsilon_i f_i^2}{f_i^2 - 2jf\\delta_i - f^2}\n\nExample\n-------\n>>> x = np.linspace(-1, 1, 5)\n>>> y = np.linspace(-1, 1, 6)\n>>> z = np.linspace(-1, 1, 7)\n>>> coords = dict(x=x, y=y, z=z)\n>>> eps_inf = SpatialDataArray(np.ones((5, 6, 7)), coords=coords)\n>>> d_epsilon = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> f = SpatialDataArray(1+np.random.random((5, 6, 7)), coords=coords)\n>>> delta = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> lorentz_medium = CustomLorentz(eps_inf=eps_inf, coeffs=[(d_epsilon,f,delta),])\n>>> eps = lorentz_medium.eps_model(200e12)\n\nSee Also\n--------\n\n:class:`CustomPoleResidue`:\n    A spatially varying dispersive medium described by the pole-residue pair model.\n\n**Notebooks**\n    * `Fitting dispersive material models <../../notebooks/Fitting.html>`_\n\n**Lectures**\n    * `Modeling dispersive material in FDTD <https://www.flexcompute.com/fdtd101/Lecture-5-Modeling-dispersive-material-in-FDTD/>`_",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "CustomLorentz",
          "enum": [
            "CustomLorentz"
          ],
          "type": "string"
        },
        "eps_inf": {
          "title": "DataArray",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "units": "None (relative permittivity)",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "coeffs": {
          "title": "Coefficients",
          "description": "List of (:math:`\\Delta\\epsilon_i, f_i, \\delta_i`) values for model.",
          "units": [
            "None (relative permittivity)",
            "Hz",
            "Hz"
          ],
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 3,
            "maxItems": 3,
            "items": [
              {
                "title": "DataArray",
                "type": "xr.DataArray",
                "properties": {
                  "_dims": {
                    "title": "_dims",
                    "type": "Tuple[str, ...]"
                  }
                },
                "required": [
                  "_dims"
                ]
              },
              {
                "title": "DataArray",
                "type": "xr.DataArray",
                "properties": {
                  "_dims": {
                    "title": "_dims",
                    "type": "Tuple[str, ...]"
                  }
                },
                "required": [
                  "_dims"
                ]
              },
              {
                "title": "DataArray",
                "type": "xr.DataArray",
                "properties": {
                  "_dims": {
                    "title": "_dims",
                    "type": "Tuple[str, ...]"
                  }
                },
                "required": [
                  "_dims"
                ]
              }
            ]
          }
        },
        "interp_method": {
          "title": "Interpolation method",
          "description": "Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.",
          "default": "nearest",
          "enum": [
            "nearest",
            "linear"
          ],
          "type": "string"
        },
        "subpixel": {
          "title": "Subpixel averaging",
          "description": "If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.",
          "default": false,
          "type": "boolean"
        }
      },
      "required": [
        "eps_inf",
        "coeffs"
      ],
      "additionalProperties": false
    },
    "CustomDebye": {
      "title": "CustomDebye",
      "description": "A spatially varying dispersive medium described by the Debye model.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\neps_inf : SpatialDataArray\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\ncoeffs : Tuple[Tuple[tidy3d.components.data.data_array.SpatialDataArray, tidy3d.components.data.data_array.SpatialDataArray], ...]\n    [units = (None (relative permittivity), sec)].  List of (:math:`\\Delta\\epsilon_i, \\tau_i`) values for model.\ninterp_method : Literal['nearest', 'linear'] = nearest\n    Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.\nsubpixel : bool = False\n    If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.\n\nNotes\n-----\n\n    The frequency-dependence of the complex-valued permittivity is described by:\n\n    .. math::\n\n        \\epsilon(f) = \\epsilon_\\infty + \\sum_i\n        \\frac{\\Delta\\epsilon_i}{1 - jf\\tau_i}\n\nExample\n-------\n>>> x = np.linspace(-1, 1, 5)\n>>> y = np.linspace(-1, 1, 6)\n>>> z = np.linspace(-1, 1, 7)\n>>> coords = dict(x=x, y=y, z=z)\n>>> eps_inf = SpatialDataArray(1+np.random.random((5, 6, 7)), coords=coords)\n>>> eps1 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> tau1 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> debye_medium = CustomDebye(eps_inf=eps_inf, coeffs=[(eps1,tau1),])\n>>> eps = debye_medium.eps_model(200e12)\n\nSee Also\n--------\n\n:class:`Debye`\n    A dispersive medium described by the Debye model.\n\n**Notebooks**\n    * `Fitting dispersive material models <../../notebooks/Fitting.html>`_\n\n**Lectures**\n    * `Modeling dispersive material in FDTD <https://www.flexcompute.com/fdtd101/Lecture-5-Modeling-dispersive-material-in-FDTD/>`_",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "CustomDebye",
          "enum": [
            "CustomDebye"
          ],
          "type": "string"
        },
        "eps_inf": {
          "title": "DataArray",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "units": "None (relative permittivity)",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "coeffs": {
          "title": "Coefficients",
          "description": "List of (:math:`\\Delta\\epsilon_i, \\tau_i`) values for model.",
          "units": [
            "None (relative permittivity)",
            "sec"
          ],
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "title": "DataArray",
                "type": "xr.DataArray",
                "properties": {
                  "_dims": {
                    "title": "_dims",
                    "type": "Tuple[str, ...]"
                  }
                },
                "required": [
                  "_dims"
                ]
              },
              {
                "title": "DataArray",
                "type": "xr.DataArray",
                "properties": {
                  "_dims": {
                    "title": "_dims",
                    "type": "Tuple[str, ...]"
                  }
                },
                "required": [
                  "_dims"
                ]
              }
            ]
          }
        },
        "interp_method": {
          "title": "Interpolation method",
          "description": "Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.",
          "default": "nearest",
          "enum": [
            "nearest",
            "linear"
          ],
          "type": "string"
        },
        "subpixel": {
          "title": "Subpixel averaging",
          "description": "If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.",
          "default": false,
          "type": "boolean"
        }
      },
      "required": [
        "eps_inf",
        "coeffs"
      ],
      "additionalProperties": false
    },
    "CustomDrude": {
      "title": "CustomDrude",
      "description": "A spatially varying dispersive medium described by the Drude model.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\neps_inf : SpatialDataArray\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\ncoeffs : Tuple[Tuple[tidy3d.components.data.data_array.SpatialDataArray, tidy3d.components.data.data_array.SpatialDataArray], ...]\n    [units = (Hz, Hz)].  List of (:math:`f_i, \\delta_i`) values for model.\ninterp_method : Literal['nearest', 'linear'] = nearest\n    Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.\nsubpixel : bool = False\n    If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.\n\n\nNotes\n-----\n\n    The frequency-dependence of the complex-valued permittivity is described by:\n\n    .. math::\n\n        \\epsilon(f) = \\epsilon_\\infty - \\sum_i\n        \\frac{ f_i^2}{f^2 + jf\\delta_i}\n\nExample\n-------\n>>> x = np.linspace(-1, 1, 5)\n>>> y = np.linspace(-1, 1, 6)\n>>> z = np.linspace(-1, 1, 7)\n>>> coords = dict(x=x, y=y, z=z)\n>>> eps_inf = SpatialDataArray(np.ones((5, 6, 7)), coords=coords)\n>>> f1 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> delta1 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> drude_medium = CustomDrude(eps_inf=eps_inf, coeffs=[(f1,delta1),])\n>>> eps = drude_medium.eps_model(200e12)\n\nSee Also\n--------\n\n:class:`Drude`:\n    A dispersive medium described by the Drude model.\n\n**Notebooks**\n    * `Fitting dispersive material models <../../notebooks/Fitting.html>`_\n\n**Lectures**\n    * `Modeling dispersive material in FDTD <https://www.flexcompute.com/fdtd101/Lecture-5-Modeling-dispersive-material-in-FDTD/>`_",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "CustomDrude",
          "enum": [
            "CustomDrude"
          ],
          "type": "string"
        },
        "eps_inf": {
          "title": "DataArray",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "units": "None (relative permittivity)",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "coeffs": {
          "title": "Coefficients",
          "description": "List of (:math:`f_i, \\delta_i`) values for model.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "title": "DataArray",
                "type": "xr.DataArray",
                "properties": {
                  "_dims": {
                    "title": "_dims",
                    "type": "Tuple[str, ...]"
                  }
                },
                "required": [
                  "_dims"
                ]
              },
              {
                "title": "DataArray",
                "type": "xr.DataArray",
                "properties": {
                  "_dims": {
                    "title": "_dims",
                    "type": "Tuple[str, ...]"
                  }
                },
                "required": [
                  "_dims"
                ]
              }
            ]
          }
        },
        "interp_method": {
          "title": "Interpolation method",
          "description": "Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.",
          "default": "nearest",
          "enum": [
            "nearest",
            "linear"
          ],
          "type": "string"
        },
        "subpixel": {
          "title": "Subpixel averaging",
          "description": "If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.",
          "default": false,
          "type": "boolean"
        }
      },
      "required": [
        "eps_inf",
        "coeffs"
      ],
      "additionalProperties": false
    },
    "CustomAnisotropicMedium": {
      "title": "CustomAnisotropicMedium",
      "description": "Diagonally anisotropic medium with spatially varying permittivity in each component.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : Optional[bool] = None\n    This field is ignored. Please set ``allow_gain`` in each component\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\nxx : Union[CustomPoleResidue, CustomSellmeier, CustomLorentz, CustomDebye, CustomDrude, CustomMedium]\n    Medium describing the xx-component of the diagonal permittivity tensor.\nyy : Union[CustomPoleResidue, CustomSellmeier, CustomLorentz, CustomDebye, CustomDrude, CustomMedium]\n    Medium describing the yy-component of the diagonal permittivity tensor.\nzz : Union[CustomPoleResidue, CustomSellmeier, CustomLorentz, CustomDebye, CustomDrude, CustomMedium]\n    Medium describing the zz-component of the diagonal permittivity tensor.\ninterp_method : Optional[Literal['nearest', 'linear']] = None\n    When the value is 'None', each component will follow its own interpolation method. When the value is other than 'None', the interpolation method specified by this field will override the one in each component.\nsubpixel : Optional[bool] = None\n    This field is ignored. Please set ``subpixel`` in each component\n\nNote\n----\n    Only diagonal anisotropy is currently supported.\n\nExample\n-------\n>>> Nx, Ny, Nz = 10, 9, 8\n>>> x = np.linspace(-1, 1, Nx)\n>>> y = np.linspace(-1, 1, Ny)\n>>> z = np.linspace(-1, 1, Nz)\n>>> coords = dict(x=x, y=y, z=z)\n>>> permittivity= SpatialDataArray(np.ones((Nx, Ny, Nz)), coords=coords)\n>>> conductivity= SpatialDataArray(np.ones((Nx, Ny, Nz)), coords=coords)\n>>> medium_xx = CustomMedium(permittivity=permittivity, conductivity=conductivity)\n>>> medium_yy = CustomMedium(permittivity=permittivity, conductivity=conductivity)\n>>> d_epsilon = SpatialDataArray(np.random.random((Nx, Ny, Nz)), coords=coords)\n>>> f = SpatialDataArray(1+np.random.random((Nx, Ny, Nz)), coords=coords)\n>>> delta = SpatialDataArray(np.random.random((Nx, Ny, Nz)), coords=coords)\n>>> medium_zz = CustomLorentz(eps_inf=permittivity, coeffs=[(d_epsilon,f,delta),])\n>>> anisotropic_dielectric = CustomAnisotropicMedium(xx=medium_xx, yy=medium_yy, zz=medium_zz)\n\nSee Also\n--------\n\n:class:`AnisotropicMedium`\n    Diagonally anisotropic medium.\n\n**Notebooks**\n    * `Broadband polarizer assisted by anisotropic metamaterial <../../notebooks/SWGBroadbandPolarizer.html>`_\n    * `Thin film lithium niobate adiabatic waveguide coupler <../../notebooks/AdiabaticCouplerLN.html>`_\n    * `Defining fully anisotropic materials <../../notebooks/FullyAnisotropic.html>`_",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "This field is ignored. Please set ``allow_gain`` in each component",
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "CustomAnisotropicMedium",
          "enum": [
            "CustomAnisotropicMedium"
          ],
          "type": "string"
        },
        "xx": {
          "title": "XX Component",
          "description": "Medium describing the xx-component of the diagonal permittivity tensor.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "CustomPoleResidue": "#/definitions/CustomPoleResidue",
              "CustomSellmeier": "#/definitions/CustomSellmeier",
              "CustomLorentz": "#/definitions/CustomLorentz",
              "CustomDebye": "#/definitions/CustomDebye",
              "CustomDrude": "#/definitions/CustomDrude",
              "CustomMedium": "#/definitions/CustomMedium"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/CustomPoleResidue"
            },
            {
              "$ref": "#/definitions/CustomSellmeier"
            },
            {
              "$ref": "#/definitions/CustomLorentz"
            },
            {
              "$ref": "#/definitions/CustomDebye"
            },
            {
              "$ref": "#/definitions/CustomDrude"
            },
            {
              "$ref": "#/definitions/CustomMedium"
            }
          ]
        },
        "yy": {
          "title": "YY Component",
          "description": "Medium describing the yy-component of the diagonal permittivity tensor.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "CustomPoleResidue": "#/definitions/CustomPoleResidue",
              "CustomSellmeier": "#/definitions/CustomSellmeier",
              "CustomLorentz": "#/definitions/CustomLorentz",
              "CustomDebye": "#/definitions/CustomDebye",
              "CustomDrude": "#/definitions/CustomDrude",
              "CustomMedium": "#/definitions/CustomMedium"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/CustomPoleResidue"
            },
            {
              "$ref": "#/definitions/CustomSellmeier"
            },
            {
              "$ref": "#/definitions/CustomLorentz"
            },
            {
              "$ref": "#/definitions/CustomDebye"
            },
            {
              "$ref": "#/definitions/CustomDrude"
            },
            {
              "$ref": "#/definitions/CustomMedium"
            }
          ]
        },
        "zz": {
          "title": "ZZ Component",
          "description": "Medium describing the zz-component of the diagonal permittivity tensor.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "CustomPoleResidue": "#/definitions/CustomPoleResidue",
              "CustomSellmeier": "#/definitions/CustomSellmeier",
              "CustomLorentz": "#/definitions/CustomLorentz",
              "CustomDebye": "#/definitions/CustomDebye",
              "CustomDrude": "#/definitions/CustomDrude",
              "CustomMedium": "#/definitions/CustomMedium"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/CustomPoleResidue"
            },
            {
              "$ref": "#/definitions/CustomSellmeier"
            },
            {
              "$ref": "#/definitions/CustomLorentz"
            },
            {
              "$ref": "#/definitions/CustomDebye"
            },
            {
              "$ref": "#/definitions/CustomDrude"
            },
            {
              "$ref": "#/definitions/CustomMedium"
            }
          ]
        },
        "interp_method": {
          "title": "Interpolation method",
          "description": "When the value is 'None', each component will follow its own interpolation method. When the value is other than 'None', the interpolation method specified by this field will override the one in each component.",
          "enum": [
            "nearest",
            "linear"
          ],
          "type": "string"
        },
        "subpixel": {
          "title": "Subpixel averaging",
          "description": "This field is ignored. Please set ``subpixel`` in each component",
          "type": "boolean"
        }
      },
      "required": [
        "xx",
        "yy",
        "zz"
      ],
      "additionalProperties": false
    },
    "LinearHeatPerturbation": {
      "title": "LinearHeatPerturbation",
      "description": "Specifies parameter's perturbation due to thermal effects as a linear function of\ntemperature.\n\nParameters\n----------\ntemperature_range : Tuple[NonNegativeFloat, NonNegativeFloat] = (0, inf)\n    [units = K].  Temperature range in which perturbation model is valid.\ntemperature_ref : NonNegativeFloat\n    [units = K].  Temperature at which perturbation is zero.\ncoeff : Union[float, tidycomplex, ComplexNumber]\n    [units = 1/K].  Sensitivity (derivative) of perturbation with respect to temperature.\n\nNotes\n-----\n\n    .. math::\n\n        \\Delta X (T) = \\text{coeff} \\times (T - \\text{temperature\\_ref}),\n\n    where ``coeff`` is the parameter's sensitivity (thermo-optic coefficient) to temperature and\n    ``temperature_ref`` is the reference temperature point. A temperature range in which such\n    a model is deemed accurate may be provided as a field ``temperature_range``\n    (default: ``[0, inf]``). Wherever is applied, Tidy3D will check that the parameter's value\n    does not go out of its physical bounds within ``temperature_range`` due to perturbations and\n    raise a warning if this check fails. A warning is also issued if the perturbation model is\n    evaluated outside of ``temperature_range``.\n\n    .. TODO link to relevant example new\n\nExample\n-------\n>>> heat_perturb = LinearHeatPerturbation(\n...     temperature_ref=300,\n...     coeff=0.0001,\n...     temperature_range=[200, 500],\n... )",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "LinearHeatPerturbation",
          "enum": [
            "LinearHeatPerturbation"
          ],
          "type": "string"
        },
        "temperature_range": {
          "title": "Temperature range",
          "description": "Temperature range in which perturbation model is valid.",
          "default": [
            0,
            Infinity
          ],
          "units": "K",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "temperature_ref": {
          "title": "Reference temperature",
          "description": "Temperature at which perturbation is zero.",
          "units": "K",
          "minimum": 0,
          "type": "number"
        },
        "coeff": {
          "title": "Thermo-optic Coefficient",
          "description": "Sensitivity (derivative) of perturbation with respect to temperature.",
          "units": "1/K",
          "anyOf": [
            {
              "type": "number"
            },
            {
              "title": "ComplexNumber",
              "description": "Complex number with a well defined schema.",
              "type": "object",
              "properties": {
                "real": {
                  "title": "Real",
                  "type": "number"
                },
                "imag": {
                  "title": "Imag",
                  "type": "number"
                }
              },
              "required": [
                "real",
                "imag"
              ]
            },
            {
              "$ref": "#/definitions/ComplexNumber"
            }
          ]
        }
      },
      "required": [
        "temperature_ref",
        "coeff"
      ],
      "additionalProperties": false
    },
    "CustomHeatPerturbation": {
      "title": "CustomHeatPerturbation",
      "description": "Specifies parameter's perturbation due to thermal effects as a custom function of\ntemperature defined as an array of perturbation values at sample temperature points.\n\nParameters\n----------\ntemperature_range : Optional[Tuple[NonNegativeFloat, NonNegativeFloat]] = None\n    [units = K].  Temperature range in which perturbation model is valid. For :class:`.CustomHeatPerturbation` this field is computed automatically based on temperature sample points provided in ``perturbation_values``.\nperturbation_values : HeatDataArray\n    Sampled perturbation values.\ninterp_method : Literal['nearest', 'linear'] = linear\n    Interpolation method to obtain perturbation values between sample points.\n\n Notes\n -----\n\n     The linear\n    interpolation is used to calculate perturbation values between sample temperature points. For\n    temperature values outside of the provided sample region the perturbation value is extrapolated\n    as a constant.\n    The temperature range, ``temperature_range``, in which the perturbation model is assumed to be\n    accurate is calculated automatically as the minimal and maximal sample temperature points.\n    Wherever is applied, Tidy3D will check that the parameter's value\n    does not go out of its physical bounds within ``temperature_range`` due to perturbations and\n    raise a warning if this check fails. A warning is also issued if the perturbation model is\n    evaluated outside of ``temperature_range``.\n\n    .. TODO link to relevant example new\n\nExample\n-------\n>>> from tidy3d import HeatDataArray\n>>> perturbation_data = HeatDataArray([0.001, 0.002, 0.004], coords=dict(T=[250, 300, 350]))\n>>> heat_perturb = CustomHeatPerturbation(\n...     perturbation_values=perturbation_data\n... )",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "CustomHeatPerturbation",
          "enum": [
            "CustomHeatPerturbation"
          ],
          "type": "string"
        },
        "temperature_range": {
          "title": "Temperature range",
          "description": "Temperature range in which perturbation model is valid. For :class:`.CustomHeatPerturbation` this field is computed automatically based on temperature sample points provided in ``perturbation_values``.",
          "units": "K",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "perturbation_values": {
          "title": "DataArray",
          "description": "Sampled perturbation values.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "interp_method": {
          "title": "Interpolation method",
          "description": "Interpolation method to obtain perturbation values between sample points.",
          "default": "linear",
          "enum": [
            "nearest",
            "linear"
          ],
          "type": "string"
        }
      },
      "required": [
        "perturbation_values"
      ],
      "additionalProperties": false
    },
    "LinearChargePerturbation": {
      "title": "LinearChargePerturbation",
      "description": "Specifies parameter's perturbation due to free carrier effects as a linear function of\nelectron and hole densities:\n\nParameters\n----------\nelectron_range : Tuple[NonNegativeFloat, NonNegativeFloat] = (0, inf)\n    Range of electrons densities in which perturbation model is valid.\nhole_range : Tuple[NonNegativeFloat, NonNegativeFloat] = (0, inf)\n    Range of holes densities in which perturbation model is valid.\nelectron_ref : NonNegativeFloat\n    [units = 1/cm^3].  Electron density value at which there is no perturbation due to electrons's presence.\nhole_ref : NonNegativeFloat\n    [units = 1/cm^3].  Hole density value at which there is no perturbation due to holes' presence.\nelectron_coeff : float\n    [units = cm^3].  Sensitivity (derivative) of perturbation with respect to electron density.\nhole_coeff : float\n    [units = cm^3].  Sensitivity (derivative) of perturbation with respect to hole density.\n\nNotes\n-----\n\n    .. math::\n\n        \\Delta X (T) = \\text{electron\\_coeff} \\times (N_e - \\text{electron\\_ref})\n        + \\text{hole\\_coeff} \\times (N_h - \\text{hole\\_ref}),\n\n    where ``electron_coeff`` and ``hole_coeff`` are the parameter's sensitivities to electron and\n    hole densities, while ``electron_ref`` and ``hole_ref`` are reference electron and hole density\n    values. Ranges of electron and hole densities in which such\n    a model is deemed accurate may be provided as fields ``electron_range`` and ``hole_range``\n    (default: ``[0, inf]`` each). Wherever is applied, Tidy3D will check that the parameter's value\n    does not go out of its physical bounds within ``electron_range`` x ``hole_range`` due to\n    perturbations and raise a warning if this check fails. A warning is also issued if\n    the perturbation model is evaluated outside of ``electron_range`` x ``hole_range``.\n\n    .. TODO add example here and links\n\nExample\n-------\n>>> charge_perturb = LinearChargePerturbation(\n...     electron_ref=0,\n...     electron_coeff=0.0001,\n...     electron_range=[0, 1e19],\n...     hole_ref=0,\n...     hole_coeff=0.0002,\n...     hole_range=[0, 2e19],\n... )",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "LinearChargePerturbation",
          "enum": [
            "LinearChargePerturbation"
          ],
          "type": "string"
        },
        "electron_range": {
          "title": "Electron Density Range",
          "description": "Range of electrons densities in which perturbation model is valid.",
          "default": [
            0,
            Infinity
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "hole_range": {
          "title": "Hole Density Range",
          "description": "Range of holes densities in which perturbation model is valid.",
          "default": [
            0,
            Infinity
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "electron_ref": {
          "title": "Reference Electron Density",
          "description": "Electron density value at which there is no perturbation due to electrons's presence.",
          "units": "1/cm^3",
          "minimum": 0,
          "type": "number"
        },
        "hole_ref": {
          "title": "Reference Hole Density",
          "description": "Hole density value at which there is no perturbation due to holes' presence.",
          "units": "1/cm^3",
          "minimum": 0,
          "type": "number"
        },
        "electron_coeff": {
          "title": "Sensitivity to Electron Density",
          "description": "Sensitivity (derivative) of perturbation with respect to electron density.",
          "units": "cm^3",
          "type": "number"
        },
        "hole_coeff": {
          "title": "Sensitivity to Hole Density",
          "description": "Sensitivity (derivative) of perturbation with respect to hole density.",
          "units": "cm^3",
          "type": "number"
        }
      },
      "required": [
        "electron_ref",
        "hole_ref",
        "electron_coeff",
        "hole_coeff"
      ],
      "additionalProperties": false
    },
    "CustomChargePerturbation": {
      "title": "CustomChargePerturbation",
      "description": "Specifies parameter's perturbation due to free carrier effects as a custom function of\nelectron and hole densities defined as a two-dimensional array of perturbation values at sample\nelectron and hole density points.\n\nParameters\n----------\nelectron_range : Optional[Tuple[NonNegativeFloat, NonNegativeFloat]] = None\n    Range of electrons densities in which perturbation model is valid. For :class:`.CustomChargePerturbation` this field is computed automatically based on provided ``perturbation_values``\nhole_range : Optional[Tuple[NonNegativeFloat, NonNegativeFloat]] = None\n    Range of holes densities in which perturbation model is valid. For :class:`.CustomChargePerturbation` this field is computed automatically based on provided ``perturbation_values``\nperturbation_values : ChargeDataArray\n    2D array (vs electron and hole densities) of sampled perturbation values.\ninterp_method : Literal['nearest', 'linear'] = linear\n    Interpolation method to obtain perturbation values between sample points.\n\nNotes\n-----\n\n    The linear interpolation is used to calculate perturbation\n    values between sample points. For electron and hole density values outside of the provided\n    sample region the perturbation value is extrapolated as a constant.\n    The electron and hole density ranges, ``electron_range`` and ``hole_range``, in which\n    the perturbation model is assumed to be accurate is calculated automatically as the minimal and\n    maximal density values provided in ``perturbation_values``. Wherever is applied, Tidy3D will\n    check that the parameter's value does not go out of its physical bounds within\n    ``electron_range`` x ``hole_range`` due to perturbations and raise a warning if this check\n    fails. A warning is also issued if the perturbation model is evaluated outside of\n    ``electron_range`` x ``hole_range``.\n\n    .. TODO add example here and links\n\nExample\n-------\n>>> from tidy3d import ChargeDataArray\n>>> perturbation_data = ChargeDataArray(\n...     [[0.001, 0.002, 0.004], [0.003, 0.002, 0.001]],\n...     coords=dict(n=[2e15, 2e19], p=[1e16, 1e17, 1e18]),\n... )\n>>> charge_perturb = CustomChargePerturbation(\n...     perturbation_values=perturbation_data,\n... )",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "CustomChargePerturbation",
          "enum": [
            "CustomChargePerturbation"
          ],
          "type": "string"
        },
        "electron_range": {
          "title": "Electron Density Range",
          "description": "Range of electrons densities in which perturbation model is valid. For :class:`.CustomChargePerturbation` this field is computed automatically based on provided ``perturbation_values``",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "hole_range": {
          "title": "Hole Density Range",
          "description": "Range of holes densities in which perturbation model is valid. For :class:`.CustomChargePerturbation` this field is computed automatically based on provided ``perturbation_values``",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "perturbation_values": {
          "title": "DataArray",
          "description": "2D array (vs electron and hole densities) of sampled perturbation values.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "interp_method": {
          "title": "Interpolation method",
          "description": "Interpolation method to obtain perturbation values between sample points.",
          "default": "linear",
          "enum": [
            "nearest",
            "linear"
          ],
          "type": "string"
        }
      },
      "required": [
        "perturbation_values"
      ],
      "additionalProperties": false
    },
    "ParameterPerturbation": {
      "title": "ParameterPerturbation",
      "description": "Stores information about parameter perturbations due to different physical effect. If both\nheat and charge perturbation models are included their effects are superimposed.\n\nParameters\n----------\nheat : Union[LinearHeatPerturbation, CustomHeatPerturbation] = None\n    Heat perturbation to apply.\ncharge : Union[LinearChargePerturbation, CustomChargePerturbation] = None\n    Charge perturbation to apply.\n\nExample\n-------\n>>> from tidy3d import LinearChargePerturbation, CustomHeatPerturbation, HeatDataArray\n>>>\n>>> perturbation_data = HeatDataArray([0.001, 0.002, 0.004], coords=dict(T=[250, 300, 350]))\n>>> heat_perturb = CustomHeatPerturbation(\n...     perturbation_values=perturbation_data\n... )\n>>> charge_perturb = LinearChargePerturbation(\n...     electron_ref=0,\n...     electron_coeff=0.0001,\n...     electron_range=[0, 1e19],\n...     hole_ref=0,\n...     hole_coeff=0.0002,\n...     hole_range=[0, 2e19],\n... )\n>>> param_perturb = ParameterPerturbation(heat=heat_perturb, charge=charge_perturb)",
      "type": "object",
      "properties": {
        "heat": {
          "title": "Heat Perturbation",
          "description": "Heat perturbation to apply.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "LinearHeatPerturbation": "#/definitions/LinearHeatPerturbation",
              "CustomHeatPerturbation": "#/definitions/CustomHeatPerturbation"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/LinearHeatPerturbation"
            },
            {
              "$ref": "#/definitions/CustomHeatPerturbation"
            }
          ]
        },
        "charge": {
          "title": "Charge Perturbation",
          "description": "Charge perturbation to apply.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "LinearChargePerturbation": "#/definitions/LinearChargePerturbation",
              "CustomChargePerturbation": "#/definitions/CustomChargePerturbation"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/LinearChargePerturbation"
            },
            {
              "$ref": "#/definitions/CustomChargePerturbation"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "ParameterPerturbation",
          "enum": [
            "ParameterPerturbation"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PerturbationMedium": {
      "title": "PerturbationMedium",
      "description": "Dispersionless medium with perturbations.\n\nParameters\n----------\nsubpixel : bool = True\n    This value will be transferred to the resulting custom medium. That is, if ``True``, the subpixel averaging will be applied to the custom medium provided the corresponding ``Simulation``'s field ``subpixel`` is set to ``True`` as well. If the resulting medium is not a custom medium (no perturbations), this field does not have an effect.\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\npermittivity : ConstrainedFloatValue = 1.0\n    [units = None (relative permittivity)].  Relative permittivity.\nconductivity : float = 0.0\n    [units = S/um].  Electric conductivity. Defined such that the imaginary part of the complex permittivity at angular frequency omega is given by conductivity/omega.\npermittivity_perturbation : Optional[ParameterPerturbation] = None\n    [units = None (relative permittivity)].  List of heat and/or charge perturbations to permittivity.\nconductivity_perturbation : Optional[ParameterPerturbation] = None\n    [units = S/um].  List of heat and/or charge perturbations to permittivity.\n\nExample\n-------\n>>> from tidy3d import ParameterPerturbation, LinearHeatPerturbation\n>>> dielectric = PerturbationMedium(\n...     permittivity=4.0,\n...     permittivity_perturbation=ParameterPerturbation(\n...         heat=LinearHeatPerturbation(temperature_ref=300, coeff=0.0001),\n...     ),\n...     name='my_medium',\n... )",
      "type": "object",
      "properties": {
        "subpixel": {
          "title": "Subpixel averaging",
          "description": "This value will be transferred to the resulting custom medium. That is, if ``True``, the subpixel averaging will be applied to the custom medium provided the corresponding ``Simulation``'s field ``subpixel`` is set to ``True`` as well. If the resulting medium is not a custom medium (no perturbations), this field does not have an effect.",
          "default": true,
          "type": "boolean"
        },
        "type": {
          "title": "Type",
          "default": "PerturbationMedium",
          "enum": [
            "PerturbationMedium"
          ],
          "type": "string"
        },
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "permittivity": {
          "title": "Permittivity",
          "description": "Relative permittivity.",
          "default": 1.0,
          "minimum": 1.0,
          "units": "None (relative permittivity)",
          "type": "number"
        },
        "conductivity": {
          "title": "Conductivity",
          "description": "Electric conductivity. Defined such that the imaginary part of the complex permittivity at angular frequency omega is given by conductivity/omega.",
          "default": 0.0,
          "units": "S/um",
          "type": "number"
        },
        "permittivity_perturbation": {
          "title": "Permittivity Perturbation",
          "description": "List of heat and/or charge perturbations to permittivity.",
          "units": "None (relative permittivity)",
          "allOf": [
            {
              "$ref": "#/definitions/ParameterPerturbation"
            }
          ]
        },
        "conductivity_perturbation": {
          "title": "Permittivity Perturbation",
          "description": "List of heat and/or charge perturbations to permittivity.",
          "units": "S/um",
          "allOf": [
            {
              "$ref": "#/definitions/ParameterPerturbation"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "PerturbationPoleResidue": {
      "title": "PerturbationPoleResidue",
      "description": "A dispersive medium described by the pole-residue pair model with perturbations.\n\nParameters\n----------\nsubpixel : bool = True\n    This value will be transferred to the resulting custom medium. That is, if ``True``, the subpixel averaging will be applied to the custom medium provided the corresponding ``Simulation``'s field ``subpixel`` is set to ``True`` as well. If the resulting medium is not a custom medium (no perturbations), this field does not have an effect.\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\neps_inf : PositiveFloat = 1.0\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\npoles : Tuple[Tuple[Union[tidy3d.components.types.tidycomplex, tidy3d.components.types.ComplexNumber], Union[tidy3d.components.types.tidycomplex, tidy3d.components.types.ComplexNumber]], ...] = ()\n    [units = (rad/sec, rad/sec)].  Tuple of complex-valued (:math:`a_i, c_i`) poles for the model.\neps_inf_perturbation : Optional[ParameterPerturbation] = None\n    [units = None (relative permittivity)].  Perturbations to relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\npoles_perturbation : Tuple[Tuple[Optional[tidy3d.components.parameter_perturbation.ParameterPerturbation], Optional[tidy3d.components.parameter_perturbation.ParameterPerturbation]], ...] = ()\n    [units = (rad/sec, rad/sec)].  Perturbations to poles of the model.\n\nNotes\n-----\n\n    The frequency-dependence of the complex-valued permittivity is described by:\n\n    .. math::\n\n        \\epsilon(\\omega) = \\epsilon_\\infty - \\sum_i\n        \\left[\\frac{c_i}{j \\omega + a_i} +\n        \\frac{c_i^*}{j \\omega + a_i^*}\\right]\n\nExample\n-------\n>>> from tidy3d import ParameterPerturbation, LinearHeatPerturbation\n>>> c0_perturbation = ParameterPerturbation(\n...     heat=LinearHeatPerturbation(temperature_ref=300, coeff=0.0001),\n... )\n>>> pole_res = PerturbationPoleResidue(\n...     eps_inf=2.0,\n...     poles=[((-1+2j), (3+4j)), ((-5+6j), (7+8j))],\n...     poles_perturbation=[(None, c0_perturbation), (None, None)],\n... )",
      "type": "object",
      "properties": {
        "subpixel": {
          "title": "Subpixel averaging",
          "description": "This value will be transferred to the resulting custom medium. That is, if ``True``, the subpixel averaging will be applied to the custom medium provided the corresponding ``Simulation``'s field ``subpixel`` is set to ``True`` as well. If the resulting medium is not a custom medium (no perturbations), this field does not have an effect.",
          "default": true,
          "type": "boolean"
        },
        "type": {
          "title": "Type",
          "default": "PerturbationPoleResidue",
          "enum": [
            "PerturbationPoleResidue"
          ],
          "type": "string"
        },
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "eps_inf": {
          "title": "Epsilon at Infinity",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "default": 1.0,
          "units": "None (relative permittivity)",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "poles": {
          "title": "Poles",
          "description": "Tuple of complex-valued (:math:`a_i, c_i`) poles for the model.",
          "default": [],
          "units": [
            "rad/sec",
            "rad/sec"
          ],
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "anyOf": [
                  {
                    "title": "ComplexNumber",
                    "description": "Complex number with a well defined schema.",
                    "type": "object",
                    "properties": {
                      "real": {
                        "title": "Real",
                        "type": "number"
                      },
                      "imag": {
                        "title": "Imag",
                        "type": "number"
                      }
                    },
                    "required": [
                      "real",
                      "imag"
                    ]
                  },
                  {
                    "$ref": "#/definitions/ComplexNumber"
                  }
                ]
              },
              {
                "anyOf": [
                  {
                    "title": "ComplexNumber",
                    "description": "Complex number with a well defined schema.",
                    "type": "object",
                    "properties": {
                      "real": {
                        "title": "Real",
                        "type": "number"
                      },
                      "imag": {
                        "title": "Imag",
                        "type": "number"
                      }
                    },
                    "required": [
                      "real",
                      "imag"
                    ]
                  },
                  {
                    "$ref": "#/definitions/ComplexNumber"
                  }
                ]
              }
            ]
          }
        },
        "eps_inf_perturbation": {
          "title": "Perturbation of Epsilon at Infinity",
          "description": "Perturbations to relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "units": "None (relative permittivity)",
          "allOf": [
            {
              "$ref": "#/definitions/ParameterPerturbation"
            }
          ]
        },
        "poles_perturbation": {
          "title": "Perturbations of Poles",
          "description": "Perturbations to poles of the model.",
          "default": [],
          "units": [
            "rad/sec",
            "rad/sec"
          ],
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "$ref": "#/definitions/ParameterPerturbation"
              },
              {
                "$ref": "#/definitions/ParameterPerturbation"
              }
            ]
          }
        }
      },
      "additionalProperties": false
    },
    "Box": {
      "title": "Box",
      "description": "Rectangular prism.\n   Also base class for :class:`Simulation`, :class:`Monitor`, and :class:`Source`.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\n\nExample\n-------\n>>> b = Box(center=(1,2,3), size=(2,2,2))",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "Box",
          "enum": [
            "Box"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        }
      },
      "required": [
        "size"
      ],
      "additionalProperties": false
    },
    "Sphere": {
      "title": "Sphere",
      "description": "Spherical geometry.\n\nParameters\n----------\nradius : NonNegativeFloat\n    [units = um].  Radius of geometry.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\n\nExample\n-------\n>>> b = Sphere(center=(1,2,3), radius=2)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "Sphere",
          "enum": [
            "Sphere"
          ],
          "type": "string"
        },
        "radius": {
          "title": "Radius",
          "description": "Radius of geometry.",
          "units": "um",
          "minimum": 0,
          "type": "number"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        }
      },
      "required": [
        "radius"
      ],
      "additionalProperties": false
    },
    "Cylinder": {
      "title": "Cylinder",
      "description": "Cylindrical geometry with optional sidewall angle along axis\ndirection. When ``sidewall_angle`` is nonzero, the shape is a\nconical frustum or a cone.\n\nParameters\n----------\naxis : Literal[0, 1, 2] = 2\n    Specifies dimension of the planar axis (0,1,2) -> (x,y,z).\nsidewall_angle : ConstrainedFloatValue = 0.0\n    [units = rad].  Angle of the sidewall. ``sidewall_angle=0`` (default) specifies a vertical wall; ``0<sidewall_angle<np.pi/2`` specifies a shrinking cross section along the ``axis`` direction; and ``-np.pi/2<sidewall_angle<0`` specifies an expanding cross section along the ``axis`` direction.\nreference_plane : Literal['bottom', 'middle', 'top'] = middle\n    The position of the plane where the supplied cross section are defined. The plane is perpendicular to the ``axis``. The plane is located at the ``bottom``, ``middle``, or ``top`` of the geometry with respect to the axis. E.g. if ``axis=1``, ``bottom`` refers to the negative side of the y-axis, and ``top`` refers to the positive side of the y-axis.\nradius : NonNegativeFloat\n    [units = um].  Radius of geometry at the ``reference_plane``.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nlength : NonNegativeFloat\n    [units = um].  Defines thickness of cylinder along axis dimension.\n\nExample\n-------\n>>> c = Cylinder(center=(1,2,3), radius=2, length=5, axis=2)\n\nSee Also\n--------\n\n**Notebooks**\n\n* `THz integrated demultiplexer/filter based on a ring resonator <../../../notebooks/THzDemultiplexerFilter.html>`_\n* `Photonic crystal waveguide polarization filter <../../../notebooks/PhotonicCrystalWaveguidePolarizationFilter.html>`_",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "Cylinder",
          "enum": [
            "Cylinder"
          ],
          "type": "string"
        },
        "axis": {
          "title": "Axis",
          "description": "Specifies dimension of the planar axis (0,1,2) -> (x,y,z).",
          "default": 2,
          "enum": [
            0,
            1,
            2
          ],
          "type": "integer"
        },
        "sidewall_angle": {
          "title": "Sidewall angle",
          "description": "Angle of the sidewall. ``sidewall_angle=0`` (default) specifies a vertical wall; ``0<sidewall_angle<np.pi/2`` specifies a shrinking cross section along the ``axis`` direction; and ``-np.pi/2<sidewall_angle<0`` specifies an expanding cross section along the ``axis`` direction.",
          "default": 0.0,
          "exclusiveMinimum": -1.5707963267948966,
          "exclusiveMaximum": 1.5707963267948966,
          "units": "rad",
          "type": "number"
        },
        "reference_plane": {
          "title": "Reference plane for cross section",
          "description": "The position of the plane where the supplied cross section are defined. The plane is perpendicular to the ``axis``. The plane is located at the ``bottom``, ``middle``, or ``top`` of the geometry with respect to the axis. E.g. if ``axis=1``, ``bottom`` refers to the negative side of the y-axis, and ``top`` refers to the positive side of the y-axis.",
          "default": "middle",
          "enum": [
            "bottom",
            "middle",
            "top"
          ],
          "type": "string"
        },
        "radius": {
          "title": "Radius",
          "description": "Radius of geometry at the ``reference_plane``.",
          "units": "um",
          "minimum": 0,
          "type": "number"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "length": {
          "title": "Length",
          "description": "Defines thickness of cylinder along axis dimension.",
          "units": "um",
          "minimum": 0,
          "type": "number"
        }
      },
      "required": [
        "radius",
        "length"
      ],
      "additionalProperties": false
    },
    "PolySlab": {
      "title": "PolySlab",
      "description": "Polygon extruded with optional sidewall angle along axis direction.\n\nParameters\n----------\naxis : Literal[0, 1, 2] = 2\n    Specifies dimension of the planar axis (0,1,2) -> (x,y,z).\nsidewall_angle : ConstrainedFloatValue = 0.0\n    [units = rad].  Angle of the sidewall. ``sidewall_angle=0`` (default) specifies a vertical wall; ``0<sidewall_angle<np.pi/2`` specifies a shrinking cross section along the ``axis`` direction; and ``-np.pi/2<sidewall_angle<0`` specifies an expanding cross section along the ``axis`` direction.\nreference_plane : Literal['bottom', 'middle', 'top'] = middle\n    The position of the plane where the supplied cross section are defined. The plane is perpendicular to the ``axis``. The plane is located at the ``bottom``, ``middle``, or ``top`` of the geometry with respect to the axis. E.g. if ``axis=1``, ``bottom`` refers to the negative side of the y-axis, and ``top`` refers to the positive side of the y-axis.\nslab_bounds : Tuple[float, float]\n    [units = um].  Minimum and maximum positions of the slab along axis dimension.\ndilation : float = 0.0\n    [units = um].  Dilation of the supplied polygon by shifting each edge along its normal outwards direction by a distance; a negative value corresponds to erosion.\nvertices : ArrayLike[dtype=float, ndim=2]\n    [units = um].  List of (d1, d2) defining the 2 dimensional positions of the polygon face vertices at the ``reference_plane``. The index of dimension should be in the ascending order: e.g. if the slab normal axis is ``axis=y``, the coordinate of the vertices will be in (x, z)\n\nExample\n-------\n>>> vertices = np.array([(0,0), (1,0), (1,1)])\n>>> p = PolySlab(vertices=vertices, axis=2, slab_bounds=(-1, 1))",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "PolySlab",
          "enum": [
            "PolySlab"
          ],
          "type": "string"
        },
        "axis": {
          "title": "Axis",
          "description": "Specifies dimension of the planar axis (0,1,2) -> (x,y,z).",
          "default": 2,
          "enum": [
            0,
            1,
            2
          ],
          "type": "integer"
        },
        "sidewall_angle": {
          "title": "Sidewall angle",
          "description": "Angle of the sidewall. ``sidewall_angle=0`` (default) specifies a vertical wall; ``0<sidewall_angle<np.pi/2`` specifies a shrinking cross section along the ``axis`` direction; and ``-np.pi/2<sidewall_angle<0`` specifies an expanding cross section along the ``axis`` direction.",
          "default": 0.0,
          "exclusiveMinimum": -1.5707963267948966,
          "exclusiveMaximum": 1.5707963267948966,
          "units": "rad",
          "type": "number"
        },
        "reference_plane": {
          "title": "Reference plane for cross section",
          "description": "The position of the plane where the supplied cross section are defined. The plane is perpendicular to the ``axis``. The plane is located at the ``bottom``, ``middle``, or ``top`` of the geometry with respect to the axis. E.g. if ``axis=1``, ``bottom`` refers to the negative side of the y-axis, and ``top`` refers to the positive side of the y-axis.",
          "default": "middle",
          "enum": [
            "bottom",
            "middle",
            "top"
          ],
          "type": "string"
        },
        "slab_bounds": {
          "title": "Slab Bounds",
          "description": "Minimum and maximum positions of the slab along axis dimension.",
          "units": "um",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "dilation": {
          "title": "Dilation",
          "description": "Dilation of the supplied polygon by shifting each edge along its normal outwards direction by a distance; a negative value corresponds to erosion.",
          "default": 0.0,
          "units": "um",
          "type": "number"
        },
        "vertices": {
          "title": "Vertices",
          "description": "List of (d1, d2) defining the 2 dimensional positions of the polygon face vertices at the ``reference_plane``. The index of dimension should be in the ascending order: e.g. if the slab normal axis is ``axis=y``, the coordinate of the vertices will be in (x, z)",
          "units": "um",
          "type": "ArrayLike"
        }
      },
      "required": [
        "slab_bounds",
        "vertices"
      ],
      "additionalProperties": false
    },
    "ComplexPolySlabBase": {
      "title": "ComplexPolySlabBase",
      "description": "Interface for dividing a complex polyslab where self-intersecting polygon can\noccur during extrusion. This class should not be used directly. Use instead\n:class:`plugins.polyslab.ComplexPolySlab`.\n\nParameters\n----------\naxis : Literal[0, 1, 2] = 2\n    Specifies dimension of the planar axis (0,1,2) -> (x,y,z).\nsidewall_angle : ConstrainedFloatValue = 0.0\n    [units = rad].  Angle of the sidewall. ``sidewall_angle=0`` (default) specifies a vertical wall; ``0<sidewall_angle<np.pi/2`` specifies a shrinking cross section along the ``axis`` direction; and ``-np.pi/2<sidewall_angle<0`` specifies an expanding cross section along the ``axis`` direction.\nreference_plane : Literal['bottom', 'middle', 'top'] = middle\n    The position of the plane where the supplied cross section are defined. The plane is perpendicular to the ``axis``. The plane is located at the ``bottom``, ``middle``, or ``top`` of the geometry with respect to the axis. E.g. if ``axis=1``, ``bottom`` refers to the negative side of the y-axis, and ``top`` refers to the positive side of the y-axis.\nslab_bounds : Tuple[float, float]\n    [units = um].  Minimum and maximum positions of the slab along axis dimension.\ndilation : float = 0.0\n    [units = um].  Dilation of the supplied polygon by shifting each edge along its normal outwards direction by a distance; a negative value corresponds to erosion.\nvertices : ArrayLike[dtype=float, ndim=2]\n    [units = um].  List of (d1, d2) defining the 2 dimensional positions of the polygon face vertices at the ``reference_plane``. The index of dimension should be in the ascending order: e.g. if the slab normal axis is ``axis=y``, the coordinate of the vertices will be in (x, z)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "ComplexPolySlabBase",
          "enum": [
            "ComplexPolySlabBase"
          ],
          "type": "string"
        },
        "axis": {
          "title": "Axis",
          "description": "Specifies dimension of the planar axis (0,1,2) -> (x,y,z).",
          "default": 2,
          "enum": [
            0,
            1,
            2
          ],
          "type": "integer"
        },
        "sidewall_angle": {
          "title": "Sidewall angle",
          "description": "Angle of the sidewall. ``sidewall_angle=0`` (default) specifies a vertical wall; ``0<sidewall_angle<np.pi/2`` specifies a shrinking cross section along the ``axis`` direction; and ``-np.pi/2<sidewall_angle<0`` specifies an expanding cross section along the ``axis`` direction.",
          "default": 0.0,
          "exclusiveMinimum": -1.5707963267948966,
          "exclusiveMaximum": 1.5707963267948966,
          "units": "rad",
          "type": "number"
        },
        "reference_plane": {
          "title": "Reference plane for cross section",
          "description": "The position of the plane where the supplied cross section are defined. The plane is perpendicular to the ``axis``. The plane is located at the ``bottom``, ``middle``, or ``top`` of the geometry with respect to the axis. E.g. if ``axis=1``, ``bottom`` refers to the negative side of the y-axis, and ``top`` refers to the positive side of the y-axis.",
          "default": "middle",
          "enum": [
            "bottom",
            "middle",
            "top"
          ],
          "type": "string"
        },
        "slab_bounds": {
          "title": "Slab Bounds",
          "description": "Minimum and maximum positions of the slab along axis dimension.",
          "units": "um",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "dilation": {
          "title": "Dilation",
          "description": "Dilation of the supplied polygon by shifting each edge along its normal outwards direction by a distance; a negative value corresponds to erosion.",
          "default": 0.0,
          "units": "um",
          "type": "number"
        },
        "vertices": {
          "title": "Vertices",
          "description": "List of (d1, d2) defining the 2 dimensional positions of the polygon face vertices at the ``reference_plane``. The index of dimension should be in the ascending order: e.g. if the slab normal axis is ``axis=y``, the coordinate of the vertices will be in (x, z)",
          "units": "um",
          "type": "ArrayLike"
        }
      },
      "required": [
        "slab_bounds",
        "vertices"
      ],
      "additionalProperties": false
    },
    "TriangleMeshDataset": {
      "title": "TriangleMeshDataset",
      "description": "Dataset for storing triangular surface data.\n\nParameters\n----------\nsurface_mesh : TriangleMeshDataArray\n    Dataset containing the surface triangles and corresponding face indices for a surface mesh.",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "TriangleMeshDataset",
          "enum": [
            "TriangleMeshDataset"
          ],
          "type": "string"
        },
        "surface_mesh": {
          "title": "DataArray",
          "description": "Dataset containing the surface triangles and corresponding face indices for a surface mesh.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        }
      },
      "required": [
        "surface_mesh"
      ],
      "additionalProperties": false
    },
    "TriangleMesh": {
      "title": "TriangleMesh",
      "description": "Custom surface geometry given by a triangle mesh, as in the STL file format.\n\nParameters\n----------\nmesh_dataset : Optional[TriangleMeshDataset]\n    Surface mesh data.\n\nExample\n-------\n>>> vertices = np.array([[0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1]])\n>>> faces = np.array([[1, 2, 3], [0, 3, 2], [0, 1, 3], [0, 2, 1]])\n>>> stl_geom = TriangleMesh.from_vertices_faces(vertices, faces)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "TriangleMesh",
          "enum": [
            "TriangleMesh"
          ],
          "type": "string"
        },
        "mesh_dataset": {
          "title": "Surface mesh data",
          "description": "Surface mesh data.",
          "allOf": [
            {
              "$ref": "#/definitions/TriangleMeshDataset"
            }
          ]
        }
      },
      "required": [
        "mesh_dataset"
      ],
      "additionalProperties": false
    },
    "GeometryGroup": {
      "title": "GeometryGroup",
      "description": "A collection of Geometry objects that can be called as a single geometry object.\n\nParameters\n----------\ngeometries : ForwardRef('Tuple[annotate_type(GeometryType), ...]')\n    Tuple of geometries in a single grouping. Can provide significant performance enhancement in ``Structure`` when all geometries are assigned the same medium.",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "GeometryGroup",
          "enum": [
            "GeometryGroup"
          ],
          "type": "string"
        },
        "geometries": {
          "title": "Geometries",
          "description": "Tuple of geometries in a single grouping. Can provide significant performance enhancement in ``Structure`` when all geometries are assigned the same medium.",
          "type": "array",
          "items": {
            "discriminator": {
              "propertyName": "type",
              "mapping": {
                "Box": "#/definitions/Box",
                "Transformed": "#/definitions/Transformed",
                "ClipOperation": "#/definitions/ClipOperation",
                "GeometryGroup": "#/definitions/GeometryGroup",
                "Sphere": "#/definitions/Sphere",
                "Cylinder": "#/definitions/Cylinder",
                "PolySlab": "#/definitions/PolySlab",
                "ComplexPolySlabBase": "#/definitions/ComplexPolySlabBase",
                "TriangleMesh": "#/definitions/TriangleMesh"
              }
            },
            "oneOf": [
              {
                "$ref": "#/definitions/Box"
              },
              {
                "$ref": "#/definitions/Transformed"
              },
              {
                "$ref": "#/definitions/ClipOperation"
              },
              {
                "$ref": "#/definitions/GeometryGroup"
              },
              {
                "$ref": "#/definitions/Sphere"
              },
              {
                "$ref": "#/definitions/Cylinder"
              },
              {
                "$ref": "#/definitions/PolySlab"
              },
              {
                "$ref": "#/definitions/ComplexPolySlabBase"
              },
              {
                "$ref": "#/definitions/TriangleMesh"
              }
            ]
          }
        }
      },
      "required": [
        "geometries"
      ],
      "additionalProperties": false
    },
    "ClipOperation": {
      "title": "ClipOperation",
      "description": "Class representing the result of a set operation between geometries.\n\nParameters\n----------\noperation : Literal['union', 'intersection', 'difference', 'symmetric_difference']\n    Operation to be performed between geometries.\ngeometry_a : ForwardRef('annotate_type(GeometryType)')\n    First operand for the set operation. It can be any geometry type, including :class:`GeometryGroup`.\ngeometry_b : ForwardRef('annotate_type(GeometryType)')\n    Second operand for the set operation. It can also be any geometry type.",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "ClipOperation",
          "enum": [
            "ClipOperation"
          ],
          "type": "string"
        },
        "operation": {
          "title": "Operation Type",
          "description": "Operation to be performed between geometries.",
          "enum": [
            "union",
            "intersection",
            "difference",
            "symmetric_difference"
          ],
          "type": "string"
        },
        "geometry_a": {
          "title": "Geometry A",
          "description": "First operand for the set operation. It can be any geometry type, including :class:`GeometryGroup`.",
          "anyOf": [
            {
              "$ref": "#/definitions/Box"
            },
            {
              "$ref": "#/definitions/Transformed"
            },
            {
              "$ref": "#/definitions/ClipOperation"
            },
            {
              "$ref": "#/definitions/GeometryGroup"
            },
            {
              "$ref": "#/definitions/Sphere"
            },
            {
              "$ref": "#/definitions/Cylinder"
            },
            {
              "$ref": "#/definitions/PolySlab"
            },
            {
              "$ref": "#/definitions/ComplexPolySlabBase"
            },
            {
              "$ref": "#/definitions/TriangleMesh"
            }
          ]
        },
        "geometry_b": {
          "title": "Geometry B",
          "description": "Second operand for the set operation. It can also be any geometry type.",
          "anyOf": [
            {
              "$ref": "#/definitions/Box"
            },
            {
              "$ref": "#/definitions/Transformed"
            },
            {
              "$ref": "#/definitions/ClipOperation"
            },
            {
              "$ref": "#/definitions/GeometryGroup"
            },
            {
              "$ref": "#/definitions/Sphere"
            },
            {
              "$ref": "#/definitions/Cylinder"
            },
            {
              "$ref": "#/definitions/PolySlab"
            },
            {
              "$ref": "#/definitions/ComplexPolySlabBase"
            },
            {
              "$ref": "#/definitions/TriangleMesh"
            }
          ]
        }
      },
      "required": [
        "operation",
        "geometry_a",
        "geometry_b"
      ],
      "additionalProperties": false
    },
    "Transformed": {
      "title": "Transformed",
      "description": "Class representing a transformed geometry.\n\nParameters\n----------\ngeometry : ForwardRef('annotate_type(GeometryType)')\n    Base geometry to be transformed.\ntransform : ArrayLike[dtype=float, ndim=2, shape=(4, 4)] = [[1.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0]]\n    Transform matrix applied to the base geometry.",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "Transformed",
          "enum": [
            "Transformed"
          ],
          "type": "string"
        },
        "geometry": {
          "title": "Geometry",
          "description": "Base geometry to be transformed.",
          "anyOf": [
            {
              "$ref": "#/definitions/Box"
            },
            {
              "$ref": "#/definitions/Transformed"
            },
            {
              "$ref": "#/definitions/ClipOperation"
            },
            {
              "$ref": "#/definitions/GeometryGroup"
            },
            {
              "$ref": "#/definitions/Sphere"
            },
            {
              "$ref": "#/definitions/Cylinder"
            },
            {
              "$ref": "#/definitions/PolySlab"
            },
            {
              "$ref": "#/definitions/ComplexPolySlabBase"
            },
            {
              "$ref": "#/definitions/TriangleMesh"
            }
          ]
        },
        "transform": {
          "title": "Transform",
          "description": "Transform matrix applied to the base geometry.",
          "default": [
            [
              1.0,
              0.0,
              0.0,
              0.0
            ],
            [
              0.0,
              1.0,
              0.0,
              0.0
            ],
            [
              0.0,
              0.0,
              1.0,
              0.0
            ],
            [
              0.0,
              0.0,
              0.0,
              1.0
            ]
          ],
          "type": "ArrayLike"
        }
      },
      "required": [
        "geometry"
      ],
      "additionalProperties": false
    },
    "Medium2D": {
      "title": "Medium2D",
      "description": "2D diagonally anisotropic medium.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\nss : Union[Medium, PoleResidue, Sellmeier, Lorentz, Debye, Drude, PECMedium]\n    Medium describing the ss-component of the diagonal permittivity tensor. The ss-component refers to the in-plane dimension of the medium that is the first component in order of 'x', 'y', 'z'. If the 2D material is normal to the y-axis, for example, then this determines the xx-component of the corresponding 3D medium.\ntt : Union[Medium, PoleResidue, Sellmeier, Lorentz, Debye, Drude, PECMedium]\n    Medium describing the tt-component of the diagonal permittivity tensor. The tt-component refers to the in-plane dimension of the medium that is the second component in order of 'x', 'y', 'z'. If the 2D material is normal to the y-axis, for example, then this determines the zz-component of the corresponding 3D medium.\n\nNotes\n-----\n\n    Only diagonal anisotropy is currently supported.\n\nExample\n-------\n>>> drude_medium = Drude(eps_inf=2.0, coeffs=[(1,2), (3,4)])\n>>> medium2d = Medium2D(ss=drude_medium, tt=drude_medium)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Medium2D",
          "enum": [
            "Medium2D"
          ],
          "type": "string"
        },
        "ss": {
          "title": "SS Component",
          "description": "Medium describing the ss-component of the diagonal permittivity tensor. The ss-component refers to the in-plane dimension of the medium that is the first component in order of 'x', 'y', 'z'. If the 2D material is normal to the y-axis, for example, then this determines the xx-component of the corresponding 3D medium.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "Medium": "#/definitions/Medium",
              "PoleResidue": "#/definitions/PoleResidue",
              "Sellmeier": "#/definitions/Sellmeier",
              "Lorentz": "#/definitions/Lorentz",
              "Debye": "#/definitions/Debye",
              "Drude": "#/definitions/Drude",
              "PECMedium": "#/definitions/PECMedium"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/Medium"
            },
            {
              "$ref": "#/definitions/PoleResidue"
            },
            {
              "$ref": "#/definitions/Sellmeier"
            },
            {
              "$ref": "#/definitions/Lorentz"
            },
            {
              "$ref": "#/definitions/Debye"
            },
            {
              "$ref": "#/definitions/Drude"
            },
            {
              "$ref": "#/definitions/PECMedium"
            }
          ]
        },
        "tt": {
          "title": "TT Component",
          "description": "Medium describing the tt-component of the diagonal permittivity tensor. The tt-component refers to the in-plane dimension of the medium that is the second component in order of 'x', 'y', 'z'. If the 2D material is normal to the y-axis, for example, then this determines the zz-component of the corresponding 3D medium.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "Medium": "#/definitions/Medium",
              "PoleResidue": "#/definitions/PoleResidue",
              "Sellmeier": "#/definitions/Sellmeier",
              "Lorentz": "#/definitions/Lorentz",
              "Debye": "#/definitions/Debye",
              "Drude": "#/definitions/Drude",
              "PECMedium": "#/definitions/PECMedium"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/Medium"
            },
            {
              "$ref": "#/definitions/PoleResidue"
            },
            {
              "$ref": "#/definitions/Sellmeier"
            },
            {
              "$ref": "#/definitions/Lorentz"
            },
            {
              "$ref": "#/definitions/Debye"
            },
            {
              "$ref": "#/definitions/Drude"
            },
            {
              "$ref": "#/definitions/PECMedium"
            }
          ]
        }
      },
      "required": [
        "ss",
        "tt"
      ],
      "additionalProperties": false
    },
    "Structure": {
      "title": "Structure",
      "description": "Defines a physical object that interacts with the electromagnetic fields.\nA :class:`Structure` is a combination of a material property (:class:`AbstractMedium`)\nand a :class:`Geometry`.\n\nParameters\n----------\ngeometry : Union[Box, Transformed, ClipOperation, GeometryGroup, Sphere, Cylinder, PolySlab, ComplexPolySlabBase, TriangleMesh]\n    Defines geometric properties of the structure.\nname : Optional[str] = None\n    Optional name for the structure.\nmedium : Union[Medium, AnisotropicMedium, PECMedium, PoleResidue, Sellmeier, Lorentz, Debye, Drude, FullyAnisotropicMedium, CustomMedium, CustomPoleResidue, CustomSellmeier, CustomLorentz, CustomDebye, CustomDrude, CustomAnisotropicMedium, PerturbationMedium, PerturbationPoleResidue, Medium2D]\n    Defines the electromagnetic properties of the structure's medium.\n\nNotes\n------\n\n    Structures can indeed be larger than the simulation domain in ``tidy3d``. In such cases, ``tidy3d`` will\n    automatically truncate the geometry that goes beyond the domain boundaries. For best results, structures that\n    intersect with absorbing boundaries or simulation edges should extend all the way through. In many such\n    cases, an \u201cinfinite\u201d size :class:`td.inf` can be used to define the size along that dimension.\n\nExample\n-------\n>>> from tidy3d import Box, Medium\n>>> box = Box(center=(0,0,1), size=(2, 2, 2))\n>>> glass = Medium(permittivity=3.9)\n>>> struct = Structure(geometry=box, medium=glass, name='glass_box')\n\nSee Also\n--------\n\n**Notebooks:**\n\n* `Quickstart <../../notebooks/StartHere.html>`_: Usage in a basic simulation flow.\n* `First walkthrough <../../notebooks/Simulation.html>`_: Usage in a basic simulation flow.\n* `Visualizing geometries in Tidy3D <../../notebooks/VizSimulation.html>`_\n\n**Lectures:**\n\n* `Using FDTD to Compute a Transmission Spectrum <https://www.flexcompute.com/fdtd101/Lecture-2-Using-FDTD-to-Compute-a-Transmission-Spectrum/>`_\n\n**GUI:**\n\n* `Structures <https://www.flexcompute.com/tidy3d/learning-center/tidy3d-gui/Lecture-3-Structures/#presentation-slides>`_",
      "type": "object",
      "properties": {
        "geometry": {
          "title": "Geometry",
          "description": "Defines geometric properties of the structure.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "Box": "#/definitions/Box",
              "Transformed": "#/definitions/Transformed",
              "ClipOperation": "#/definitions/ClipOperation",
              "GeometryGroup": "#/definitions/GeometryGroup",
              "Sphere": "#/definitions/Sphere",
              "Cylinder": "#/definitions/Cylinder",
              "PolySlab": "#/definitions/PolySlab",
              "ComplexPolySlabBase": "#/definitions/ComplexPolySlabBase",
              "TriangleMesh": "#/definitions/TriangleMesh"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/Box"
            },
            {
              "$ref": "#/definitions/Transformed"
            },
            {
              "$ref": "#/definitions/ClipOperation"
            },
            {
              "$ref": "#/definitions/GeometryGroup"
            },
            {
              "$ref": "#/definitions/Sphere"
            },
            {
              "$ref": "#/definitions/Cylinder"
            },
            {
              "$ref": "#/definitions/PolySlab"
            },
            {
              "$ref": "#/definitions/ComplexPolySlabBase"
            },
            {
              "$ref": "#/definitions/TriangleMesh"
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Optional name for the structure.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "Structure",
          "enum": [
            "Structure"
          ],
          "type": "string"
        },
        "medium": {
          "title": "Medium",
          "description": "Defines the electromagnetic properties of the structure's medium.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "Medium": "#/definitions/Medium",
              "AnisotropicMedium": "#/definitions/AnisotropicMedium",
              "PECMedium": "#/definitions/PECMedium",
              "PoleResidue": "#/definitions/PoleResidue",
              "Sellmeier": "#/definitions/Sellmeier",
              "Lorentz": "#/definitions/Lorentz",
              "Debye": "#/definitions/Debye",
              "Drude": "#/definitions/Drude",
              "FullyAnisotropicMedium": "#/definitions/FullyAnisotropicMedium",
              "CustomMedium": "#/definitions/CustomMedium",
              "CustomPoleResidue": "#/definitions/CustomPoleResidue",
              "CustomSellmeier": "#/definitions/CustomSellmeier",
              "CustomLorentz": "#/definitions/CustomLorentz",
              "CustomDebye": "#/definitions/CustomDebye",
              "CustomDrude": "#/definitions/CustomDrude",
              "CustomAnisotropicMedium": "#/definitions/CustomAnisotropicMedium",
              "PerturbationMedium": "#/definitions/PerturbationMedium",
              "PerturbationPoleResidue": "#/definitions/PerturbationPoleResidue",
              "Medium2D": "#/definitions/Medium2D"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/Medium"
            },
            {
              "$ref": "#/definitions/AnisotropicMedium"
            },
            {
              "$ref": "#/definitions/PECMedium"
            },
            {
              "$ref": "#/definitions/PoleResidue"
            },
            {
              "$ref": "#/definitions/Sellmeier"
            },
            {
              "$ref": "#/definitions/Lorentz"
            },
            {
              "$ref": "#/definitions/Debye"
            },
            {
              "$ref": "#/definitions/Drude"
            },
            {
              "$ref": "#/definitions/FullyAnisotropicMedium"
            },
            {
              "$ref": "#/definitions/CustomMedium"
            },
            {
              "$ref": "#/definitions/CustomPoleResidue"
            },
            {
              "$ref": "#/definitions/CustomSellmeier"
            },
            {
              "$ref": "#/definitions/CustomLorentz"
            },
            {
              "$ref": "#/definitions/CustomDebye"
            },
            {
              "$ref": "#/definitions/CustomDrude"
            },
            {
              "$ref": "#/definitions/CustomAnisotropicMedium"
            },
            {
              "$ref": "#/definitions/PerturbationMedium"
            },
            {
              "$ref": "#/definitions/PerturbationPoleResidue"
            },
            {
              "$ref": "#/definitions/Medium2D"
            }
          ]
        }
      },
      "required": [
        "geometry",
        "medium"
      ],
      "additionalProperties": false
    },
    "GaussianPulse": {
      "title": "GaussianPulse",
      "description": "Source time dependence that describes a Gaussian pulse.\n\nParameters\n----------\namplitude : NonNegativeFloat = 1.0\n    Real-valued maximum amplitude of the time dependence.\nphase : float = 0.0\n    [units = rad].  Phase shift of the time dependence.\nfreq0 : PositiveFloat\n    [units = Hz].  Central frequency of the pulse.\nfwidth : PositiveFloat\n    [units = Hz].  Standard deviation of the frequency content of the pulse.\noffset : ConstrainedFloatValue = 5.0\n    Time delay of the maximum value of the pulse in units of 1 / (``2pi * fwidth``).\nremove_dc_component : bool = True\n    Whether to remove the DC component in the Gaussian pulse spectrum. If ``True``, the Gaussian pulse is modified at low frequencies to zero out the DC component, which is usually desirable so that the fields will decay. However, for broadband simulations, it may be better to have non-vanishing source power near zero frequency. Setting this to ``False`` results in an unmodified Gaussian pulse spectrum which can have a nonzero DC component.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)",
      "type": "object",
      "properties": {
        "amplitude": {
          "title": "Amplitude",
          "description": "Real-valued maximum amplitude of the time dependence.",
          "default": 1.0,
          "minimum": 0,
          "type": "number"
        },
        "phase": {
          "title": "Phase",
          "description": "Phase shift of the time dependence.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "type": {
          "title": "Type",
          "default": "GaussianPulse",
          "enum": [
            "GaussianPulse"
          ],
          "type": "string"
        },
        "freq0": {
          "title": "Central Frequency",
          "description": "Central frequency of the pulse.",
          "units": "Hz",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "fwidth": {
          "title": "Fwidth",
          "description": "Standard deviation of the frequency content of the pulse.",
          "units": "Hz",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "offset": {
          "title": "Offset",
          "description": "Time delay of the maximum value of the pulse in units of 1 / (``2pi * fwidth``).",
          "default": 5.0,
          "minimum": 2.5,
          "type": "number"
        },
        "remove_dc_component": {
          "title": "Remove DC Component",
          "description": "Whether to remove the DC component in the Gaussian pulse spectrum. If ``True``, the Gaussian pulse is modified at low frequencies to zero out the DC component, which is usually desirable so that the fields will decay. However, for broadband simulations, it may be better to have non-vanishing source power near zero frequency. Setting this to ``False`` results in an unmodified Gaussian pulse spectrum which can have a nonzero DC component.",
          "default": true,
          "type": "boolean"
        }
      },
      "required": [
        "freq0",
        "fwidth"
      ],
      "additionalProperties": false
    },
    "ContinuousWave": {
      "title": "ContinuousWave",
      "description": "Source time dependence that ramps up to continuous oscillation\nand holds until end of simulation.\n\nParameters\n----------\namplitude : NonNegativeFloat = 1.0\n    Real-valued maximum amplitude of the time dependence.\nphase : float = 0.0\n    [units = rad].  Phase shift of the time dependence.\nfreq0 : PositiveFloat\n    [units = Hz].  Central frequency of the pulse.\nfwidth : PositiveFloat\n    [units = Hz].  Standard deviation of the frequency content of the pulse.\noffset : ConstrainedFloatValue = 5.0\n    Time delay of the maximum value of the pulse in units of 1 / (``2pi * fwidth``).\n\nNote\n----\nField decay will not occur, so the simulation will run for the full ``run_time``.\nAlso, source normalization of frequency-domain monitors is not meaningful.\n\nExample\n-------\n>>> cw = ContinuousWave(freq0=200e12, fwidth=20e12)",
      "type": "object",
      "properties": {
        "amplitude": {
          "title": "Amplitude",
          "description": "Real-valued maximum amplitude of the time dependence.",
          "default": 1.0,
          "minimum": 0,
          "type": "number"
        },
        "phase": {
          "title": "Phase",
          "description": "Phase shift of the time dependence.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "type": {
          "title": "Type",
          "default": "ContinuousWave",
          "enum": [
            "ContinuousWave"
          ],
          "type": "string"
        },
        "freq0": {
          "title": "Central Frequency",
          "description": "Central frequency of the pulse.",
          "units": "Hz",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "fwidth": {
          "title": "Fwidth",
          "description": "Standard deviation of the frequency content of the pulse.",
          "units": "Hz",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "offset": {
          "title": "Offset",
          "description": "Time delay of the maximum value of the pulse in units of 1 / (``2pi * fwidth``).",
          "default": 5.0,
          "minimum": 2.5,
          "type": "number"
        }
      },
      "required": [
        "freq0",
        "fwidth"
      ],
      "additionalProperties": false
    },
    "TimeDataset": {
      "title": "TimeDataset",
      "description": "Dataset for storing a function of time.\n\nParameters\n----------\nvalues : TimeDataArray\n    Values as a function of time.",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "TimeDataset",
          "enum": [
            "TimeDataset"
          ],
          "type": "string"
        },
        "values": {
          "title": "DataArray",
          "description": "Values as a function of time.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        }
      },
      "required": [
        "values"
      ],
      "additionalProperties": false
    },
    "CustomSourceTime": {
      "title": "CustomSourceTime",
      "description": "Custom source time dependence consisting of a real or complex envelope\nmodulated at a central frequency, as shown below.\n\nParameters\n----------\namplitude : NonNegativeFloat = 1.0\n    Real-valued maximum amplitude of the time dependence.\nphase : float = 0.0\n    [units = rad].  Phase shift of the time dependence.\nfreq0 : PositiveFloat\n    [units = Hz].  Central frequency of the pulse.\nfwidth : PositiveFloat\n    [units = Hz].  Standard deviation of the frequency content of the pulse.\noffset : float = 0.0\n    Time delay of the envelope in units of 1 / (``2pi * fwidth``).\nsource_time_dataset : Optional[TimeDataset]\n    Dataset for storing the envelope of the custom source time. This envelope will be modulated by a complex exponential at frequency ``freq0``.\n\nNote\n----\n.. math::\n\n    amp\\_time(t) = amplitude \\cdot \\\n            e^{i \\cdot phase - 2 \\pi i \\cdot freq0 \\cdot t} \\cdot \\\n            envelope(t - offset / (2 \\pi \\cdot fwidth))\n\nNote\n----\nDepending on the envelope, field decay may not occur.\nIf field decay does not occur, then the simulation will run for the full ``run_time``.\nAlso, if field decay does not occur, then source normalization of frequency-domain\nmonitors is not meaningful.\n\nNote\n----\nThe source time dependence is linearly interpolated to the simulation time steps.\nThe sampling rate should be sufficiently fast that this interpolation does not\nintroduce artifacts. The source time dependence should also start at zero and ramp up smoothly.\nThe first and last values of the envelope will be used for times that are out of range\nof the provided data.\n\nExample\n-------\n>>> cst = CustomSourceTime.from_values(freq0=1, fwidth=0.1,\n...     values=np.linspace(0, 9, 10), dt=0.1)",
      "type": "object",
      "properties": {
        "amplitude": {
          "title": "Amplitude",
          "description": "Real-valued maximum amplitude of the time dependence.",
          "default": 1.0,
          "minimum": 0,
          "type": "number"
        },
        "phase": {
          "title": "Phase",
          "description": "Phase shift of the time dependence.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "type": {
          "title": "Type",
          "default": "CustomSourceTime",
          "enum": [
            "CustomSourceTime"
          ],
          "type": "string"
        },
        "freq0": {
          "title": "Central Frequency",
          "description": "Central frequency of the pulse.",
          "units": "Hz",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "fwidth": {
          "title": "Fwidth",
          "description": "Standard deviation of the frequency content of the pulse.",
          "units": "Hz",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "offset": {
          "title": "Offset",
          "description": "Time delay of the envelope in units of 1 / (``2pi * fwidth``).",
          "default": 0.0,
          "type": "number"
        },
        "source_time_dataset": {
          "title": "Source time dataset",
          "description": "Dataset for storing the envelope of the custom source time. This envelope will be modulated by a complex exponential at frequency ``freq0``.",
          "allOf": [
            {
              "$ref": "#/definitions/TimeDataset"
            }
          ]
        }
      },
      "required": [
        "freq0",
        "fwidth",
        "source_time_dataset"
      ],
      "additionalProperties": false
    },
    "UniformCurrentSource": {
      "title": "UniformCurrentSource",
      "description": "Source in a rectangular volume with uniform time dependence.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional name for the source.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave, CustomSourceTime]\n    Specification of the source time-dependence.\ninterpolate : bool = True\n    Handles reverse-interpolation of zero-size dimensions of the source. If ``False``, the source data is snapped to the nearest Yee grid point. If ``True``, equivalent source data is applied on the surrounding Yee grid points to emulate placement at the specified location using linear interpolation.\npolarization : Literal['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']\n    Specifies the direction and type of current component.\n\nNotes\n-----\n\n    Inputting the parameter ``size=(0,0,0)`` defines the equivalent of a point source.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> pt_source = UniformCurrentSource(size=(0,0,0), source_time=pulse, polarization='Ex')",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "UniformCurrentSource",
          "enum": [
            "UniformCurrentSource"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "GaussianPulse": "#/definitions/GaussianPulse",
              "ContinuousWave": "#/definitions/ContinuousWave",
              "CustomSourceTime": "#/definitions/CustomSourceTime"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            },
            {
              "$ref": "#/definitions/CustomSourceTime"
            }
          ]
        },
        "interpolate": {
          "title": "Enable Interpolation",
          "description": "Handles reverse-interpolation of zero-size dimensions of the source. If ``False``, the source data is snapped to the nearest Yee grid point. If ``True``, equivalent source data is applied on the surrounding Yee grid points to emulate placement at the specified location using linear interpolation.",
          "default": true,
          "type": "boolean"
        },
        "polarization": {
          "title": "Polarization",
          "description": "Specifies the direction and type of current component.",
          "enum": [
            "Ex",
            "Ey",
            "Ez",
            "Hx",
            "Hy",
            "Hz"
          ],
          "type": "string"
        }
      },
      "required": [
        "size",
        "source_time",
        "polarization"
      ],
      "additionalProperties": false
    },
    "PointDipole": {
      "title": "PointDipole",
      "description": "Uniform current source with a zero size.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional name for the source.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[Literal[0], Literal[0], Literal[0]] = (0, 0, 0)\n    [units = um].  Size in x, y, and z directions, constrained to ``(0, 0, 0)``.\nsource_time : Union[GaussianPulse, ContinuousWave, CustomSourceTime]\n    Specification of the source time-dependence.\ninterpolate : bool = True\n    Handles reverse-interpolation of zero-size dimensions of the source. If ``False``, the source data is snapped to the nearest Yee grid point. If ``True``, equivalent source data is applied on the surrounding Yee grid points to emulate placement at the specified location using linear interpolation.\npolarization : Literal['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']\n    Specifies the direction and type of current component.\n\n.. TODO add image of how it looks like based on sim 1.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> pt_dipole = PointDipole(center=(1,2,3), source_time=pulse, polarization='Ex')\n\nSee Also\n--------\n\n**Lectures:**\n    * `Prelude to Integrated Photonics Simulation: Mode Injection <https://www.flexcompute.com/fdtd101/Lecture-4-Prelude-to-Integrated-Photonics-Simulation-Mode-Injection/>`_",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "PointDipole",
          "enum": [
            "PointDipole"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions, constrained to ``(0, 0, 0)``.",
          "default": [
            0,
            0,
            0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "enum": [
                0
              ],
              "type": "integer"
            },
            {
              "enum": [
                0
              ],
              "type": "integer"
            },
            {
              "enum": [
                0
              ],
              "type": "integer"
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "GaussianPulse": "#/definitions/GaussianPulse",
              "ContinuousWave": "#/definitions/ContinuousWave",
              "CustomSourceTime": "#/definitions/CustomSourceTime"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            },
            {
              "$ref": "#/definitions/CustomSourceTime"
            }
          ]
        },
        "interpolate": {
          "title": "Enable Interpolation",
          "description": "Handles reverse-interpolation of zero-size dimensions of the source. If ``False``, the source data is snapped to the nearest Yee grid point. If ``True``, equivalent source data is applied on the surrounding Yee grid points to emulate placement at the specified location using linear interpolation.",
          "default": true,
          "type": "boolean"
        },
        "polarization": {
          "title": "Polarization",
          "description": "Specifies the direction and type of current component.",
          "enum": [
            "Ex",
            "Ey",
            "Ez",
            "Hx",
            "Hy",
            "Hz"
          ],
          "type": "string"
        }
      },
      "required": [
        "source_time",
        "polarization"
      ],
      "additionalProperties": false
    },
    "GaussianBeam": {
      "title": "GaussianBeam",
      "description": "Gaussian distribution on finite extent plane.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional name for the source.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave, CustomSourceTime]\n    Specification of the source time-dependence.\nnum_freqs : ConstrainedIntValue = 1\n    Number of points used to approximate the frequency dependence of injected field. A Chebyshev interpolation is used, thus, only a small number of points, i.e., less than 20, is typically sufficient to obtain converged results.\ndirection : Literal['+', '-']\n    Specifies propagation in the positive or negative direction of the injection axis.\nangle_theta : float = 0.0\n    [units = rad].  Polar angle of the propagation axis from the injection axis.\nangle_phi : float = 0.0\n    [units = rad].  Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.\npol_angle : float = 0\n    [units = rad].  Specifies the angle between the electric field polarization of the source and the plane defined by the injection axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.\nwaist_radius : PositiveFloat = 1.0\n    [units = um].  Radius of the beam at the waist.\nwaist_distance : float = 0.0\n    [units = um].  Distance from the beam waist along the propagation direction. When ``direction`` is ``+`` and ``waist_distance`` is positive, the waist is on the ``-`` side (behind) the source plane. When ``direction`` is ``+`` and  ``waist_distance``is negative, the waist is on the ``+`` side (in front) of the source plane.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> gauss = GaussianBeam(\n...     size=(0,3,3),\n...     source_time=pulse,\n...     pol_angle=np.pi / 2,\n...     direction='+',\n...     waist_radius=1.0)\n\nSee Also\n--------\n\n**Notebooks**:\n    * `Inverse taper edge coupler <../../notebooks/EdgeCoupler.html>`_",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "GaussianBeam",
          "enum": [
            "GaussianBeam"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "GaussianPulse": "#/definitions/GaussianPulse",
              "ContinuousWave": "#/definitions/ContinuousWave",
              "CustomSourceTime": "#/definitions/CustomSourceTime"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            },
            {
              "$ref": "#/definitions/CustomSourceTime"
            }
          ]
        },
        "num_freqs": {
          "title": "Number of Frequency Points",
          "description": "Number of points used to approximate the frequency dependence of injected field. A Chebyshev interpolation is used, thus, only a small number of points, i.e., less than 20, is typically sufficient to obtain converged results.",
          "default": 1,
          "minimum": 1,
          "maximum": 99,
          "type": "integer"
        },
        "direction": {
          "title": "Direction",
          "description": "Specifies propagation in the positive or negative direction of the injection axis.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "angle_theta": {
          "title": "Polar Angle",
          "description": "Polar angle of the propagation axis from the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "angle_phi": {
          "title": "Azimuth Angle",
          "description": "Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "pol_angle": {
          "title": "Polarization Angle",
          "description": "Specifies the angle between the electric field polarization of the source and the plane defined by the injection axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.",
          "default": 0,
          "units": "rad",
          "type": "number"
        },
        "waist_radius": {
          "title": "Waist Radius",
          "description": "Radius of the beam at the waist.",
          "default": 1.0,
          "units": "um",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "waist_distance": {
          "title": "Waist Distance",
          "description": "Distance from the beam waist along the propagation direction. When ``direction`` is ``+`` and ``waist_distance`` is positive, the waist is on the ``-`` side (behind) the source plane. When ``direction`` is ``+`` and  ``waist_distance``is negative, the waist is on the ``+`` side (in front) of the source plane.",
          "default": 0.0,
          "units": "um",
          "type": "number"
        }
      },
      "required": [
        "size",
        "source_time",
        "direction"
      ],
      "additionalProperties": false
    },
    "AstigmaticGaussianBeam": {
      "title": "AstigmaticGaussianBeam",
      "description": "The simple astigmatic Gaussian distribution allows\nboth an elliptical intensity profile and different waist locations for the two principal axes\nof the ellipse. When equal waist sizes and equal waist distances are specified in the two\ndirections, this source becomes equivalent to :class:`GaussianBeam`.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional name for the source.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave, CustomSourceTime]\n    Specification of the source time-dependence.\nnum_freqs : ConstrainedIntValue = 1\n    Number of points used to approximate the frequency dependence of injected field. A Chebyshev interpolation is used, thus, only a small number of points, i.e., less than 20, is typically sufficient to obtain converged results.\ndirection : Literal['+', '-']\n    Specifies propagation in the positive or negative direction of the injection axis.\nangle_theta : float = 0.0\n    [units = rad].  Polar angle of the propagation axis from the injection axis.\nangle_phi : float = 0.0\n    [units = rad].  Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.\npol_angle : float = 0\n    [units = rad].  Specifies the angle between the electric field polarization of the source and the plane defined by the injection axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.\nwaist_sizes : Tuple[PositiveFloat, PositiveFloat] = (1.0, 1.0)\n    [units = um].  Size of the beam at the waist in the local x and y directions.\nwaist_distances : Tuple[float, float] = (0.0, 0.0)\n    [units = um].  Distance to the beam waist along the propagation direction for the waist sizes in the local x and y directions. When ``direction`` is ``+`` and ``waist_distances`` are positive, the waist is on the ``-`` side (behind) the source plane. When ``direction`` is ``+`` and ``waist_distances`` are negative, the waist is on the ``+`` side (in front) of the source plane.\n\nNotes\n-----\n\n    This class implements the simple astigmatic Gaussian beam described in _`[1]`.\n\n    **References**:\n\n    .. [1] Kochkina et al., Applied Optics, vol. 52, issue 24, 2013.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> gauss = AstigmaticGaussianBeam(\n...     size=(0,3,3),\n...     source_time=pulse,\n...     pol_angle=np.pi / 2,\n...     direction='+',\n...     waist_sizes=(1.0, 2.0),\n...     waist_distances = (3.0, 4.0))",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "AstigmaticGaussianBeam",
          "enum": [
            "AstigmaticGaussianBeam"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "GaussianPulse": "#/definitions/GaussianPulse",
              "ContinuousWave": "#/definitions/ContinuousWave",
              "CustomSourceTime": "#/definitions/CustomSourceTime"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            },
            {
              "$ref": "#/definitions/CustomSourceTime"
            }
          ]
        },
        "num_freqs": {
          "title": "Number of Frequency Points",
          "description": "Number of points used to approximate the frequency dependence of injected field. A Chebyshev interpolation is used, thus, only a small number of points, i.e., less than 20, is typically sufficient to obtain converged results.",
          "default": 1,
          "minimum": 1,
          "maximum": 99,
          "type": "integer"
        },
        "direction": {
          "title": "Direction",
          "description": "Specifies propagation in the positive or negative direction of the injection axis.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "angle_theta": {
          "title": "Polar Angle",
          "description": "Polar angle of the propagation axis from the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "angle_phi": {
          "title": "Azimuth Angle",
          "description": "Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "pol_angle": {
          "title": "Polarization Angle",
          "description": "Specifies the angle between the electric field polarization of the source and the plane defined by the injection axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.",
          "default": 0,
          "units": "rad",
          "type": "number"
        },
        "waist_sizes": {
          "title": "Waist sizes",
          "description": "Size of the beam at the waist in the local x and y directions.",
          "default": [
            1.0,
            1.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number",
              "exclusiveMinimum": 0
            },
            {
              "type": "number",
              "exclusiveMinimum": 0
            }
          ]
        },
        "waist_distances": {
          "title": "Waist distances",
          "description": "Distance to the beam waist along the propagation direction for the waist sizes in the local x and y directions. When ``direction`` is ``+`` and ``waist_distances`` are positive, the waist is on the ``-`` side (behind) the source plane. When ``direction`` is ``+`` and ``waist_distances`` are negative, the waist is on the ``+`` side (in front) of the source plane.",
          "default": [
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        }
      },
      "required": [
        "size",
        "source_time",
        "direction"
      ],
      "additionalProperties": false
    },
    "ModeSpec": {
      "title": "ModeSpec",
      "description": "Stores specifications for the mode solver to find an electromagntic mode.\n\nParameters\n----------\nnum_modes : PositiveInt = 1\n    Number of modes returned by mode solver.\ntarget_neff : Optional[PositiveFloat] = None\n    Guess for effective index of the mode.\nnum_pml : Tuple[NonNegativeInt, NonNegativeInt] = (0, 0)\n    Number of standard pml layers to add in the two tangential axes.\nfilter_pol : Optional[Literal['te', 'tm']] = None\n    The solver always computes the ``num_modes`` modes closest to the given ``target_neff``. If ``filter_pol==None``, they are simply sorted in order of decreasing effective index. If a polarization filter is selected, the modes are rearranged such that the first ``n_pol`` modes in the list are the ones with the selected polarization fraction larger than or equal to 0.5, while the next ``num_modes - n_pol`` modes are the ones where it is smaller than 0.5 (i.e. the opposite polarization fraction is larger than 0.5). Within each polarization subset, the modes are still ordered by decreasing effective index. ``te``-fraction is defined as the integrated intensity of the E-field component parallel to the first plane axis, normalized to the total in-plane E-field intensity. Conversely, ``tm``-fraction uses the E field component parallel to the second plane axis.\nangle_theta : float = 0.0\n    [units = rad].  Polar angle of the propagation axis from the injection axis.\nangle_phi : float = 0.0\n    [units = rad].  Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.\nprecision : Literal['single', 'double'] = single\n    The solver will be faster and using less memory under single precision, but more accurate under double precision.\nbend_radius : Optional[float] = None\n    [units = um].  A curvature radius for simulation of waveguide bends. Can be negative, in which case the mode plane center has a smaller value than the curvature center along the tangential axis perpendicular to the bend axis.\nbend_axis : Optional[Literal[0, 1]] = None\n    Index into the two tangential axes defining the normal to the plane in which the bend lies. This must be provided if ``bend_radius`` is not ``None``. For example, for a ring in the global xy-plane, and a mode plane in either the xz or the yz plane, the ``bend_axis`` is always 1 (the global z axis).\ntrack_freq : Optional[Literal['central', 'lowest', 'highest']] = central\n    Parameter that turns on/off mode tracking based on their similarity. Can take values ``'lowest'``, ``'central'``, or ``'highest'``, which correspond to mode tracking based on the lowest, central, or highest frequency. If ``None`` no mode tracking is performed.\ngroup_index_step : Union[PositiveFloat, bool] = False\n    Control the computation of the group index alongside the effective index. If set to a positive value, it sets the fractional frequency step used in the numerical differentiation of the effective index to compute the group index. If set to `True`, the default of 0.005 is used.\n\nNotes\n-----\n\n    The :attr:`angle_theta` and :attr:`angle_phi` parameters define the injection axis as illustrated in the figure\n    below, with respect to the axis normal to the mode plane (``x`` in the figure). Note that :attr:`angle_theta`\n    must be smaller than :math:`\\frac{pi}{2}`. To inject in the backward direction, we can still use the\n    ``direction`` parameter as also shown in the figure. Similarly, the mode amplitudes computed in mode monitors\n    are defined w.r.t. the ``forward`` and ``backward`` directions as illustrated. Note, the planar axes are\n    found by popping the injection axis from ``{x,y,z}``. For example, if injection axis is ``y``, the planar\n    axes are ordered ``{x,z}``.\n\n    .. image:: ../../notebooks/img/ring_modes.png\n\n    The :attr:`bend_axis` is the axis normal to the plane in which the bend lies, (``z`` in the diagram below). In\n    the mode specification, it is defined locally for the mode plane as one of the two axes tangential to the\n    plane. In the case of bends that lie in the ``xy``-plane, the mode plane would be either in ``xz`` or in\n    ``yz``, so in both cases the correct setting is ``bend_axis=1``, selecting the global ``z``. The\n    ``bend_radius`` is counted from the center of the mode plane to the center of the curvature,\n    along the tangential axis perpendicular to the bend axis. This radius can also be negative, if the center of\n    the mode plane is smaller than the center of the bend.\n\n    .. image:: ../../notebooks/img/mode_angled.png\n\nExample\n-------\n>>> mode_spec = ModeSpec(num_modes=3, target_neff=1.5)\n\nSee Also\n--------\n\n**Notebooks**:\n    * `Introduction on tidy3d working principles <../../notebooks/Primer.html#Modes>`_\n    * `Defining mode sources and monitors <../../notebooks/ModalSourcesMonitors.html>`_\n    * `Injecting modes in bent and angled waveguides <../../notebooks/ModesBentAngled.html>`_\n    * `Waveguide to ring coupling <../../notebooks/WaveguideToRingCoupling.html>`_",
      "type": "object",
      "properties": {
        "num_modes": {
          "title": "Number of modes",
          "description": "Number of modes returned by mode solver.",
          "default": 1,
          "exclusiveMinimum": 0,
          "type": "integer"
        },
        "target_neff": {
          "title": "Target effective index",
          "description": "Guess for effective index of the mode.",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "num_pml": {
          "title": "Number of PML layers",
          "description": "Number of standard pml layers to add in the two tangential axes.",
          "default": [
            0,
            0
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "integer",
              "minimum": 0
            },
            {
              "type": "integer",
              "minimum": 0
            }
          ]
        },
        "filter_pol": {
          "title": "Polarization filtering",
          "description": "The solver always computes the ``num_modes`` modes closest to the given ``target_neff``. If ``filter_pol==None``, they are simply sorted in order of decreasing effective index. If a polarization filter is selected, the modes are rearranged such that the first ``n_pol`` modes in the list are the ones with the selected polarization fraction larger than or equal to 0.5, while the next ``num_modes - n_pol`` modes are the ones where it is smaller than 0.5 (i.e. the opposite polarization fraction is larger than 0.5). Within each polarization subset, the modes are still ordered by decreasing effective index. ``te``-fraction is defined as the integrated intensity of the E-field component parallel to the first plane axis, normalized to the total in-plane E-field intensity. Conversely, ``tm``-fraction uses the E field component parallel to the second plane axis.",
          "enum": [
            "te",
            "tm"
          ],
          "type": "string"
        },
        "angle_theta": {
          "title": "Polar Angle",
          "description": "Polar angle of the propagation axis from the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "angle_phi": {
          "title": "Azimuth Angle",
          "description": "Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "precision": {
          "title": "single or double precision in mode solver",
          "description": "The solver will be faster and using less memory under single precision, but more accurate under double precision.",
          "default": "single",
          "enum": [
            "single",
            "double"
          ],
          "type": "string"
        },
        "bend_radius": {
          "title": "Bend radius",
          "description": "A curvature radius for simulation of waveguide bends. Can be negative, in which case the mode plane center has a smaller value than the curvature center along the tangential axis perpendicular to the bend axis.",
          "units": "um",
          "type": "number"
        },
        "bend_axis": {
          "title": "Bend axis",
          "description": "Index into the two tangential axes defining the normal to the plane in which the bend lies. This must be provided if ``bend_radius`` is not ``None``. For example, for a ring in the global xy-plane, and a mode plane in either the xz or the yz plane, the ``bend_axis`` is always 1 (the global z axis).",
          "enum": [
            0,
            1
          ],
          "type": "integer"
        },
        "track_freq": {
          "title": "Mode Tracking Frequency",
          "description": "Parameter that turns on/off mode tracking based on their similarity. Can take values ``'lowest'``, ``'central'``, or ``'highest'``, which correspond to mode tracking based on the lowest, central, or highest frequency. If ``None`` no mode tracking is performed.",
          "default": "central",
          "enum": [
            "central",
            "lowest",
            "highest"
          ],
          "type": "string"
        },
        "group_index_step": {
          "title": "Frequency step for group index computation",
          "description": "Control the computation of the group index alongside the effective index. If set to a positive value, it sets the fractional frequency step used in the numerical differentiation of the effective index to compute the group index. If set to `True`, the default of 0.005 is used.",
          "default": false,
          "anyOf": [
            {
              "type": "number",
              "exclusiveMinimum": 0
            },
            {
              "type": "boolean"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "ModeSpec",
          "enum": [
            "ModeSpec"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "ModeSource": {
      "title": "ModeSource",
      "description": "Injects current source to excite modal profile on finite extent plane.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional name for the source.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave, CustomSourceTime]\n    Specification of the source time-dependence.\nnum_freqs : ConstrainedIntValue = 1\n    Number of points used to approximate the frequency dependence of injected field. A Chebyshev interpolation is used, thus, only a small number of points, i.e., less than 20, is typically sufficient to obtain converged results.\ndirection : Literal['+', '-']\n    Specifies propagation in the positive or negative direction of the injection axis.\nmode_spec : ModeSpec = ModeSpec(num_modes=1, target_neff=None, num_pml=(0,, 0), filter_pol=None, angle_theta=0.0, angle_phi=0.0, precision='single', bend_radius=None, bend_axis=None, track_freq='central', group_index_step=False, type='ModeSpec')\n    Parameters to feed to mode solver which determine modes measured by monitor.\nmode_index : NonNegativeInt = 0\n    Index into the collection of modes returned by mode solver.  Specifies which mode to inject using this source. If larger than ``mode_spec.num_modes``, ``num_modes`` in the solver will be set to ``mode_index + 1``.\n\nNotes\n-----\n\n    Using this mode source, it is possible selectively excite one of the guided modes of a waveguide. This can be\n    computed in our eigenmode solver :class:`tidy3d.plugins.mode.ModeSolver` and implement the mode simulation in\n    FDTD.\n\n    Mode sources are normalized to inject exactly 1W of power at the central frequency.\n\n    The modal source allows you to do directional excitation. Illustrated\n    by the image below, the field is perfectly launched to the right of the source and there's zero field to the\n    left of the source. Now you can contrast the behavior of the modal source with that of a dipole source. If\n    you just put a dipole into the waveguide, well, you see quite a bit different in the field distribution.\n    First of all, the dipole source is not directional launching. It launches waves in both directions. The\n    second is that the polarization of the dipole is set to selectively excite a TE mode. But it takes some\n    propagation distance before the mode settles into a perfect TE mode profile. During this process,\n    there is radiation into the substrate.\n\n    .. image:: ../../_static/img/mode_vs_dipole_source.png\n\n    .. TODO improve links to other APIs functionality here.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> mode_spec = ModeSpec(target_neff=2.)\n>>> mode_source = ModeSource(\n...     size=(10,10,0),\n...     source_time=pulse,\n...     mode_spec=mode_spec,\n...     mode_index=1,\n...     direction='-')\n\nSee Also\n--------\n\n:class:`tidy3d.plugins.mode.ModeSolver`:\n    Interface for solving electromagnetic eigenmodes in a 2D plane with translational invariance in the third dimension.\n\n**Notebooks:**\n    * `Waveguide Y junction <../../notebooks/YJunction.html>`_\n    * `90 degree optical hybrid <../../notebooks/90OpticalHybrid.html>`_\n\n**Lectures:**\n    * `Prelude to Integrated Photonics Simulation: Mode Injection <https://www.flexcompute.com/fdtd101/Lecture-4-Prelude-to-Integrated-Photonics-Simulation-Mode-Injection/>`_",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "ModeSource",
          "enum": [
            "ModeSource"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "GaussianPulse": "#/definitions/GaussianPulse",
              "ContinuousWave": "#/definitions/ContinuousWave",
              "CustomSourceTime": "#/definitions/CustomSourceTime"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            },
            {
              "$ref": "#/definitions/CustomSourceTime"
            }
          ]
        },
        "num_freqs": {
          "title": "Number of Frequency Points",
          "description": "Number of points used to approximate the frequency dependence of injected field. A Chebyshev interpolation is used, thus, only a small number of points, i.e., less than 20, is typically sufficient to obtain converged results.",
          "default": 1,
          "minimum": 1,
          "maximum": 99,
          "type": "integer"
        },
        "direction": {
          "title": "Direction",
          "description": "Specifies propagation in the positive or negative direction of the injection axis.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "mode_spec": {
          "title": "Mode Specification",
          "description": "Parameters to feed to mode solver which determine modes measured by monitor.",
          "default": {
            "num_modes": 1,
            "target_neff": null,
            "num_pml": [
              0,
              0
            ],
            "filter_pol": null,
            "angle_theta": 0.0,
            "angle_phi": 0.0,
            "precision": "single",
            "bend_radius": null,
            "bend_axis": null,
            "track_freq": "central",
            "group_index_step": false,
            "type": "ModeSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ModeSpec"
            }
          ]
        },
        "mode_index": {
          "title": "Mode Index",
          "description": "Index into the collection of modes returned by mode solver.  Specifies which mode to inject using this source. If larger than ``mode_spec.num_modes``, ``num_modes`` in the solver will be set to ``mode_index + 1``.",
          "default": 0,
          "minimum": 0,
          "type": "integer"
        }
      },
      "required": [
        "size",
        "source_time",
        "direction"
      ],
      "additionalProperties": false
    },
    "PlaneWave": {
      "title": "PlaneWave",
      "description": "Uniform current distribution on an infinite extent plane. One element of size must be zero.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional name for the source.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave, CustomSourceTime]\n    Specification of the source time-dependence.\ndirection : Literal['+', '-']\n    Specifies propagation in the positive or negative direction of the injection axis.\nangle_theta : float = 0.0\n    [units = rad].  Polar angle of the propagation axis from the injection axis.\nangle_phi : float = 0.0\n    [units = rad].  Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.\npol_angle : float = 0\n    [units = rad].  Specifies the angle between the electric field polarization of the source and the plane defined by the injection axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> pw_source = PlaneWave(size=(inf,0,inf), source_time=pulse, pol_angle=0.1, direction='+')\n\nSee Also\n--------\n\n**Notebooks:**\n    * `How to troubleshoot a diverged FDTD simulation <../../notebooks/DivergedFDTDSimulation.html>`_\n\n**Lectures:**\n    * `Using FDTD to Compute a Transmission Spectrum <https://www.flexcompute.com/fdtd101/Lecture-2-Using-FDTD-to-Compute-a-Transmission-Spectrum/>`__",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "PlaneWave",
          "enum": [
            "PlaneWave"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "GaussianPulse": "#/definitions/GaussianPulse",
              "ContinuousWave": "#/definitions/ContinuousWave",
              "CustomSourceTime": "#/definitions/CustomSourceTime"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            },
            {
              "$ref": "#/definitions/CustomSourceTime"
            }
          ]
        },
        "direction": {
          "title": "Direction",
          "description": "Specifies propagation in the positive or negative direction of the injection axis.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "angle_theta": {
          "title": "Polar Angle",
          "description": "Polar angle of the propagation axis from the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "angle_phi": {
          "title": "Azimuth Angle",
          "description": "Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "pol_angle": {
          "title": "Polarization Angle",
          "description": "Specifies the angle between the electric field polarization of the source and the plane defined by the injection axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.",
          "default": 0,
          "units": "rad",
          "type": "number"
        }
      },
      "required": [
        "size",
        "source_time",
        "direction"
      ],
      "additionalProperties": false
    },
    "FieldDataset": {
      "title": "FieldDataset",
      "description": "Dataset storing a collection of the scalar components of E and H fields in the freq. domain\n\nParameters\n----------\nEx : Optional[ScalarFieldDataArray] = None\n    Spatial distribution of the x-component of the electric field.\nEy : Optional[ScalarFieldDataArray] = None\n    Spatial distribution of the y-component of the electric field.\nEz : Optional[ScalarFieldDataArray] = None\n    Spatial distribution of the z-component of the electric field.\nHx : Optional[ScalarFieldDataArray] = None\n    Spatial distribution of the x-component of the magnetic field.\nHy : Optional[ScalarFieldDataArray] = None\n    Spatial distribution of the y-component of the magnetic field.\nHz : Optional[ScalarFieldDataArray] = None\n    Spatial distribution of the z-component of the magnetic field.\n\nExample\n-------\n>>> x = [-1,1]\n>>> y = [-2,0,2]\n>>> z = [-3,-1,1,3]\n>>> f = [2e14, 3e14]\n>>> coords = dict(x=x, y=y, z=z, f=f)\n>>> scalar_field = ScalarFieldDataArray((1+1j) * np.random.random((2,3,4,2)), coords=coords)\n>>> data = FieldDataset(Ex=scalar_field, Hz=scalar_field)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "FieldDataset",
          "enum": [
            "FieldDataset"
          ],
          "type": "string"
        },
        "Ex": {
          "title": "DataArray",
          "description": "Spatial distribution of the x-component of the electric field.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "Ey": {
          "title": "DataArray",
          "description": "Spatial distribution of the y-component of the electric field.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "Ez": {
          "title": "DataArray",
          "description": "Spatial distribution of the z-component of the electric field.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "Hx": {
          "title": "DataArray",
          "description": "Spatial distribution of the x-component of the magnetic field.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "Hy": {
          "title": "DataArray",
          "description": "Spatial distribution of the y-component of the magnetic field.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "Hz": {
          "title": "DataArray",
          "description": "Spatial distribution of the z-component of the magnetic field.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        }
      },
      "additionalProperties": false
    },
    "CustomFieldSource": {
      "title": "CustomFieldSource",
      "description": "Implements a source corresponding to an input dataset containing ``E`` and ``H`` fields,\nusing the equivalence principle to define the actual injected currents.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional name for the source.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave, CustomSourceTime]\n    Specification of the source time-dependence.\nfield_dataset : Optional[FieldDataset]\n    :class:`.FieldDataset` containing the desired frequency-domain fields patterns to inject. At least one tangential field component must be specified.\n\n Notes\n -----\n\n    For the injection to work as expected (i.e. to reproduce the required ``E`` and ``H`` fields),\n    the field data must decay by the edges of the source plane, or the source plane must span the entire\n    simulation domain and the fields must match the simulation boundary conditions.\n\n    The equivalent source currents are fully defined by the field components tangential to the\n    source plane. For e.g. source normal along ``z``, the normal components (``Ez`` and ``Hz``)\n    can be provided but will have no effect on the results, and at least one of the tangential\n    components has to be in the dataset, i.e. at least one of ``Ex``, ``Ey``, ``Hx``, and ``Hy``.\n\n    .. TODO add image here\n\n    ..\n        TODO is this generic? Only the field components tangential to the custom source plane are needed and used\n        in the simulation. Due to the equivalence principle, these fully define the currents that need to be\n        injected. This is not to say that the normal components of the data (:math:`E_x`, :math:`H_x` in our example)\n        is lost or not injected. It is merely not needed as it can be uniquely obtained using the tangential components.\n\n    ..\n        TODO add example for this standalone\n        Source data can be imported from file just as shown here, after the data is imported as a numpy array using\n        standard numpy functions like loadtxt.\n\n    If the data is not coming from a ``tidy3d`` simulation, the normalization is likely going to be arbitrary and\n    the directionality of the source will likely not be perfect, even if both the ``E`` and ``H`` fields are\n    provided. An empty normalizing run may be needed to accurately normalize results.\n\n    The coordinates of all provided fields are assumed to be relative to the source center.\n    If only the ``E`` or only the ``H`` fields are provided, the source will not be directional,\n    but will inject equal power in both directions instead.\n\nExample\n-------\n>>> from tidy3d import ScalarFieldDataArray\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> x = np.linspace(-1, 1, 101)\n>>> y = np.linspace(-1, 1, 101)\n>>> z = np.array([0])\n>>> f = [2e14]\n>>> coords = dict(x=x, y=y, z=z, f=f)\n>>> scalar_field = ScalarFieldDataArray(np.ones((101, 101, 1, 1)), coords=coords)\n>>> dataset = FieldDataset(Ex=scalar_field)\n>>> custom_source = CustomFieldSource(\n...     center=(1, 1, 1),\n...     size=(2, 2, 0),\n...     source_time=pulse,\n...     field_dataset=dataset)\n\nSee Also\n--------\n\n**Notebooks**\n    * `Defining spatially-varying sources <../../notebooks/CustomFieldSource.html>`_",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "CustomFieldSource",
          "enum": [
            "CustomFieldSource"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "GaussianPulse": "#/definitions/GaussianPulse",
              "ContinuousWave": "#/definitions/ContinuousWave",
              "CustomSourceTime": "#/definitions/CustomSourceTime"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            },
            {
              "$ref": "#/definitions/CustomSourceTime"
            }
          ]
        },
        "field_dataset": {
          "title": "Field Dataset",
          "description": ":class:`.FieldDataset` containing the desired frequency-domain fields patterns to inject. At least one tangential field component must be specified.",
          "allOf": [
            {
              "$ref": "#/definitions/FieldDataset"
            }
          ]
        }
      },
      "required": [
        "size",
        "source_time",
        "field_dataset"
      ],
      "additionalProperties": false
    },
    "CustomCurrentSource": {
      "title": "CustomCurrentSource",
      "description": "Implements a source corresponding to an input dataset containing ``E`` and ``H`` fields.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional name for the source.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave, CustomSourceTime]\n    Specification of the source time-dependence.\ninterpolate : bool = True\n    Handles reverse-interpolation of zero-size dimensions of the source. If ``False``, the source data is snapped to the nearest Yee grid point. If ``True``, equivalent source data is applied on the surrounding Yee grid points to emulate placement at the specified location using linear interpolation.\ncurrent_dataset : Optional[FieldDataset]\n    :class:`.FieldDataset` containing the desired frequency-domain electric and magnetic current patterns to inject.\n\nNotes\n-----\n\n    Injects the specified components of the ``E`` and ``H`` dataset directly as ``J`` and ``M`` current\n    distributions in the FDTD solver. The coordinates of all provided fields are assumed to be relative to the\n    source center.\n\n    The syntax is very similar to :class:`CustomFieldSource`, except instead of a ``field_dataset``, the source\n    accepts a :attr:`current_dataset`. This dataset still contains :math:`E_{x,y,z}` and :math:`H_{x,y,\n    z}` field components, which correspond to :math:`J` and :math:`M` components respectively. There are also\n    fewer constraints on the data requirements for :class:`CustomCurrentSource`. It can be volumetric or planar\n    without requiring tangential components. Finally, note that the dataset is still defined w.r.t. the source\n    center, just as in the case of the :class:`CustomFieldSource`, and can then be placed anywhere in the simulation.\n\nExample\n-------\n>>> from tidy3d import ScalarFieldDataArray\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> x = np.linspace(-1, 1, 101)\n>>> y = np.linspace(-1, 1, 101)\n>>> z = np.array([0])\n>>> f = [2e14]\n>>> coords = dict(x=x, y=y, z=z, f=f)\n>>> scalar_field = ScalarFieldDataArray(np.ones((101, 101, 1, 1)), coords=coords)\n>>> dataset = FieldDataset(Ex=scalar_field)\n>>> custom_source = CustomCurrentSource(\n...     center=(1, 1, 1),\n...     size=(2, 2, 0),\n...     source_time=pulse,\n...     current_dataset=dataset)\n\nSee Also\n--------\n\n**Notebooks**\n    * `Defining spatially-varying sources <../../notebooks/CustomFieldSource.html>`_",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "CustomCurrentSource",
          "enum": [
            "CustomCurrentSource"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "GaussianPulse": "#/definitions/GaussianPulse",
              "ContinuousWave": "#/definitions/ContinuousWave",
              "CustomSourceTime": "#/definitions/CustomSourceTime"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            },
            {
              "$ref": "#/definitions/CustomSourceTime"
            }
          ]
        },
        "interpolate": {
          "title": "Enable Interpolation",
          "description": "Handles reverse-interpolation of zero-size dimensions of the source. If ``False``, the source data is snapped to the nearest Yee grid point. If ``True``, equivalent source data is applied on the surrounding Yee grid points to emulate placement at the specified location using linear interpolation.",
          "default": true,
          "type": "boolean"
        },
        "current_dataset": {
          "title": "Current Dataset",
          "description": ":class:`.FieldDataset` containing the desired frequency-domain electric and magnetic current patterns to inject.",
          "allOf": [
            {
              "$ref": "#/definitions/FieldDataset"
            }
          ]
        }
      },
      "required": [
        "size",
        "source_time",
        "current_dataset"
      ],
      "additionalProperties": false
    },
    "TFSF": {
      "title": "TFSF",
      "description": "Total-field scattered-field (TFSF) source that can inject a plane wave in a finite region.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional name for the source.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave, CustomSourceTime]\n    Specification of the source time-dependence.\ndirection : Literal['+', '-']\n    Specifies propagation in the positive or negative direction of the injection axis.\nangle_theta : float = 0.0\n    [units = rad].  Polar angle of the propagation axis from the injection axis.\nangle_phi : float = 0.0\n    [units = rad].  Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.\npol_angle : float = 0\n    [units = rad].  Specifies the angle between the electric field polarization of the source and the plane defined by the injection axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.\ninjection_axis : Literal[0, 1, 2]\n    Specifies the injection axis. The plane of incidence is defined via this ``injection_axis`` and the ``direction``. The popagation axis is defined with respect to the ``injection_axis`` by ``angle_theta`` and ``angle_phi``.\n\nNotes\n-----\n\n    The TFSF source injects :math:`\\frac{1 W}{\\mu m^2}` of power along the :attr:`injection_axis`. Note that in the\n    case of angled incidence, :math:`\\frac{1 W}{\\mu m^2}` is still injected along the source's :attr:`injection_axis`,\n    and not the propagation direction, unlike a :class:`PlaneWave` source. This allows computing\n    scattering and absorption cross-sections without the need for additional normalization.\n\n    The TFSF source allows specifying a box region into which a plane wave is injected. Fields inside this region\n    can be interpreted as the superposition of the incident field and the scattered field due to any scatterers\n    present in the simulation domain. The fields at the edges of the TFSF box are modified at each time step such\n    that the incident field is cancelled out, so that all fields outside the TFSF box are scattered fields only.\n    This is useful in scenarios where one is interested in computing scattered fields only, for example when\n    computing scattered cross-sections of various objects.\n\n    It is important to note that when a non-uniform grid is used in the directions transverse to the\n    :attr:`injection_axis` of the TFSF source, the suppression of the incident field outside the TFSF box may not be as\n    close to zero as in the case of a uniform grid. Because of this, a warning may be issued when nonuniform grid\n    TFSF setup is detected. In some cases, however, the accuracy may be only weakly affected, and the warnings\n    can be ignored.\n\nSee Also\n--------\n\n**Notebooks**:\n    * `Defining a total-field scattered-field (TFSF) plane wave source <../../notebooks/TFSF.html>`_\n    * `Nanoparticle Scattering <../../notebooks/PlasmonicNanoparticle.html>`_: To force a uniform grid in the TFSF region and avoid the warnings, a mesh override structure can be used as illustrated here.",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "TFSF",
          "enum": [
            "TFSF"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "GaussianPulse": "#/definitions/GaussianPulse",
              "ContinuousWave": "#/definitions/ContinuousWave",
              "CustomSourceTime": "#/definitions/CustomSourceTime"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            },
            {
              "$ref": "#/definitions/CustomSourceTime"
            }
          ]
        },
        "direction": {
          "title": "Direction",
          "description": "Specifies propagation in the positive or negative direction of the injection axis.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "angle_theta": {
          "title": "Polar Angle",
          "description": "Polar angle of the propagation axis from the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "angle_phi": {
          "title": "Azimuth Angle",
          "description": "Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "pol_angle": {
          "title": "Polarization Angle",
          "description": "Specifies the angle between the electric field polarization of the source and the plane defined by the injection axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.",
          "default": 0,
          "units": "rad",
          "type": "number"
        },
        "injection_axis": {
          "title": "Injection Axis",
          "description": "Specifies the injection axis. The plane of incidence is defined via this ``injection_axis`` and the ``direction``. The popagation axis is defined with respect to the ``injection_axis`` by ``angle_theta`` and ``angle_phi``.",
          "enum": [
            0,
            1,
            2
          ],
          "type": "integer"
        }
      },
      "required": [
        "size",
        "source_time",
        "direction",
        "injection_axis"
      ],
      "additionalProperties": false
    },
    "Periodic": {
      "title": "Periodic",
      "description": "Periodic boundary condition class.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for boundary.",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for boundary.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "Periodic",
          "enum": [
            "Periodic"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PECBoundary": {
      "title": "PECBoundary",
      "description": "Perfect electric conductor boundary condition class.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for boundary.",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for boundary.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "PECBoundary",
          "enum": [
            "PECBoundary"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PMCBoundary": {
      "title": "PMCBoundary",
      "description": "Perfect magnetic conductor boundary condition class.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for boundary.",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for boundary.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "PMCBoundary",
          "enum": [
            "PMCBoundary"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PMLParams": {
      "title": "PMLParams",
      "description": "Specifies full set of parameters needed for complex, frequency-shifted PML.\n\nParameters\n----------\nsigma_order : NonNegativeInt = 3\n    Order of the polynomial describing the absorber profile (~dist^sigma_order).\nsigma_min : NonNegativeFloat = 0.0\n    [units = 2*EPSILON_0/dt].  Minimum value of the absorber conductivity.\nsigma_max : NonNegativeFloat = 1.5\n    [units = 2*EPSILON_0/dt].  Maximum value of the absorber conductivity.\nkappa_order : NonNegativeInt = 3\n    Order of the polynomial describing the PML kappa profile (kappa~dist^kappa_order).\nkappa_min : NonNegativeFloat = 0.0\n    \nkappa_max : NonNegativeFloat = 1.5\n    \nalpha_order : NonNegativeInt = 3\n    Order of the polynomial describing the PML alpha profile (alpha~dist^alpha_order).\nalpha_min : NonNegativeFloat = 0.0\n    [units = 2*EPSILON_0/dt].  Minimum value of the PML alpha.\nalpha_max : NonNegativeFloat = 1.5\n    [units = 2*EPSILON_0/dt].  Maximum value of the PML alpha.\n\nExample\n-------\n>>> params = PMLParams(sigma_order=3, sigma_min=0.0, sigma_max=1.5, kappa_min=0.0)",
      "type": "object",
      "properties": {
        "sigma_order": {
          "title": "Sigma Order",
          "description": "Order of the polynomial describing the absorber profile (~dist^sigma_order).",
          "default": 3,
          "minimum": 0,
          "type": "integer"
        },
        "sigma_min": {
          "title": "Sigma Minimum",
          "description": "Minimum value of the absorber conductivity.",
          "default": 0.0,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        },
        "sigma_max": {
          "title": "Sigma Maximum",
          "description": "Maximum value of the absorber conductivity.",
          "default": 1.5,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        },
        "type": {
          "title": "Type",
          "default": "PMLParams",
          "enum": [
            "PMLParams"
          ],
          "type": "string"
        },
        "kappa_order": {
          "title": "Kappa Order",
          "description": "Order of the polynomial describing the PML kappa profile (kappa~dist^kappa_order).",
          "default": 3,
          "minimum": 0,
          "type": "integer"
        },
        "kappa_min": {
          "title": "Kappa Minimum",
          "default": 0.0,
          "minimum": 0,
          "type": "number"
        },
        "kappa_max": {
          "title": "Kappa Maximum",
          "default": 1.5,
          "minimum": 0,
          "type": "number"
        },
        "alpha_order": {
          "title": "Alpha Order",
          "description": "Order of the polynomial describing the PML alpha profile (alpha~dist^alpha_order).",
          "default": 3,
          "minimum": 0,
          "type": "integer"
        },
        "alpha_min": {
          "title": "Alpha Minimum",
          "description": "Minimum value of the PML alpha.",
          "default": 0.0,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        },
        "alpha_max": {
          "title": "Alpha Maximum",
          "description": "Maximum value of the PML alpha.",
          "default": 1.5,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        }
      },
      "additionalProperties": false
    },
    "PML": {
      "title": "PML",
      "description": "Specifies a standard PML along a single dimension.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for boundary.\nnum_layers : NonNegativeInt = 12\n    Number of layers of standard PML.\nparameters : PMLParams = PMLParams(sigma_order=3, sigma_min=0.0, sigma_max=1.5, type='PMLParams', kappa_order=3, kappa_min=1.0, kappa_max=3.0, alpha_order=1, alpha_min=0.0, alpha_max=0.0)\n    Parameters of the complex frequency-shifted absorption poles.\n\nNotes\n------\n\n    **1D Model Illustration**\n\n    Consider a transformed wave equation in the :math:`x` dimension below _`[1]`:\n\n    .. math::\n\n         \\left( \\left( \\frac{1}{s(x)} \\frac{\\delta}{\\delta x} \\right)^2 - \\frac{1}{c^2} \\frac{\\delta^2}{\\delta t^2} \\right) E = 0\n\n    where the wave stretch factor :math:`s(x)` depends on the PML boundary position in the :math:`x` dimension.\n\n    .. TODO what is x at 0?\n\n    .. math::\n\n         s(x) = \\left \\{\n                    \\begin{array}{lr}\n                        1, & \\text{for } x < 0 \\\\\n                        1 - \\frac{\\sigma}{i \\omega \\epsilon_0}, & \\text{for } x > 0\n                    \\end{array}\n                \\right \\}\n\n    The wave equation can be solved and plotted accordingly as a function of the :math:`x` dimension.\n\n    .. math::\n\n         E(x) = \\left \\{\n                    \\begin{array}{lr}\n                        e^{i(kx - \\omega t)}, & \\text{for } x < 0 \\\\\n                        e^{i(kx - \\omega t)} \\times e^{-\\frac{\\sigma x}{c \\epsilon_0}} & \\text{for } x > 0\n                    \\end{array}\n                \\right \\}\n\n    Hence, we see how this PML stretch factor induces frequency-independent exponential attentation and no\n    reflection after the boundary at :math:`x=0`.\n\n    .. image:: ../../_static/img/pml_boundary.png\n\n    .. TODO make this image better\n\n    **Usage Caveats**\n\n    A perfectly matched layer (PML) is the most commonly used boundary condition in FDTD simulations to truncate\n    a simulation domain and absorb outgoing radiation. However, many divergence issues are associated with the\n    use of PML. One of the most common causes of a diverged simulation is structures inserted into PML at an angle.\n\n    .. TODO links to absorber boundaries\n\n    .. image:: ../../notebooks/img/diverged-fdtd-simulation.png\n\n    Incorporating a dispersive material into the PML can also cause simulation divergence in certain scenarios.\n    If your simulation lacks any structures inserted into the PML at an angle, but includes dispersive material\n    in PML, it is advisable to substitute a nondispersive material for the dispersive material. Alternatively,\n    if dispersion is necessary, switching from the :class:`PML` to :class:`Absorber` can effectively address the\n    issue.\n\n    The PML can effectively absorb outgoing radiation with minimum reflection as if the radiation just propagates\n    into the free space. However, it\u2019s important to keep in mind that the PML only absorbs propagating fields. For\n    evanescent fields, the PML can act as an amplification medium and cause a simulation to diverge. In Tidy3D,\n    a warning will appear if the distance between a structure is smaller than half of a wavelength to prevent\n    evanescent fields from leaking into PML. In most cases, the evanescent field will naturally die off within\n    half a wavelength, but in some instances, a larger distance may be required.\n\n    .. image:: ../../notebooks/img/diverged-fdtd-simulation1.png\n\n\n    **References**\n\n    .. [1]  W.C. Chew and W.H. Weedon, Microwave and Optical Tech. Lett., 7 (13), 599,1994; S. Johnson, arXiv 2108.05348, 2021\n    .. [2]  Antonios Giannopoulos, IEEE Transactions on Antennas and Propagation, 56(9), 2995, 2008\n\nNote\n----\n\n    For best results, structures that intersect with the PML or simulation edges should extend extend all the way\n    through. In many such cases, an \u201cinfinite\u201d size ``td.inf`` can be used to define the size along that dimension.\n\nExample\n-------\n>>> pml = PML(num_layers=10)\n\nSee Also\n--------\n\n:class:`StablePML`:\n     This PML deals handles possibly divergent simulations better, but at the expense of more layers.\n\n:class:`Absorber`:\n     Specifies an adiabatic absorber along a single dimension.\n\n**Notebooks:**\n    * `How to troubleshoot a diverged FDTD simulation <../../notebooks/DivergedFDTDSimulation.html>`_\n\n**Lectures:**\n    * `Using FDTD to Compute a Transmission Spectrum <https://www.flexcompute.com/fdtd101/Lecture-2-Using-FDTD-to-Compute-a-Transmission-Spectrum/>`__\n    * `Introduction to perfectly matched layer (PML) tutorial <https://www.flexcompute.com/fdtd101/Lecture-6-Introduction-to-perfectly-matched-layer/>`__",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for boundary.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "PML",
          "enum": [
            "PML"
          ],
          "type": "string"
        },
        "num_layers": {
          "title": "Number of Layers",
          "description": "Number of layers of standard PML.",
          "default": 12,
          "minimum": 0,
          "type": "integer"
        },
        "parameters": {
          "title": "PML Parameters",
          "description": "Parameters of the complex frequency-shifted absorption poles.",
          "default": {
            "sigma_order": 3,
            "sigma_min": 0.0,
            "sigma_max": 1.5,
            "type": "PMLParams",
            "kappa_order": 3,
            "kappa_min": 1.0,
            "kappa_max": 3.0,
            "alpha_order": 1,
            "alpha_min": 0.0,
            "alpha_max": 0.0
          },
          "allOf": [
            {
              "$ref": "#/definitions/PMLParams"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "StablePML": {
      "title": "StablePML",
      "description": "Specifies a 'stable' PML along a single dimension.\nThis PML deals handles possibly divergent simulations better, but at the expense of more layers.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for boundary.\nnum_layers : NonNegativeInt = 40\n    Number of layers of 'stable' PML.\nparameters : PMLParams = PMLParams(sigma_order=3, sigma_min=0.0, sigma_max=1.0, type='PMLParams', kappa_order=3, kappa_min=1.0, kappa_max=5.0, alpha_order=1, alpha_min=0.0, alpha_max=0.9)\n    'Stable' parameters of the complex frequency-shifted absorption poles.\n\nExample\n-------\n>>> pml = StablePML(num_layers=40)\n\nSee Also\n--------\n\n:class:`PML`:\n     A standard PML along a single dimension.\n\n:class:`Absorber`:\n     Specifies an adiabatic absorber along a single dimension.\n\n**Notebooks:**\n    * `How to troubleshoot a diverged FDTD simulation <../../notebooks/DivergedFDTDSimulation.html>`_\n\n**Lectures:**\n    * `Introduction to perfectly matched layer (PML) tutorial <https://www.flexcompute.com/fdtd101/Lecture-6-Introduction-to-perfectly-matched-layer/>`__",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for boundary.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "StablePML",
          "enum": [
            "StablePML"
          ],
          "type": "string"
        },
        "num_layers": {
          "title": "Number of Layers",
          "description": "Number of layers of 'stable' PML.",
          "default": 40,
          "minimum": 0,
          "type": "integer"
        },
        "parameters": {
          "title": "Stable PML Parameters",
          "description": "'Stable' parameters of the complex frequency-shifted absorption poles.",
          "default": {
            "sigma_order": 3,
            "sigma_min": 0.0,
            "sigma_max": 1.0,
            "type": "PMLParams",
            "kappa_order": 3,
            "kappa_min": 1.0,
            "kappa_max": 5.0,
            "alpha_order": 1,
            "alpha_min": 0.0,
            "alpha_max": 0.9
          },
          "allOf": [
            {
              "$ref": "#/definitions/PMLParams"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "AbsorberParams": {
      "title": "AbsorberParams",
      "description": "Specifies parameters common to Absorbers and PMLs.\n\nParameters\n----------\nsigma_order : NonNegativeInt = 3\n    Order of the polynomial describing the absorber profile (~dist^sigma_order).\nsigma_min : NonNegativeFloat = 0.0\n    [units = 2*EPSILON_0/dt].  Minimum value of the absorber conductivity.\nsigma_max : NonNegativeFloat = 1.5\n    [units = 2*EPSILON_0/dt].  Maximum value of the absorber conductivity.\n\nExample\n-------\n>>> params = AbsorberParams(sigma_order=3, sigma_min=0.0, sigma_max=1.5)",
      "type": "object",
      "properties": {
        "sigma_order": {
          "title": "Sigma Order",
          "description": "Order of the polynomial describing the absorber profile (~dist^sigma_order).",
          "default": 3,
          "minimum": 0,
          "type": "integer"
        },
        "sigma_min": {
          "title": "Sigma Minimum",
          "description": "Minimum value of the absorber conductivity.",
          "default": 0.0,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        },
        "sigma_max": {
          "title": "Sigma Maximum",
          "description": "Maximum value of the absorber conductivity.",
          "default": 1.5,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        },
        "type": {
          "title": "Type",
          "default": "AbsorberParams",
          "enum": [
            "AbsorberParams"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "Absorber": {
      "title": "Absorber",
      "description": "Specifies an adiabatic absorber along a single dimension.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for boundary.\nnum_layers : NonNegativeInt = 40\n    Number of layers of absorber to add to + and - boundaries.\nparameters : AbsorberParams = AbsorberParams(sigma_order=3, sigma_min=0.0, sigma_max=6.4, type='AbsorberParams')\n    Adiabatic absorber parameters.\n\nNotes\n-----\n\n    This absorber is well-suited for dispersive materials intersecting with absorbing edges of the simulation at the\n    expense of more layers.\n\n    **Usage Caveats**\n\n    Using absorber boundary is often a good remedy to resolve divergence issues related to :class:`PML`. The\n    adiabatic absorber is a multilayer system with gradually increasing conductivity. The absorber usually has a\n    larger undesired reflection compared to :class:`PML`. In practice, this small difference rarely matters,\n    but is important to understand for simulations that require high accuracy.\n\n    There are two possible sources for the reflection from absorbers. The first, and more common one, is that the\n    ramping up of the conductivity is not sufficiently slow, which can be remedied by increasing the number of\n    absorber layers (40 by default). The second one is that the absorption is not high enough, such that the\n    light reaches the :class:`PEC` boundary at the end of the :class:`Absorber`, travels back through it,\n    and is still not fully attenuated before re-entering the simulation region. If this is the case, increasing\n    the maximum conductivity :class:`AbsorberParams` can help. In both cases, changing the order of the scaling\n    of the conductivity (:attr:`tidy3d.AbsorberParams.sigma_order`) can also have an effect, but this is a more\n    advanced setting that we typically do not recommend modifying.\n\nExample\n-------\n>>> pml = Absorber(num_layers=40)\n\nSee Also\n--------\n\n:class:`PML`:\n     A standard PML along a single dimension.\n\n**Notebooks:**\n    * `How to troubleshoot a diverged FDTD simulation <../../notebooks/DivergedFDTDSimulation.html>`_",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for boundary.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "Absorber",
          "enum": [
            "Absorber"
          ],
          "type": "string"
        },
        "num_layers": {
          "title": "Number of Layers",
          "description": "Number of layers of absorber to add to + and - boundaries.",
          "default": 40,
          "minimum": 0,
          "type": "integer"
        },
        "parameters": {
          "title": "Absorber Parameters",
          "description": "Adiabatic absorber parameters.",
          "default": {
            "sigma_order": 3,
            "sigma_min": 0.0,
            "sigma_max": 6.4,
            "type": "AbsorberParams"
          },
          "allOf": [
            {
              "$ref": "#/definitions/AbsorberParams"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "BlochBoundary": {
      "title": "BlochBoundary",
      "description": "Specifies a Bloch boundary condition along a single dimension.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for boundary.\nbloch_vec : float\n    Normalized component of the Bloch vector in units of 2 * pi / (size along dimension) in the background medium, along the dimension in which the boundary is specified.\n\nExample\n-------\n>>> bloch = BlochBoundary(bloch_vec=1)\n\nSee Also\n--------\n\n**Notebooks**:\n    * `Defining a total-field scattered-field (TFSF) plane wave source <../../notebooks/TFSF.html>`_\n    * `Multilevel blazed diffraction grating <../../notebooks/GratingEfficiency.html>`_",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for boundary.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "BlochBoundary",
          "enum": [
            "BlochBoundary"
          ],
          "type": "string"
        },
        "bloch_vec": {
          "title": "Normalized Bloch vector component",
          "description": "Normalized component of the Bloch vector in units of 2 * pi / (size along dimension) in the background medium, along the dimension in which the boundary is specified.",
          "type": "number"
        }
      },
      "required": [
        "bloch_vec"
      ],
      "additionalProperties": false
    },
    "Boundary": {
      "title": "Boundary",
      "description": "Boundary conditions at the minus and plus extents along a dimension.\n\nParameters\n----------\nplus : Union[Periodic, PECBoundary, PMCBoundary, PML, StablePML, Absorber, BlochBoundary] = PML(name=None, type='PML', num_layers=12, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0))\n    Boundary condition on the plus side along a dimension.\nminus : Union[Periodic, PECBoundary, PMCBoundary, PML, StablePML, Absorber, BlochBoundary] = PML(name=None, type='PML', num_layers=12, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0))\n    Boundary condition on the minus side along a dimension.\n\nNotes\n-----\n\n     To specify individual boundary conditions along different dimensions, instead of :class:`BoundarySpec`,\n     this class is used, which defines the ``plus`` and ``minus`` boundaries along a single\n     dimension.\n\nExample\n-------\n>>> boundary = Boundary(plus = PML(), minus = PECBoundary())\n\nSee Also\n--------\n\n:class:`BoundarySpec`\n    Specifies boundary conditions on each side of the domain and along each dimension.\n\n:class:`PML`\n    A standard PML along a single dimension.\n\n**Notebooks**\n    * `Setting up boundary conditions <../../notebooks/BoundaryConditions.html>`_\n    * `Multilevel blazed diffraction grating <../../notebooks/GratingEfficiency.html>`_",
      "type": "object",
      "properties": {
        "plus": {
          "title": "Plus BC",
          "description": "Boundary condition on the plus side along a dimension.",
          "default": {
            "name": null,
            "type": "PML",
            "num_layers": 12,
            "parameters": {
              "sigma_order": 3,
              "sigma_min": 0.0,
              "sigma_max": 1.5,
              "type": "PMLParams",
              "kappa_order": 3,
              "kappa_min": 1.0,
              "kappa_max": 3.0,
              "alpha_order": 1,
              "alpha_min": 0.0,
              "alpha_max": 0.0
            }
          },
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "Periodic": "#/definitions/Periodic",
              "PECBoundary": "#/definitions/PECBoundary",
              "PMCBoundary": "#/definitions/PMCBoundary",
              "PML": "#/definitions/PML",
              "StablePML": "#/definitions/StablePML",
              "Absorber": "#/definitions/Absorber",
              "BlochBoundary": "#/definitions/BlochBoundary"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/Periodic"
            },
            {
              "$ref": "#/definitions/PECBoundary"
            },
            {
              "$ref": "#/definitions/PMCBoundary"
            },
            {
              "$ref": "#/definitions/PML"
            },
            {
              "$ref": "#/definitions/StablePML"
            },
            {
              "$ref": "#/definitions/Absorber"
            },
            {
              "$ref": "#/definitions/BlochBoundary"
            }
          ]
        },
        "minus": {
          "title": "Minus BC",
          "description": "Boundary condition on the minus side along a dimension.",
          "default": {
            "name": null,
            "type": "PML",
            "num_layers": 12,
            "parameters": {
              "sigma_order": 3,
              "sigma_min": 0.0,
              "sigma_max": 1.5,
              "type": "PMLParams",
              "kappa_order": 3,
              "kappa_min": 1.0,
              "kappa_max": 3.0,
              "alpha_order": 1,
              "alpha_min": 0.0,
              "alpha_max": 0.0
            }
          },
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "Periodic": "#/definitions/Periodic",
              "PECBoundary": "#/definitions/PECBoundary",
              "PMCBoundary": "#/definitions/PMCBoundary",
              "PML": "#/definitions/PML",
              "StablePML": "#/definitions/StablePML",
              "Absorber": "#/definitions/Absorber",
              "BlochBoundary": "#/definitions/BlochBoundary"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/Periodic"
            },
            {
              "$ref": "#/definitions/PECBoundary"
            },
            {
              "$ref": "#/definitions/PMCBoundary"
            },
            {
              "$ref": "#/definitions/PML"
            },
            {
              "$ref": "#/definitions/StablePML"
            },
            {
              "$ref": "#/definitions/Absorber"
            },
            {
              "$ref": "#/definitions/BlochBoundary"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Boundary",
          "enum": [
            "Boundary"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "BoundarySpec": {
      "title": "BoundarySpec",
      "description": "Specifies boundary conditions on each side of the domain and along each dimension.\n\nParameters\n----------\nx : Boundary = Boundary(plus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)), minus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)), type='Boundary')\n    Boundary condition on the plus and minus sides along the x axis. If ``None``, periodic boundaries are applied. Default will change to PML in 2.0 so explicitly setting the boundaries is recommended.\ny : Boundary = Boundary(plus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)), minus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)), type='Boundary')\n    Boundary condition on the plus and minus sides along the y axis. If ``None``, periodic boundaries are applied. Default will change to PML in 2.0 so explicitly setting the boundaries is recommended.\nz : Boundary = Boundary(plus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)), minus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)), type='Boundary')\n    Boundary condition on the plus and minus sides along the z axis. If ``None``, periodic boundaries are applied. Default will change to PML in 2.0 so explicitly setting the boundaries is recommended.\n\nNotes\n-----\n\n    This :class:`BoundarySpec` object defines the boundary conditions applied on each of the 6 domain edges,\n    and is provided as an input to the simulation.\n\n    A :class:`BoundarySpec` consists of three :class:`Boundary` objects, each defining the boundaries on the plus\n    and minus side of each dimension. In most cases, one just wants to specify whether there are absorbing\n    :class:`PML` layers along any of the ``x``, ``y``, ``z`` dimensions. By default, ``tidy3d`` simulations have\n    :class:`PML` boundaries on all sides.\n\n    If we want to explicitly set the boundaries, we can use the :attr:`tidy3d.BoundarySpec.all_sides` method.\n    This can be used to set any type of boundary condition on all sides of the simulation. We can also set\n    :class:`PML` on specified sides only by calling the :attr:`tidy3d.BoundarySpec.pml` method, e.g. ``BoundarySpec.pml(\n    x=False, y=False, z=False)``. This will put :class:`PML` along the dimensions defined as ``True``,\n    and set periodic boundaries along the other dimensions.\n\n\nSee Also\n--------\n\n:class:`Boundary`\n    Boundary conditions at the minus and plus extents along a dimension.\n\n**Notebooks**\n    * `How to troubleshoot a diverged FDTD simulation <../../notebooks/DivergedFDTDSimulation.html>`_\n\n**Lectures**\n    * `Using FDTD to Compute a Transmission Spectrum <https://www.flexcompute.com/fdtd101/Lecture-2-Using-FDTD-to-Compute-a-Transmission-Spectrum/>`__",
      "type": "object",
      "properties": {
        "x": {
          "title": "Boundary condition along x.",
          "description": "Boundary condition on the plus and minus sides along the x axis. If ``None``, periodic boundaries are applied. Default will change to PML in 2.0 so explicitly setting the boundaries is recommended.",
          "default": {
            "plus": {
              "name": null,
              "type": "PML",
              "num_layers": 12,
              "parameters": {
                "sigma_order": 3,
                "sigma_min": 0.0,
                "sigma_max": 1.5,
                "type": "PMLParams",
                "kappa_order": 3,
                "kappa_min": 1.0,
                "kappa_max": 3.0,
                "alpha_order": 1,
                "alpha_min": 0.0,
                "alpha_max": 0.0
              }
            },
            "minus": {
              "name": null,
              "type": "PML",
              "num_layers": 12,
              "parameters": {
                "sigma_order": 3,
                "sigma_min": 0.0,
                "sigma_max": 1.5,
                "type": "PMLParams",
                "kappa_order": 3,
                "kappa_min": 1.0,
                "kappa_max": 3.0,
                "alpha_order": 1,
                "alpha_min": 0.0,
                "alpha_max": 0.0
              }
            },
            "type": "Boundary"
          },
          "allOf": [
            {
              "$ref": "#/definitions/Boundary"
            }
          ]
        },
        "y": {
          "title": "Boundary condition along y.",
          "description": "Boundary condition on the plus and minus sides along the y axis. If ``None``, periodic boundaries are applied. Default will change to PML in 2.0 so explicitly setting the boundaries is recommended.",
          "default": {
            "plus": {
              "name": null,
              "type": "PML",
              "num_layers": 12,
              "parameters": {
                "sigma_order": 3,
                "sigma_min": 0.0,
                "sigma_max": 1.5,
                "type": "PMLParams",
                "kappa_order": 3,
                "kappa_min": 1.0,
                "kappa_max": 3.0,
                "alpha_order": 1,
                "alpha_min": 0.0,
                "alpha_max": 0.0
              }
            },
            "minus": {
              "name": null,
              "type": "PML",
              "num_layers": 12,
              "parameters": {
                "sigma_order": 3,
                "sigma_min": 0.0,
                "sigma_max": 1.5,
                "type": "PMLParams",
                "kappa_order": 3,
                "kappa_min": 1.0,
                "kappa_max": 3.0,
                "alpha_order": 1,
                "alpha_min": 0.0,
                "alpha_max": 0.0
              }
            },
            "type": "Boundary"
          },
          "allOf": [
            {
              "$ref": "#/definitions/Boundary"
            }
          ]
        },
        "z": {
          "title": "Boundary condition along z.",
          "description": "Boundary condition on the plus and minus sides along the z axis. If ``None``, periodic boundaries are applied. Default will change to PML in 2.0 so explicitly setting the boundaries is recommended.",
          "default": {
            "plus": {
              "name": null,
              "type": "PML",
              "num_layers": 12,
              "parameters": {
                "sigma_order": 3,
                "sigma_min": 0.0,
                "sigma_max": 1.5,
                "type": "PMLParams",
                "kappa_order": 3,
                "kappa_min": 1.0,
                "kappa_max": 3.0,
                "alpha_order": 1,
                "alpha_min": 0.0,
                "alpha_max": 0.0
              }
            },
            "minus": {
              "name": null,
              "type": "PML",
              "num_layers": 12,
              "parameters": {
                "sigma_order": 3,
                "sigma_min": 0.0,
                "sigma_max": 1.5,
                "type": "PMLParams",
                "kappa_order": 3,
                "kappa_min": 1.0,
                "kappa_max": 3.0,
                "alpha_order": 1,
                "alpha_min": 0.0,
                "alpha_max": 0.0
              }
            },
            "type": "Boundary"
          },
          "allOf": [
            {
              "$ref": "#/definitions/Boundary"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "BoundarySpec",
          "enum": [
            "BoundarySpec"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "ApodizationSpec": {
      "title": "ApodizationSpec",
      "description": "Stores specifications for the apodizaton of frequency-domain monitors.\n\nParameters\n----------\nstart : Optional[NonNegativeFloat] = None\n    [units = sec].  Defines the time at which the start apodization ends.\nend : Optional[NonNegativeFloat] = None\n    [units = sec].  Defines the time at which the end apodization begins.\nwidth : Optional[PositiveFloat] = None\n    [units = sec].  Characteristic decay length of the apodization function.\n\nExample\n-------\n>>> apod_spec = ApodizationSpec(start=1, end=2, width=0.5)",
      "type": "object",
      "properties": {
        "start": {
          "title": "Start Interval",
          "description": "Defines the time at which the start apodization ends.",
          "units": "sec",
          "minimum": 0,
          "type": "number"
        },
        "end": {
          "title": "End Interval",
          "description": "Defines the time at which the end apodization begins.",
          "units": "sec",
          "minimum": 0,
          "type": "number"
        },
        "width": {
          "title": "Apodization Width",
          "description": "Characteristic decay length of the apodization function.",
          "units": "sec",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "type": {
          "title": "Type",
          "default": "ApodizationSpec",
          "enum": [
            "ApodizationSpec"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "FieldMonitor": {
      "title": "FieldMonitor",
      "description": ":class:`Monitor` that records electromagnetic fields in the frequency domain.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\ninterval_space : Tuple[PositiveInt, PositiveInt, PositiveInt] = (1, 1, 1)\n    Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included.\ncolocate : bool = True\n    Toggle whether fields should be colocated to grid cell boundaries (i.e. primal grid nodes).\nfreqs : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\napodization : ApodizationSpec = ApodizationSpec(start=None, end=None, width=None, type='ApodizationSpec')\n    Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.\nfields : Tuple[Literal['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz'], ...] = ['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']\n    Collection of field components to store in the monitor.\n\nNotes\n-----\n\n    :class:`FieldMonitor` objects operate by running a discrete Fourier transform of the fields at a given set of\n    frequencies to perform the calculation \u201cin-place\u201d with the time stepping. :class:`FieldMonitor`  objects are\n    useful for investigating the steady-state field distribution in 2D and 3D regions of the simulation.\n\nExample\n-------\n>>> monitor = FieldMonitor(\n...     center=(1,2,3),\n...     size=(2,2,2),\n...     fields=['Hx'],\n...     freqs=[250e12, 300e12],\n...     name='steady_state_monitor',\n...     colocate=True)\n\n\nSee Also\n--------\n\n**Notebooks**\n\n* `Quickstart <../../notebooks/StartHere.html>`_: Usage in a basic simulation flow.\n\n**Lectures**\n\n* `Introduction to FDTD Simulation <https://www.flexcompute.com/fdtd101/Lecture-1-Introduction-to-FDTD-Simulation/#presentation-slides>`_: Usage in a basic simulation flow.",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "FieldMonitor",
          "enum": [
            "FieldMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "interval_space": {
          "title": "Spatial Interval",
          "description": "Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included.",
          "default": [
            1,
            1,
            1
          ],
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "integer",
              "exclusiveMinimum": 0
            },
            {
              "type": "integer",
              "exclusiveMinimum": 0
            },
            {
              "type": "integer",
              "exclusiveMinimum": 0
            }
          ]
        },
        "colocate": {
          "title": "Colocate Fields",
          "description": "Toggle whether fields should be colocated to grid cell boundaries (i.e. primal grid nodes).",
          "default": true,
          "type": "boolean"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        },
        "apodization": {
          "title": "Apodization Specification",
          "description": "Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.",
          "default": {
            "start": null,
            "end": null,
            "width": null,
            "type": "ApodizationSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ApodizationSpec"
            }
          ]
        },
        "fields": {
          "title": "Field Components",
          "description": "Collection of field components to store in the monitor.",
          "default": [
            "Ex",
            "Ey",
            "Ez",
            "Hx",
            "Hy",
            "Hz"
          ],
          "type": "array",
          "items": {
            "enum": [
              "Ex",
              "Ey",
              "Ez",
              "Hx",
              "Hy",
              "Hz"
            ],
            "type": "string"
          }
        }
      },
      "required": [
        "size",
        "name",
        "freqs"
      ],
      "additionalProperties": false
    },
    "FieldTimeMonitor": {
      "title": "FieldTimeMonitor",
      "description": ":class:`Monitor` that records electromagnetic fields in the time domain.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\ninterval_space : Tuple[PositiveInt, PositiveInt, PositiveInt] = (1, 1, 1)\n    Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included.\ncolocate : bool = True\n    Toggle whether fields should be colocated to grid cell boundaries (i.e. primal grid nodes).\nstart : NonNegativeFloat = 0.0\n    [units = sec].  Time at which to start monitor recording.\nstop : Optional[NonNegativeFloat] = None\n    [units = sec].  Time at which to stop monitor recording.  If not specified, record until end of simulation.\ninterval : Optional[PositiveInt] = None\n    Sampling rate of the monitor: number of time steps between each measurement. Set ``interval`` to 1 for the highest possible resolution in time. Higher integer values downsample the data by measuring every ``interval`` time steps. This can be useful for reducing data storage as needed by the application.\nfields : Tuple[Literal['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz'], ...] = ['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']\n    Collection of field components to store in the monitor.\n\nNotes\n-----\n\n    :class:`FieldTimeMonitor` objects are best used to monitor the time dependence of the fields at a single\n    point, but they can also be used to create \u201canimations\u201d of the field pattern evolution.\n\n    To create an animation, we need to capture the frames at different time instances of the simulation. This can\n    be done by using a :class:`FieldTimeMonitor`. Usually a FDTD simulation contains a large number of time steps\n    and grid points. Recording the field at every time step and grid point will result in a large dataset. For\n    the purpose of making animations, this is usually unnecessary.\n\n\nExample\n-------\n>>> monitor = FieldTimeMonitor(\n...     center=(1,2,3),\n...     size=(2,2,2),\n...     fields=['Hx'],\n...     start=1e-13,\n...     stop=5e-13,\n...     interval=2,\n...     colocate=True,\n...     name='movie_monitor')\n\n\nSee Also\n--------\n\n**Notebooks**\n    * `First walkthrough <../../notebooks/Simulation.html>`_: Usage in a basic simulation flow.\n    * `Creating FDTD animations <../../notebooks/AnimationTutorial.html>`_.",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "FieldTimeMonitor",
          "enum": [
            "FieldTimeMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "interval_space": {
          "title": "Spatial Interval",
          "description": "Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included.",
          "default": [
            1,
            1,
            1
          ],
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "integer",
              "exclusiveMinimum": 0
            },
            {
              "type": "integer",
              "exclusiveMinimum": 0
            },
            {
              "type": "integer",
              "exclusiveMinimum": 0
            }
          ]
        },
        "colocate": {
          "title": "Colocate Fields",
          "description": "Toggle whether fields should be colocated to grid cell boundaries (i.e. primal grid nodes).",
          "default": true,
          "type": "boolean"
        },
        "start": {
          "title": "Start Time",
          "description": "Time at which to start monitor recording.",
          "default": 0.0,
          "units": "sec",
          "minimum": 0,
          "type": "number"
        },
        "stop": {
          "title": "Stop Time",
          "description": "Time at which to stop monitor recording.  If not specified, record until end of simulation.",
          "units": "sec",
          "minimum": 0,
          "type": "number"
        },
        "interval": {
          "title": "Time Interval",
          "description": "Sampling rate of the monitor: number of time steps between each measurement. Set ``interval`` to 1 for the highest possible resolution in time. Higher integer values downsample the data by measuring every ``interval`` time steps. This can be useful for reducing data storage as needed by the application.",
          "exclusiveMinimum": 0,
          "type": "integer"
        },
        "fields": {
          "title": "Field Components",
          "description": "Collection of field components to store in the monitor.",
          "default": [
            "Ex",
            "Ey",
            "Ez",
            "Hx",
            "Hy",
            "Hz"
          ],
          "type": "array",
          "items": {
            "enum": [
              "Ex",
              "Ey",
              "Ez",
              "Hx",
              "Hy",
              "Hz"
            ],
            "type": "string"
          }
        }
      },
      "required": [
        "size",
        "name"
      ],
      "additionalProperties": false
    },
    "PermittivityMonitor": {
      "title": "PermittivityMonitor",
      "description": ":class:`Monitor` that records the diagonal components of the complex-valued relative\npermittivity tensor in the frequency domain. The recorded data has the same shape as a\n:class:`.FieldMonitor` of the same geometry: the permittivity values are saved at the\nYee grid locations, and can be interpolated to any point inside the monitor.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\ninterval_space : Tuple[PositiveInt, PositiveInt, PositiveInt] = (1, 1, 1)\n    Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included.\ncolocate : Literal[False] = False\n    Colocation turned off, since colocated permittivity values do not have a physical meaning - they do not correspond to the subpixel-averaged ones.\nfreqs : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\napodization : ApodizationSpec = ApodizationSpec(start=None, end=None, width=None, type='ApodizationSpec')\n    This field is ignored in this monitor.\n\nNotes\n-----\n\n    If 2D materials are present, then the permittivity values correspond to the\n    volumetric equivalent of the 2D materials.\n\n    .. TODO add links to relevant areas\n\nExample\n-------\n>>> monitor = PermittivityMonitor(\n...     center=(1,2,3),\n...     size=(2,2,2),\n...     freqs=[250e12, 300e12],\n...     name='eps_monitor')",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "PermittivityMonitor",
          "enum": [
            "PermittivityMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "interval_space": {
          "title": "Spatial Interval",
          "description": "Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included.",
          "default": [
            1,
            1,
            1
          ],
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "integer",
              "exclusiveMinimum": 0
            },
            {
              "type": "integer",
              "exclusiveMinimum": 0
            },
            {
              "type": "integer",
              "exclusiveMinimum": 0
            }
          ]
        },
        "colocate": {
          "title": "Colocate Fields",
          "description": "Colocation turned off, since colocated permittivity values do not have a physical meaning - they do not correspond to the subpixel-averaged ones.",
          "default": false,
          "enum": [
            false
          ],
          "type": "boolean"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        },
        "apodization": {
          "title": "Apodization Specification",
          "description": "This field is ignored in this monitor.",
          "default": {
            "start": null,
            "end": null,
            "width": null,
            "type": "ApodizationSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ApodizationSpec"
            }
          ]
        }
      },
      "required": [
        "size",
        "name",
        "freqs"
      ],
      "additionalProperties": false
    },
    "FluxMonitor": {
      "title": "FluxMonitor",
      "description": ":class:`Monitor` that records power flux in the frequency domain.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\ninterval_space : Tuple[Literal[1], Literal[1], Literal[1]] = (1, 1, 1)\n    Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Not all monitors support values different from 1.\ncolocate : Literal[True] = True\n    Defines whether fields are colocated to grid cell boundaries (i.e. to the primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors and is hard-coded for other monitors depending on their specific function.\nfreqs : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\napodization : ApodizationSpec = ApodizationSpec(start=None, end=None, width=None, type='ApodizationSpec')\n    Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.\nnormal_dir : Optional[Literal['+', '-']] = None\n    Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.\nexclude_surfaces : Optional[Tuple[Literal['x-', 'x+', 'y-', 'y+', 'z-', 'z+'], ...]] = None\n    Surfaces to exclude in the integration, if a volume monitor.\n\nNotes\n-----\n\n    If the monitor geometry is a 2D box, the total flux through this plane is returned, with a\n    positive sign corresponding to power flow in the positive direction along the axis normal to\n    the plane. If the geometry is a 3D box, the total power coming out of the box is returned by\n    integrating the flux over all box surfaces (except the ones defined in ``exclude_surfaces``).\n\nExample\n-------\n>>> monitor = FluxMonitor(\n...     center=(1,2,3),\n...     size=(2,2,0),\n...     freqs=[200e12, 210e12],\n...     name='flux_monitor')\n\nSee Also\n--------\n\n**Notebooks**\n\n* `THz integrated demultiplexer/filter based on a ring resonator <../../notebooks/THzDemultiplexerFilter.html>`_",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "FluxMonitor",
          "enum": [
            "FluxMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "interval_space": {
          "title": "Spatial Interval",
          "description": "Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Not all monitors support values different from 1.",
          "default": [
            1,
            1,
            1
          ],
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "enum": [
                1
              ],
              "type": "integer"
            },
            {
              "enum": [
                1
              ],
              "type": "integer"
            },
            {
              "enum": [
                1
              ],
              "type": "integer"
            }
          ]
        },
        "colocate": {
          "title": "Colocate Fields",
          "description": "Defines whether fields are colocated to grid cell boundaries (i.e. to the primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors and is hard-coded for other monitors depending on their specific function.",
          "default": true,
          "enum": [
            true
          ],
          "type": "boolean"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        },
        "apodization": {
          "title": "Apodization Specification",
          "description": "Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.",
          "default": {
            "start": null,
            "end": null,
            "width": null,
            "type": "ApodizationSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ApodizationSpec"
            }
          ]
        },
        "normal_dir": {
          "title": "Normal Vector Orientation",
          "description": "Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "exclude_surfaces": {
          "title": "Excluded Surfaces",
          "description": "Surfaces to exclude in the integration, if a volume monitor.",
          "type": "array",
          "items": {
            "enum": [
              "x-",
              "x+",
              "y-",
              "y+",
              "z-",
              "z+"
            ],
            "type": "string"
          }
        }
      },
      "required": [
        "size",
        "name",
        "freqs"
      ],
      "additionalProperties": false
    },
    "FluxTimeMonitor": {
      "title": "FluxTimeMonitor",
      "description": ":class:`Monitor` that records power flux in the time domain.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\ninterval_space : Tuple[Literal[1], Literal[1], Literal[1]] = (1, 1, 1)\n    Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Not all monitors support values different from 1.\ncolocate : Literal[True] = True\n    Defines whether fields are colocated to grid cell boundaries (i.e. to the primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors and is hard-coded for other monitors depending on their specific function.\nstart : NonNegativeFloat = 0.0\n    [units = sec].  Time at which to start monitor recording.\nstop : Optional[NonNegativeFloat] = None\n    [units = sec].  Time at which to stop monitor recording.  If not specified, record until end of simulation.\ninterval : Optional[PositiveInt] = None\n    Sampling rate of the monitor: number of time steps between each measurement. Set ``interval`` to 1 for the highest possible resolution in time. Higher integer values downsample the data by measuring every ``interval`` time steps. This can be useful for reducing data storage as needed by the application.\nnormal_dir : Optional[Literal['+', '-']] = None\n    Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.\nexclude_surfaces : Optional[Tuple[Literal['x-', 'x+', 'y-', 'y+', 'z-', 'z+'], ...]] = None\n    Surfaces to exclude in the integration, if a volume monitor.\n\nNotes\n-----\n\n    If the monitor geometry is a 2D box, the total flux through this plane is returned, with a\n    positive sign corresponding to power flow in the positive direction along the axis normal to\n    the plane. If the geometry is a 3D box, the total power coming out of the box is returned by\n    integrating the flux over all box surfaces (except the ones defined in ``exclude_surfaces``).\n\nExample\n-------\n>>> monitor = FluxTimeMonitor(\n...     center=(1,2,3),\n...     size=(2,2,0),\n...     start=1e-13,\n...     stop=5e-13,\n...     interval=2,\n...     name='flux_vs_time')",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "FluxTimeMonitor",
          "enum": [
            "FluxTimeMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "interval_space": {
          "title": "Spatial Interval",
          "description": "Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Not all monitors support values different from 1.",
          "default": [
            1,
            1,
            1
          ],
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "enum": [
                1
              ],
              "type": "integer"
            },
            {
              "enum": [
                1
              ],
              "type": "integer"
            },
            {
              "enum": [
                1
              ],
              "type": "integer"
            }
          ]
        },
        "colocate": {
          "title": "Colocate Fields",
          "description": "Defines whether fields are colocated to grid cell boundaries (i.e. to the primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors and is hard-coded for other monitors depending on their specific function.",
          "default": true,
          "enum": [
            true
          ],
          "type": "boolean"
        },
        "start": {
          "title": "Start Time",
          "description": "Time at which to start monitor recording.",
          "default": 0.0,
          "units": "sec",
          "minimum": 0,
          "type": "number"
        },
        "stop": {
          "title": "Stop Time",
          "description": "Time at which to stop monitor recording.  If not specified, record until end of simulation.",
          "units": "sec",
          "minimum": 0,
          "type": "number"
        },
        "interval": {
          "title": "Time Interval",
          "description": "Sampling rate of the monitor: number of time steps between each measurement. Set ``interval`` to 1 for the highest possible resolution in time. Higher integer values downsample the data by measuring every ``interval`` time steps. This can be useful for reducing data storage as needed by the application.",
          "exclusiveMinimum": 0,
          "type": "integer"
        },
        "normal_dir": {
          "title": "Normal Vector Orientation",
          "description": "Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "exclude_surfaces": {
          "title": "Excluded Surfaces",
          "description": "Surfaces to exclude in the integration, if a volume monitor.",
          "type": "array",
          "items": {
            "enum": [
              "x-",
              "x+",
              "y-",
              "y+",
              "z-",
              "z+"
            ],
            "type": "string"
          }
        }
      },
      "required": [
        "size",
        "name"
      ],
      "additionalProperties": false
    },
    "ModeMonitor": {
      "title": "ModeMonitor",
      "description": ":class:`Monitor` that records amplitudes from modal decomposition of fields on plane.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\ninterval_space : Tuple[Literal[1], Literal[1], Literal[1]] = (1, 1, 1)\n    Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Not all monitors support values different from 1.\ncolocate : Literal[False] = False\n    Defines whether fields are colocated to grid cell boundaries (i.e. to the primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors and is hard-coded for other monitors depending on their specific function.\nfreqs : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\napodization : ApodizationSpec = ApodizationSpec(start=None, end=None, width=None, type='ApodizationSpec')\n    Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.\nmode_spec : ModeSpec\n    Parameters to feed to mode solver which determine modes measured by monitor.\nstore_fields_direction : Optional[Literal['+', '-']] = None\n    Propagation direction for the mode field profiles stored from mode solving.\n\nNotes\n------\n\n    The fields recorded by frequency monitors (and hence also mode monitors) are automatically\n    normalized by the power amplitude spectrum of the source. For multiple sources, the user can\n    select which source to use for the normalization too.\n\n    We can also use the mode amplitudes recorded in the mode monitor to reveal the decomposition\n    of the radiated power into forward- and backward-propagating modes, respectively.\n\n    .. TODO give an example of how to extract the data from this mode.\n\n    .. TODO add derivation in the notebook.\n\n    .. TODO add link to method\n\n    .. TODO add links to notebooks correspondingly\n\nExample\n-------\n>>> mode_spec = ModeSpec(num_modes=3)\n>>> monitor = ModeMonitor(\n...     center=(1,2,3),\n...     size=(2,2,0),\n...     freqs=[200e12, 210e12],\n...     mode_spec=mode_spec,\n...     name='mode_monitor')\n\nSee Also\n--------\n\n**Notebooks**:\n    * `ModalSourcesMonitors <../../notebooks/ModalSourcesMonitors.html>`_",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "ModeMonitor",
          "enum": [
            "ModeMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "interval_space": {
          "title": "Spatial Interval",
          "description": "Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Not all monitors support values different from 1.",
          "default": [
            1,
            1,
            1
          ],
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "enum": [
                1
              ],
              "type": "integer"
            },
            {
              "enum": [
                1
              ],
              "type": "integer"
            },
            {
              "enum": [
                1
              ],
              "type": "integer"
            }
          ]
        },
        "colocate": {
          "title": "Colocate Fields",
          "description": "Defines whether fields are colocated to grid cell boundaries (i.e. to the primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors and is hard-coded for other monitors depending on their specific function.",
          "default": false,
          "enum": [
            false
          ],
          "type": "boolean"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        },
        "apodization": {
          "title": "Apodization Specification",
          "description": "Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.",
          "default": {
            "start": null,
            "end": null,
            "width": null,
            "type": "ApodizationSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ApodizationSpec"
            }
          ]
        },
        "mode_spec": {
          "title": "Mode Specification",
          "description": "Parameters to feed to mode solver which determine modes measured by monitor.",
          "allOf": [
            {
              "$ref": "#/definitions/ModeSpec"
            }
          ]
        },
        "store_fields_direction": {
          "title": "Store Fields",
          "description": "Propagation direction for the mode field profiles stored from mode solving.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        }
      },
      "required": [
        "size",
        "name",
        "freqs",
        "mode_spec"
      ],
      "additionalProperties": false
    },
    "ModeSolverMonitor": {
      "title": "ModeSolverMonitor",
      "description": ":class:`Monitor` that stores the mode field profiles returned by the mode solver in the\nmonitor plane.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\ninterval_space : Tuple[Literal[1], Literal[1], Literal[1]] = (1, 1, 1)\n    Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Not all monitors support values different from 1.\ncolocate : bool = True\n    Toggle whether fields should be colocated to grid cell boundaries (i.e. primal grid nodes).\nfreqs : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\napodization : ApodizationSpec = ApodizationSpec(start=None, end=None, width=None, type='ApodizationSpec')\n    Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.\nmode_spec : ModeSpec\n    Parameters to feed to mode solver which determine modes measured by monitor.\nstore_fields_direction : Optional[Literal['+', '-']] = None\n    Propagation direction for the mode field profiles stored from mode solving.\ndirection : Literal['+', '-'] = +\n    Direction of waveguide mode propagation along the axis defined by its normal dimension.\n\nExample\n-------\n>>> mode_spec = ModeSpec(num_modes=3)\n>>> monitor = ModeSolverMonitor(\n...     center=(1,2,3),\n...     size=(2,2,0),\n...     freqs=[200e12, 210e12],\n...     mode_spec=mode_spec,\n...     name='mode_monitor')",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "ModeSolverMonitor",
          "enum": [
            "ModeSolverMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "interval_space": {
          "title": "Spatial Interval",
          "description": "Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Not all monitors support values different from 1.",
          "default": [
            1,
            1,
            1
          ],
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "enum": [
                1
              ],
              "type": "integer"
            },
            {
              "enum": [
                1
              ],
              "type": "integer"
            },
            {
              "enum": [
                1
              ],
              "type": "integer"
            }
          ]
        },
        "colocate": {
          "title": "Colocate Fields",
          "description": "Toggle whether fields should be colocated to grid cell boundaries (i.e. primal grid nodes).",
          "default": true,
          "type": "boolean"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        },
        "apodization": {
          "title": "Apodization Specification",
          "description": "Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.",
          "default": {
            "start": null,
            "end": null,
            "width": null,
            "type": "ApodizationSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ApodizationSpec"
            }
          ]
        },
        "mode_spec": {
          "title": "Mode Specification",
          "description": "Parameters to feed to mode solver which determine modes measured by monitor.",
          "allOf": [
            {
              "$ref": "#/definitions/ModeSpec"
            }
          ]
        },
        "store_fields_direction": {
          "title": "Store Fields",
          "description": "Propagation direction for the mode field profiles stored from mode solving.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "direction": {
          "title": "Propagation Direction",
          "description": "Direction of waveguide mode propagation along the axis defined by its normal dimension.",
          "default": "+",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        }
      },
      "required": [
        "size",
        "name",
        "freqs",
        "mode_spec"
      ],
      "additionalProperties": false
    },
    "FieldProjectionAngleMonitor": {
      "title": "FieldProjectionAngleMonitor",
      "description": ":class:`Monitor` that samples electromagnetic near fields in the frequency domain\nand projects them at given observation angles.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\ninterval_space : Tuple[PositiveInt, PositiveInt, PositiveInt] = (1, 1, 1)\n    Number of grid step intervals at which near fields are recorded for projection to the far field, along each direction. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Using values greater than 1 can help speed up server-side far field projections with minimal accuracy loss, especially in cases where it is necessary for the grid resolution to be high for the FDTD simulation, but such a high resolution is unnecessary for the purpose of projecting the recorded near fields to the far field.\ncolocate : Literal[True] = True\n    Defines whether fields are colocated to grid cell boundaries (i.e. to the primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors and is hard-coded for other monitors depending on their specific function.\nfreqs : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\napodization : ApodizationSpec = ApodizationSpec(start=None, end=None, width=None, type='ApodizationSpec')\n    Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.\nnormal_dir : Optional[Literal['+', '-']] = None\n    Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.\nexclude_surfaces : Optional[Tuple[Literal['x-', 'x+', 'y-', 'y+', 'z-', 'z+'], ...]] = None\n    Surfaces to exclude in the integration, if a volume monitor.\ncustom_origin : Optional[Tuple[float, float, float]] = None\n    [units = um].  Local origin used for defining observation points. If ``None``, uses the monitor's center.\nfar_field_approx : bool = True\n    Whether to enable the far field approximation when projecting fields. If ``True``, terms that decay as O(1/r^2) are ignored, as are the radial components of fields. Typically, this should be set to ``True`` only when the projection distance is much larger than the size of the device being modeled, and the projected points are in the far field of the device.\nwindow_size : Tuple[NonNegativeFloat, NonNegativeFloat] = (0, 0)\n    Size of the transition region of the windowing function used to ensure that the recorded near fields decay to zero near the edges of the monitor. The two components refer to the two tangential directions associated with each surface. For surfaces with the normal along ``x``, the two components are (``y``, ``z``). For surfaces with the normal along ``y``, the two components are (``x``, ``z``). For surfaces with the normal along ``z``, the two components are (``x``, ``y``). Each value must be between 0 and 1, inclusive, and denotes the size of the transition region over which fields are scaled to less than a thousandth of the original amplitude, relative to half the size of the monitor in that direction. A value of 0 turns windowing off in that direction, while a value of 1 indicates that the window will be applied to the entire monitor in that direction. This field is applicable for surface monitors only, and otherwise must remain (0, 0).\nmedium : Union[Medium, AnisotropicMedium, PECMedium, PoleResidue, Sellmeier, Lorentz, Debye, Drude, FullyAnisotropicMedium, CustomMedium, CustomPoleResidue, CustomSellmeier, CustomLorentz, CustomDebye, CustomDrude, CustomAnisotropicMedium, PerturbationMedium, PerturbationPoleResidue, Medium2D] = None\n    Medium through which to project fields. Generally, the fields should be projected through the same medium as the one in which this monitor is placed, and this is the default behavior when ``medium=None``. A custom ``medium`` can be useful in some situations for advanced users, but we recommend trying to avoid using a non-default ``medium``.\nproj_distance : float = 1000000.0\n    [units = um].  Radial distance of the projection points from ``local_origin``.\ntheta : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    [units = rad].  Polar angles with respect to the global z axis, relative to the location of ``local_origin``, at which to project fields.\nphi : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    [units = rad].  Azimuth angles with respect to the global z axis, relative to the location of ``local_origin``, at which to project fields.\n\nNotes\n-----\n\n    .. TODO this needs an illustration\n\n    **Parameters Caveats**\n\n    The :attr:`center` and :attr:`size` parameters define\n    where the monitor will be placed in order to record near fields, typically very close\n    to the structure of interest. The near fields are then projected\n    to far-field locations defined by :attr:`phi`, :attr:`theta`, and :attr:`proj_distance`, relative\n    to the :attr:`custom_origin`.\n\n    **Usage Caveats**\n\n    The field projections make use of the analytical homogeneous medium Green\u2019s function, which assumes that the\n    fields are propagating in a homogeneous medium. Therefore, one should use :class:`PML` / :class:`Absorber` as\n    boundary conditions in the part of the domain where fields are projected.\n\n    .. TODO why not add equation here\n\n    Server-side field projections will add to the monetary cost of the simulation. However, typically the far field\n    projections have a very small computation cost compared to the FDTD simulation itself, so the increase in monetary\n    cost should be negligibly small in most cases. For applications where the monitor is an open surface rather than a box that\n    encloses the device, it is advisable to pick the size of the monitor such that the\n    recorded near fields decay to negligible values near the edges of the monitor.\n\n    .. TODO TYPO FIX o that the approximations are not used, and the projection is accurate even just a few wavelengths away from the near field locations.\n\n    By default, if no :attr:`proj_distance` was provided, the fields are projected to a distance of 1m.\n\n    **Server-side field projection Application**\n\n    Provide the :class:`FieldProjectionAngleMonitor` monitor as an input to the\n    :class:`Simulation` object as one of its monitors. Now, we no longer need to provide a separate near-field\n    :class:`FieldMonitor` - the near fields will automatically be recorded based on the size and location of the\n    ``FieldProjectionAngleMonitor``. Note also that in some cases, the server-side computations may be slightly\n    more accurate than client-side ones, because on the server, the near fields are not downsampled at all.\n\n    We can re-project the already-computed far fields to a different distance away from the structure - we\n    neither need to run another simulation nor re-run the :class:`FieldProjector`.\n\n    **Far-Field Approximation Selection**\n\n    .. TODO unsure if add on params?\n\n    If the distance between the near and far field locations is\n    much larger than the size of the device, one can typically set :attr:`far_field_approx` to\n    ``True``, which will make use of the far-field approximation to speed up calculations.\n    If the projection distance is comparable to the size of the device, we recommend setting\n    :attr:`far_field_approx` to ``False``.\n\n    .. image:: ../../notebooks/img/n2f_diagram.png\n\n    .. TODO Fix that image so remove right irrelevant side\n\n    When selected, it is assumed that:\n\n    -   The fields are measured at a distance much greater than the size of our simulation in the transverse\n        direction.\n    -   The geometric approximations imply that any quantity whose magnitude drops off as\n        :math:`\\frac{1}{r^2}` or faster is ignored.\n\n    The advantages of these approximations are:\n\n    *   The projections are computed relatively fast.\n    *   The projections are cast in a simple mathematical form.\n        which allows re-projecting the fields to different distance without the need to re-run a simulation or to\n        re-run the :class:`FieldProjector`.\n\n    In cases where we may want to project to intermediate distances where the far field approximation is no\n    longer valid, simply include the class definition parameter :attr:`far_field_approx` to ``False`` in the\n    ``FieldProjectionAngleMonitor`` instantiation. The resulting computations will be a bit slower,\n    but the results will be significantly more accurate.\n\n    .. TODO include here inherited methods.\n\nExample\n-------\n>>> monitor = FieldProjectionAngleMonitor(\n...     center=(1,2,3),\n...     size=(2,2,2),\n...     freqs=[250e12, 300e12],\n...     name='n2f_monitor',\n...     custom_origin=(1,2,3),\n...     phi=[0, np.pi/2],\n...     theta=np.linspace(-np.pi/2, np.pi/2, 100),\n...     far_field_approx=True,\n...     )\n\nSee Also\n--------\n\n**Notebooks**:\n\n    * `Performing near field to far field projections <../../notebooks/FieldProjections.html>`_\n    * `Field projection for a zone plate <../../notebooks/ZonePlateFieldProjection.html>`_: Realistic case study further demonstrating the accuracy of the field projections.\n    * `Metalens in the visible frequency range <../../notebooks/Metalens.html>`_: Realistic case study further demonstrating the accuracy of the field projections.\n    * `Multilevel blazed diffraction grating <../../notebooks/GratingEfficiency.html>`_: For far field projections in the context of perdiodic boundary conditions.",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "FieldProjectionAngleMonitor",
          "enum": [
            "FieldProjectionAngleMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "interval_space": {
          "title": "Spatial Interval",
          "description": "Number of grid step intervals at which near fields are recorded for projection to the far field, along each direction. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Using values greater than 1 can help speed up server-side far field projections with minimal accuracy loss, especially in cases where it is necessary for the grid resolution to be high for the FDTD simulation, but such a high resolution is unnecessary for the purpose of projecting the recorded near fields to the far field.",
          "default": [
            1,
            1,
            1
          ],
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "integer",
              "exclusiveMinimum": 0
            },
            {
              "type": "integer",
              "exclusiveMinimum": 0
            },
            {
              "type": "integer",
              "exclusiveMinimum": 0
            }
          ]
        },
        "colocate": {
          "title": "Colocate Fields",
          "description": "Defines whether fields are colocated to grid cell boundaries (i.e. to the primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors and is hard-coded for other monitors depending on their specific function.",
          "default": true,
          "enum": [
            true
          ],
          "type": "boolean"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        },
        "apodization": {
          "title": "Apodization Specification",
          "description": "Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.",
          "default": {
            "start": null,
            "end": null,
            "width": null,
            "type": "ApodizationSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ApodizationSpec"
            }
          ]
        },
        "normal_dir": {
          "title": "Normal Vector Orientation",
          "description": "Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "exclude_surfaces": {
          "title": "Excluded Surfaces",
          "description": "Surfaces to exclude in the integration, if a volume monitor.",
          "type": "array",
          "items": {
            "enum": [
              "x-",
              "x+",
              "y-",
              "y+",
              "z-",
              "z+"
            ],
            "type": "string"
          }
        },
        "custom_origin": {
          "title": "Local Origin",
          "description": "Local origin used for defining observation points. If ``None``, uses the monitor's center.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "far_field_approx": {
          "title": "Far Field Approximation",
          "description": "Whether to enable the far field approximation when projecting fields. If ``True``, terms that decay as O(1/r^2) are ignored, as are the radial components of fields. Typically, this should be set to ``True`` only when the projection distance is much larger than the size of the device being modeled, and the projected points are in the far field of the device.",
          "default": true,
          "type": "boolean"
        },
        "window_size": {
          "title": "Spatial filtering window size",
          "description": "Size of the transition region of the windowing function used to ensure that the recorded near fields decay to zero near the edges of the monitor. The two components refer to the two tangential directions associated with each surface. For surfaces with the normal along ``x``, the two components are (``y``, ``z``). For surfaces with the normal along ``y``, the two components are (``x``, ``z``). For surfaces with the normal along ``z``, the two components are (``x``, ``y``). Each value must be between 0 and 1, inclusive, and denotes the size of the transition region over which fields are scaled to less than a thousandth of the original amplitude, relative to half the size of the monitor in that direction. A value of 0 turns windowing off in that direction, while a value of 1 indicates that the window will be applied to the entire monitor in that direction. This field is applicable for surface monitors only, and otherwise must remain (0, 0).",
          "default": [
            0,
            0
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "medium": {
          "title": "Projection medium",
          "description": "Medium through which to project fields. Generally, the fields should be projected through the same medium as the one in which this monitor is placed, and this is the default behavior when ``medium=None``. A custom ``medium`` can be useful in some situations for advanced users, but we recommend trying to avoid using a non-default ``medium``.",
          "anyOf": [
            {
              "$ref": "#/definitions/Medium"
            },
            {
              "$ref": "#/definitions/AnisotropicMedium"
            },
            {
              "$ref": "#/definitions/PECMedium"
            },
            {
              "$ref": "#/definitions/PoleResidue"
            },
            {
              "$ref": "#/definitions/Sellmeier"
            },
            {
              "$ref": "#/definitions/Lorentz"
            },
            {
              "$ref": "#/definitions/Debye"
            },
            {
              "$ref": "#/definitions/Drude"
            },
            {
              "$ref": "#/definitions/FullyAnisotropicMedium"
            },
            {
              "$ref": "#/definitions/CustomMedium"
            },
            {
              "$ref": "#/definitions/CustomPoleResidue"
            },
            {
              "$ref": "#/definitions/CustomSellmeier"
            },
            {
              "$ref": "#/definitions/CustomLorentz"
            },
            {
              "$ref": "#/definitions/CustomDebye"
            },
            {
              "$ref": "#/definitions/CustomDrude"
            },
            {
              "$ref": "#/definitions/CustomAnisotropicMedium"
            },
            {
              "$ref": "#/definitions/PerturbationMedium"
            },
            {
              "$ref": "#/definitions/PerturbationPoleResidue"
            },
            {
              "$ref": "#/definitions/Medium2D"
            }
          ]
        },
        "proj_distance": {
          "title": "Projection Distance",
          "description": "Radial distance of the projection points from ``local_origin``.",
          "default": 1000000.0,
          "units": "um",
          "type": "number"
        },
        "theta": {
          "title": "Polar Angles",
          "description": "Polar angles with respect to the global z axis, relative to the location of ``local_origin``, at which to project fields.",
          "units": "rad",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        },
        "phi": {
          "title": "Azimuth Angles",
          "description": "Azimuth angles with respect to the global z axis, relative to the location of ``local_origin``, at which to project fields.",
          "units": "rad",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        }
      },
      "required": [
        "size",
        "name",
        "freqs",
        "theta",
        "phi"
      ],
      "additionalProperties": false
    },
    "FieldProjectionCartesianMonitor": {
      "title": "FieldProjectionCartesianMonitor",
      "description": ":class:`Monitor` that samples electromagnetic near fields in the frequency domain\nand projects them on a Cartesian observation plane.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\ninterval_space : Tuple[PositiveInt, PositiveInt, PositiveInt] = (1, 1, 1)\n    Number of grid step intervals at which near fields are recorded for projection to the far field, along each direction. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Using values greater than 1 can help speed up server-side far field projections with minimal accuracy loss, especially in cases where it is necessary for the grid resolution to be high for the FDTD simulation, but such a high resolution is unnecessary for the purpose of projecting the recorded near fields to the far field.\ncolocate : Literal[True] = True\n    Defines whether fields are colocated to grid cell boundaries (i.e. to the primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors and is hard-coded for other monitors depending on their specific function.\nfreqs : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\napodization : ApodizationSpec = ApodizationSpec(start=None, end=None, width=None, type='ApodizationSpec')\n    Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.\nnormal_dir : Optional[Literal['+', '-']] = None\n    Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.\nexclude_surfaces : Optional[Tuple[Literal['x-', 'x+', 'y-', 'y+', 'z-', 'z+'], ...]] = None\n    Surfaces to exclude in the integration, if a volume monitor.\ncustom_origin : Optional[Tuple[float, float, float]] = None\n    [units = um].  Local origin used for defining observation points. If ``None``, uses the monitor's center.\nfar_field_approx : bool = True\n    Whether to enable the far field approximation when projecting fields. If ``True``, terms that decay as O(1/r^2) are ignored, as are the radial components of fields. Typically, this should be set to ``True`` only when the projection distance is much larger than the size of the device being modeled, and the projected points are in the far field of the device.\nwindow_size : Tuple[NonNegativeFloat, NonNegativeFloat] = (0, 0)\n    Size of the transition region of the windowing function used to ensure that the recorded near fields decay to zero near the edges of the monitor. The two components refer to the two tangential directions associated with each surface. For surfaces with the normal along ``x``, the two components are (``y``, ``z``). For surfaces with the normal along ``y``, the two components are (``x``, ``z``). For surfaces with the normal along ``z``, the two components are (``x``, ``y``). Each value must be between 0 and 1, inclusive, and denotes the size of the transition region over which fields are scaled to less than a thousandth of the original amplitude, relative to half the size of the monitor in that direction. A value of 0 turns windowing off in that direction, while a value of 1 indicates that the window will be applied to the entire monitor in that direction. This field is applicable for surface monitors only, and otherwise must remain (0, 0).\nmedium : Union[Medium, AnisotropicMedium, PECMedium, PoleResidue, Sellmeier, Lorentz, Debye, Drude, FullyAnisotropicMedium, CustomMedium, CustomPoleResidue, CustomSellmeier, CustomLorentz, CustomDebye, CustomDrude, CustomAnisotropicMedium, PerturbationMedium, PerturbationPoleResidue, Medium2D] = None\n    Medium through which to project fields. Generally, the fields should be projected through the same medium as the one in which this monitor is placed, and this is the default behavior when ``medium=None``. A custom ``medium`` can be useful in some situations for advanced users, but we recommend trying to avoid using a non-default ``medium``.\nproj_axis : Literal[0, 1, 2]\n    Axis along which the observation plane is oriented.\nproj_distance : float = 1000000.0\n    [units = um].  Signed distance of the projection plane along ``proj_axis``. from the plane containing ``local_origin``.\nx : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    [units = um].  Local x observation coordinates w.r.t. ``local_origin`` and ``proj_axis``. When ``proj_axis`` is 0, this corresponds to the global y axis. When ``proj_axis`` is 1, this corresponds to the global x axis. When ``proj_axis`` is 2, this corresponds to the global x axis. \ny : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    [units = um].  Local y observation coordinates w.r.t. ``local_origin`` and ``proj_axis``. When ``proj_axis`` is 0, this corresponds to the global z axis. When ``proj_axis`` is 1, this corresponds to the global z axis. When ``proj_axis`` is 2, this corresponds to the global y axis. \n\nNotes\n-----\n\n    **Parameters Caveats**\n\n    The :attr:`center` and :attr:`size` fields define\n    where the monitor will be placed in order to record near fields, typically very close\n    to the structure of interest. The near fields are then projected\n    to far-field locations defined by :attr:`x`, :attr:`y`, and :attr:`proj_distance`, relative\n    to the :attr:`custom_origin`.\n\n    Here, :attr:`x` and :attr:`y`, correspond to a local coordinate system\n    where the local ``z`` axis is defined by :attr:`proj_axis`: which is the axis normal to this monitor.\n\n    **Far-Field Approximation Selection**\n\n    If the distance between the near and far field locations is much larger than the size of the\n    device, one can typically set :attr:`far_field_approx` to ``True``, which will make use of the\n    far-field approximation to speed up calculations. If the projection distance is comparable\n    to the size of the device, we recommend setting :attr:`far_field_approx` to ``False``,\n    so that the approximations are not used, and the projection is accurate even just a few\n    wavelengths away from the near field locations.\n\n    For applications where the monitor is an open surface rather than a box that\n    encloses the device, it is advisable to pick the size of the monitor such that the\n    recorded near fields decay to negligible values near the edges of the monitor.\n\n    .. image:: ../../notebooks/img/n2f_diagram.png\n\n    .. TODO unsure if add on params?\n\n    When selected, it is assumed that:\n\n    -   The fields are measured at a distance much greater than the size of our simulation in the transverse\n        direction.\n    -   The geometric approximations imply that any quantity whose magnitude drops off as\n        :math:`\\frac{1}{r^2}` or faster is ignored.\n\n    The advantages of these approximations are:\n\n    *   The projections are computed relatively fast.\n    *   The projections are cast in a simple mathematical form.\n        which allows re-projecting the fields to different distance without the need to re-run a simulation or to\n        re-run the :class:`FieldProjector`.\n\n\n    In cases where we may want to project to intermediate distances where the far field approximation is no\n    longer valid, simply include the class definition parameter ``far_field_approx=False`` in the\n    ``FieldProjectionCartesianMonitor`` instantiation. The resulting computations will be a bit slower,\n    but the results will be significantly more accurate.\n\n    .. TODO include this example\n\n    **Usage Caveats**\n\n    .. TODO I believe a little illustration here would be handy.\n\n    Since field projections rely on the surface equivalence principle, we have assumed that the tangential near\n    fields recorded on the near field monitor serve as equivalent sources which generate the correct far fields.\n    However, this requires that the field strength decays nearly to zero near the edges of the near-field\n    monitor, which may not always be the case. For example, if we had used a larger aperture compared to the full\n    simulation size in the transverse direction, we may expect a degradation in accuracy of the field\n    projections. Despite this limitation, the field projections are still remarkably accurate in realistic\n    scenarios. For realistic case studies further demonstrating the accuracy of the field projections,\n    see our metalens and zone plate case studies.\n\n    The field projections make use of the analytical homogeneous medium Green\u2019s function, which assumes that the fields\n    are propagating in a homogeneous medium. Therefore, one should use PMLs / absorbers as boundary conditions in the\n    part of the domain where fields are projected. For far field projections in the context of perdiodic boundary\n    conditions, see the diffraction efficiency example which demonstrates the use of a DiffractionMonitor.\n\n    Server-side field projections will add to the monetary cost of the simulation. However, typically the far field\n    projections have a very small computation cost compared to the FDTD simulation itself, so the increase in monetary\n    cost should be negligibly small in most cases.\n\nExample\n-------\n>>> monitor = FieldProjectionCartesianMonitor(\n...     center=(1,2,3),\n...     size=(2,2,2),\n...     freqs=[250e12, 300e12],\n...     name='n2f_monitor',\n...     custom_origin=(1,2,3),\n...     x=[-1, 0, 1],\n...     y=[-2, -1, 0, 1, 2],\n...     proj_axis=2,\n...     proj_distance=5,\n...     far_field_approx=True,\n...     )\n\nSee Also\n--------\n\n**Notebooks**:\n    * `Performing near field to far field projections <../../notebooks/FieldProjections.html>`_\n    * `Field projection for a zone plate <../../notebooks/ZonePlateFieldProjection.html>`_\n    * `Metalens in the visible frequency range <../../notebooks/Metalens.html>`_\n    * `Multilevel blazed diffraction grating <../../notebooks/GratingEfficiency.html>`_",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "FieldProjectionCartesianMonitor",
          "enum": [
            "FieldProjectionCartesianMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "interval_space": {
          "title": "Spatial Interval",
          "description": "Number of grid step intervals at which near fields are recorded for projection to the far field, along each direction. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Using values greater than 1 can help speed up server-side far field projections with minimal accuracy loss, especially in cases where it is necessary for the grid resolution to be high for the FDTD simulation, but such a high resolution is unnecessary for the purpose of projecting the recorded near fields to the far field.",
          "default": [
            1,
            1,
            1
          ],
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "integer",
              "exclusiveMinimum": 0
            },
            {
              "type": "integer",
              "exclusiveMinimum": 0
            },
            {
              "type": "integer",
              "exclusiveMinimum": 0
            }
          ]
        },
        "colocate": {
          "title": "Colocate Fields",
          "description": "Defines whether fields are colocated to grid cell boundaries (i.e. to the primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors and is hard-coded for other monitors depending on their specific function.",
          "default": true,
          "enum": [
            true
          ],
          "type": "boolean"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        },
        "apodization": {
          "title": "Apodization Specification",
          "description": "Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.",
          "default": {
            "start": null,
            "end": null,
            "width": null,
            "type": "ApodizationSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ApodizationSpec"
            }
          ]
        },
        "normal_dir": {
          "title": "Normal Vector Orientation",
          "description": "Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "exclude_surfaces": {
          "title": "Excluded Surfaces",
          "description": "Surfaces to exclude in the integration, if a volume monitor.",
          "type": "array",
          "items": {
            "enum": [
              "x-",
              "x+",
              "y-",
              "y+",
              "z-",
              "z+"
            ],
            "type": "string"
          }
        },
        "custom_origin": {
          "title": "Local Origin",
          "description": "Local origin used for defining observation points. If ``None``, uses the monitor's center.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "far_field_approx": {
          "title": "Far Field Approximation",
          "description": "Whether to enable the far field approximation when projecting fields. If ``True``, terms that decay as O(1/r^2) are ignored, as are the radial components of fields. Typically, this should be set to ``True`` only when the projection distance is much larger than the size of the device being modeled, and the projected points are in the far field of the device.",
          "default": true,
          "type": "boolean"
        },
        "window_size": {
          "title": "Spatial filtering window size",
          "description": "Size of the transition region of the windowing function used to ensure that the recorded near fields decay to zero near the edges of the monitor. The two components refer to the two tangential directions associated with each surface. For surfaces with the normal along ``x``, the two components are (``y``, ``z``). For surfaces with the normal along ``y``, the two components are (``x``, ``z``). For surfaces with the normal along ``z``, the two components are (``x``, ``y``). Each value must be between 0 and 1, inclusive, and denotes the size of the transition region over which fields are scaled to less than a thousandth of the original amplitude, relative to half the size of the monitor in that direction. A value of 0 turns windowing off in that direction, while a value of 1 indicates that the window will be applied to the entire monitor in that direction. This field is applicable for surface monitors only, and otherwise must remain (0, 0).",
          "default": [
            0,
            0
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "medium": {
          "title": "Projection medium",
          "description": "Medium through which to project fields. Generally, the fields should be projected through the same medium as the one in which this monitor is placed, and this is the default behavior when ``medium=None``. A custom ``medium`` can be useful in some situations for advanced users, but we recommend trying to avoid using a non-default ``medium``.",
          "anyOf": [
            {
              "$ref": "#/definitions/Medium"
            },
            {
              "$ref": "#/definitions/AnisotropicMedium"
            },
            {
              "$ref": "#/definitions/PECMedium"
            },
            {
              "$ref": "#/definitions/PoleResidue"
            },
            {
              "$ref": "#/definitions/Sellmeier"
            },
            {
              "$ref": "#/definitions/Lorentz"
            },
            {
              "$ref": "#/definitions/Debye"
            },
            {
              "$ref": "#/definitions/Drude"
            },
            {
              "$ref": "#/definitions/FullyAnisotropicMedium"
            },
            {
              "$ref": "#/definitions/CustomMedium"
            },
            {
              "$ref": "#/definitions/CustomPoleResidue"
            },
            {
              "$ref": "#/definitions/CustomSellmeier"
            },
            {
              "$ref": "#/definitions/CustomLorentz"
            },
            {
              "$ref": "#/definitions/CustomDebye"
            },
            {
              "$ref": "#/definitions/CustomDrude"
            },
            {
              "$ref": "#/definitions/CustomAnisotropicMedium"
            },
            {
              "$ref": "#/definitions/PerturbationMedium"
            },
            {
              "$ref": "#/definitions/PerturbationPoleResidue"
            },
            {
              "$ref": "#/definitions/Medium2D"
            }
          ]
        },
        "proj_axis": {
          "title": "Projection Plane Axis",
          "description": "Axis along which the observation plane is oriented.",
          "enum": [
            0,
            1,
            2
          ],
          "type": "integer"
        },
        "proj_distance": {
          "title": "Projection Distance",
          "description": "Signed distance of the projection plane along ``proj_axis``. from the plane containing ``local_origin``.",
          "default": 1000000.0,
          "units": "um",
          "type": "number"
        },
        "x": {
          "title": "Local x Observation Coordinates",
          "description": "Local x observation coordinates w.r.t. ``local_origin`` and ``proj_axis``. When ``proj_axis`` is 0, this corresponds to the global y axis. When ``proj_axis`` is 1, this corresponds to the global x axis. When ``proj_axis`` is 2, this corresponds to the global x axis. ",
          "units": "um",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        },
        "y": {
          "title": "Local y Observation Coordinates",
          "description": "Local y observation coordinates w.r.t. ``local_origin`` and ``proj_axis``. When ``proj_axis`` is 0, this corresponds to the global z axis. When ``proj_axis`` is 1, this corresponds to the global z axis. When ``proj_axis`` is 2, this corresponds to the global y axis. ",
          "units": "um",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        }
      },
      "required": [
        "size",
        "name",
        "freqs",
        "proj_axis",
        "x",
        "y"
      ],
      "additionalProperties": false
    },
    "FieldProjectionKSpaceMonitor": {
      "title": "FieldProjectionKSpaceMonitor",
      "description": ":class:`Monitor` that samples electromagnetic near fields in the frequency domain\nand projects them on an observation plane defined in k-space.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\ninterval_space : Tuple[PositiveInt, PositiveInt, PositiveInt] = (1, 1, 1)\n    Number of grid step intervals at which near fields are recorded for projection to the far field, along each direction. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Using values greater than 1 can help speed up server-side far field projections with minimal accuracy loss, especially in cases where it is necessary for the grid resolution to be high for the FDTD simulation, but such a high resolution is unnecessary for the purpose of projecting the recorded near fields to the far field.\ncolocate : Literal[True] = True\n    Defines whether fields are colocated to grid cell boundaries (i.e. to the primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors and is hard-coded for other monitors depending on their specific function.\nfreqs : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\napodization : ApodizationSpec = ApodizationSpec(start=None, end=None, width=None, type='ApodizationSpec')\n    Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.\nnormal_dir : Optional[Literal['+', '-']] = None\n    Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.\nexclude_surfaces : Optional[Tuple[Literal['x-', 'x+', 'y-', 'y+', 'z-', 'z+'], ...]] = None\n    Surfaces to exclude in the integration, if a volume monitor.\ncustom_origin : Optional[Tuple[float, float, float]] = None\n    [units = um].  Local origin used for defining observation points. If ``None``, uses the monitor's center.\nfar_field_approx : bool = True\n    Whether to enable the far field approximation when projecting fields. If ``True``, terms that decay as O(1/r^2) are ignored, as are the radial components of fields. Typically, this should be set to ``True`` only when the projection distance is much larger than the size of the device being modeled, and the projected points are in the far field of the device.\nwindow_size : Tuple[NonNegativeFloat, NonNegativeFloat] = (0, 0)\n    Size of the transition region of the windowing function used to ensure that the recorded near fields decay to zero near the edges of the monitor. The two components refer to the two tangential directions associated with each surface. For surfaces with the normal along ``x``, the two components are (``y``, ``z``). For surfaces with the normal along ``y``, the two components are (``x``, ``z``). For surfaces with the normal along ``z``, the two components are (``x``, ``y``). Each value must be between 0 and 1, inclusive, and denotes the size of the transition region over which fields are scaled to less than a thousandth of the original amplitude, relative to half the size of the monitor in that direction. A value of 0 turns windowing off in that direction, while a value of 1 indicates that the window will be applied to the entire monitor in that direction. This field is applicable for surface monitors only, and otherwise must remain (0, 0).\nmedium : Union[Medium, AnisotropicMedium, PECMedium, PoleResidue, Sellmeier, Lorentz, Debye, Drude, FullyAnisotropicMedium, CustomMedium, CustomPoleResidue, CustomSellmeier, CustomLorentz, CustomDebye, CustomDrude, CustomAnisotropicMedium, PerturbationMedium, PerturbationPoleResidue, Medium2D] = None\n    Medium through which to project fields. Generally, the fields should be projected through the same medium as the one in which this monitor is placed, and this is the default behavior when ``medium=None``. A custom ``medium`` can be useful in some situations for advanced users, but we recommend trying to avoid using a non-default ``medium``.\nproj_axis : Literal[0, 1, 2]\n    Axis along which the observation plane is oriented.\nproj_distance : float = 1000000.0\n    [units = um].  Radial distance of the projection points from ``local_origin``.\nux : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    Local x component of wave vectors on the observation plane, relative to ``local_origin`` and oriented with respect to ``proj_axis``, normalized by (2*pi/lambda) where lambda is the wavelength associated with the background medium. Must be in the range [-1, 1].\nuy : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    Local y component of wave vectors on the observation plane, relative to ``local_origin`` and oriented with respect to ``proj_axis``, normalized by (2*pi/lambda) where lambda is the wavelength associated with the background medium. Must be in the range [-1, 1].\n\n Notes\n -----\n\n    The :attr:`center` and :attr:`size`\n    fields define where the monitor will be placed in order to record near fields, typically\n    very close to the structure of interest. The near fields are then\n    projected to far-field locations defined in k-space by ``ux``, ``uy``, and ``proj_distance``,\n    relative to the ``custom_origin``. Here, ``ux`` and ``uy`` are associated with a local\n    coordinate system where the local 'z' axis is defined by ``proj_axis``: which is the axis\n    normal to this monitor. If the distance between the near and far field locations is much\n    larger than the size of the device, one can typically set ``far_field_approx`` to ``True``,\n    which will make use of the far-field approximation to speed up calculations. If the\n    projection distance is comparable to the size of the device, we recommend setting\n    ``far_field_approx`` to ``False``, so that the approximations are not used, and the\n    projection is accurate even just a few wavelengths away from the near field locations.\n    For applications where the monitor is an open surface rather than a box that\n    encloses the device, it is advisable to pick the size of the monitor such that the\n    recorded near fields decay to negligible values near the edges of the monitor.\n\n    **Usage Caveats**\n\n    .. TODO I believe a little illustration here would be handy.\n\n    Since field projections rely on the surface equivalence principle, we have assumed that the tangential near\n    fields recorded on the near field monitor serve as equivalent sources which generate the correct far fields.\n    However, this requires that the field strength decays nearly to zero near the edges of the near-field\n    monitor, which may not always be the case. For example, if we had used a larger aperture compared to the full\n    simulation size in the transverse direction, we may expect a degradation in accuracy of the field\n    projections. Despite this limitation, the field projections are still remarkably accurate in realistic\n    scenarios. For realistic case studies further demonstrating the accuracy of the field projections,\n    see our metalens and zone plate case studies.\n\n    The field projections make use of the analytical homogeneous medium Green\u2019s function, which assumes that the fields\n    are propagating in a homogeneous medium. Therefore, one should use PMLs / absorbers as boundary conditions in the\n    part of the domain where fields are projected. For far field projections in the context of perdiodic boundary\n    conditions, see the diffraction efficiency example which demonstrates the use of a :class:`DiffractionMonitor`.\n\n    Server-side field projections will add to the monetary cost of the simulation. However, typically the far field\n    projections have a very small computation cost compared to the FDTD simulation itself, so the increase in monetary\n    cost should be negligibly small in most cases.\n\nExample\n-------\n>>> monitor = FieldProjectionKSpaceMonitor(\n...     center=(1,2,3),\n...     size=(2,2,2),\n...     freqs=[250e12, 300e12],\n...     name='n2f_monitor',\n...     custom_origin=(1,2,3),\n...     proj_axis=2,\n...     ux=[0.1,0.2],\n...     uy=[0.3,0.4,0.5]\n...     )\n\nSee Also\n--------\n\n**Notebooks**:\n    * `Performing near field to far field projections <../../notebooks/FieldProjections.html>`_\n    * `Field projection for a zone plate <../../notebooks/ZonePlateFieldProjection.html>`_\n    * `Metalens in the visible frequency range <../../notebooks/Metalens.html>`_\n    * `Multilevel blazed diffraction grating <../../notebooks/GratingEfficiency.html>`_",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "FieldProjectionKSpaceMonitor",
          "enum": [
            "FieldProjectionKSpaceMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "interval_space": {
          "title": "Spatial Interval",
          "description": "Number of grid step intervals at which near fields are recorded for projection to the far field, along each direction. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Using values greater than 1 can help speed up server-side far field projections with minimal accuracy loss, especially in cases where it is necessary for the grid resolution to be high for the FDTD simulation, but such a high resolution is unnecessary for the purpose of projecting the recorded near fields to the far field.",
          "default": [
            1,
            1,
            1
          ],
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "integer",
              "exclusiveMinimum": 0
            },
            {
              "type": "integer",
              "exclusiveMinimum": 0
            },
            {
              "type": "integer",
              "exclusiveMinimum": 0
            }
          ]
        },
        "colocate": {
          "title": "Colocate Fields",
          "description": "Defines whether fields are colocated to grid cell boundaries (i.e. to the primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors and is hard-coded for other monitors depending on their specific function.",
          "default": true,
          "enum": [
            true
          ],
          "type": "boolean"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        },
        "apodization": {
          "title": "Apodization Specification",
          "description": "Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.",
          "default": {
            "start": null,
            "end": null,
            "width": null,
            "type": "ApodizationSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ApodizationSpec"
            }
          ]
        },
        "normal_dir": {
          "title": "Normal Vector Orientation",
          "description": "Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "exclude_surfaces": {
          "title": "Excluded Surfaces",
          "description": "Surfaces to exclude in the integration, if a volume monitor.",
          "type": "array",
          "items": {
            "enum": [
              "x-",
              "x+",
              "y-",
              "y+",
              "z-",
              "z+"
            ],
            "type": "string"
          }
        },
        "custom_origin": {
          "title": "Local Origin",
          "description": "Local origin used for defining observation points. If ``None``, uses the monitor's center.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "far_field_approx": {
          "title": "Far Field Approximation",
          "description": "Whether to enable the far field approximation when projecting fields. If ``True``, terms that decay as O(1/r^2) are ignored, as are the radial components of fields. Typically, this should be set to ``True`` only when the projection distance is much larger than the size of the device being modeled, and the projected points are in the far field of the device.",
          "default": true,
          "type": "boolean"
        },
        "window_size": {
          "title": "Spatial filtering window size",
          "description": "Size of the transition region of the windowing function used to ensure that the recorded near fields decay to zero near the edges of the monitor. The two components refer to the two tangential directions associated with each surface. For surfaces with the normal along ``x``, the two components are (``y``, ``z``). For surfaces with the normal along ``y``, the two components are (``x``, ``z``). For surfaces with the normal along ``z``, the two components are (``x``, ``y``). Each value must be between 0 and 1, inclusive, and denotes the size of the transition region over which fields are scaled to less than a thousandth of the original amplitude, relative to half the size of the monitor in that direction. A value of 0 turns windowing off in that direction, while a value of 1 indicates that the window will be applied to the entire monitor in that direction. This field is applicable for surface monitors only, and otherwise must remain (0, 0).",
          "default": [
            0,
            0
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "medium": {
          "title": "Projection medium",
          "description": "Medium through which to project fields. Generally, the fields should be projected through the same medium as the one in which this monitor is placed, and this is the default behavior when ``medium=None``. A custom ``medium`` can be useful in some situations for advanced users, but we recommend trying to avoid using a non-default ``medium``.",
          "anyOf": [
            {
              "$ref": "#/definitions/Medium"
            },
            {
              "$ref": "#/definitions/AnisotropicMedium"
            },
            {
              "$ref": "#/definitions/PECMedium"
            },
            {
              "$ref": "#/definitions/PoleResidue"
            },
            {
              "$ref": "#/definitions/Sellmeier"
            },
            {
              "$ref": "#/definitions/Lorentz"
            },
            {
              "$ref": "#/definitions/Debye"
            },
            {
              "$ref": "#/definitions/Drude"
            },
            {
              "$ref": "#/definitions/FullyAnisotropicMedium"
            },
            {
              "$ref": "#/definitions/CustomMedium"
            },
            {
              "$ref": "#/definitions/CustomPoleResidue"
            },
            {
              "$ref": "#/definitions/CustomSellmeier"
            },
            {
              "$ref": "#/definitions/CustomLorentz"
            },
            {
              "$ref": "#/definitions/CustomDebye"
            },
            {
              "$ref": "#/definitions/CustomDrude"
            },
            {
              "$ref": "#/definitions/CustomAnisotropicMedium"
            },
            {
              "$ref": "#/definitions/PerturbationMedium"
            },
            {
              "$ref": "#/definitions/PerturbationPoleResidue"
            },
            {
              "$ref": "#/definitions/Medium2D"
            }
          ]
        },
        "proj_axis": {
          "title": "Projection Plane Axis",
          "description": "Axis along which the observation plane is oriented.",
          "enum": [
            0,
            1,
            2
          ],
          "type": "integer"
        },
        "proj_distance": {
          "title": "Projection Distance",
          "description": "Radial distance of the projection points from ``local_origin``.",
          "default": 1000000.0,
          "units": "um",
          "type": "number"
        },
        "ux": {
          "title": "Normalized kx",
          "description": "Local x component of wave vectors on the observation plane, relative to ``local_origin`` and oriented with respect to ``proj_axis``, normalized by (2*pi/lambda) where lambda is the wavelength associated with the background medium. Must be in the range [-1, 1].",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        },
        "uy": {
          "title": "Normalized ky",
          "description": "Local y component of wave vectors on the observation plane, relative to ``local_origin`` and oriented with respect to ``proj_axis``, normalized by (2*pi/lambda) where lambda is the wavelength associated with the background medium. Must be in the range [-1, 1].",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        }
      },
      "required": [
        "size",
        "name",
        "freqs",
        "proj_axis",
        "ux",
        "uy"
      ],
      "additionalProperties": false
    },
    "DiffractionMonitor": {
      "title": "DiffractionMonitor",
      "description": ":class:`Monitor` that uses a 2D Fourier transform to compute the\ndiffraction amplitudes and efficiency for allowed diffraction orders.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\ninterval_space : Tuple[Literal[1], Literal[1], Literal[1]] = (1, 1, 1)\n    Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Not all monitors support values different from 1.\ncolocate : Literal[False] = False\n    Defines whether fields are colocated to grid cell boundaries (i.e. to the primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors and is hard-coded for other monitors depending on their specific function.\nfreqs : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\napodization : ApodizationSpec = ApodizationSpec(start=None, end=None, width=None, type='ApodizationSpec')\n    Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.\nnormal_dir : Literal['+', '-'] = +\n    Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Defaults to ``'+'`` if not provided.\n\nExample\n-------\n>>> monitor = DiffractionMonitor(\n...     center=(1,2,3),\n...     size=(inf,inf,0),\n...     freqs=[250e12, 300e12],\n...     name='diffraction_monitor',\n...     normal_dir='+',\n...     )\n\nSee Also\n--------\n\n**Notebooks**\n    * `Multilevel blazed diffraction grating <../../notebooks/GratingEfficiency.html>`_",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "DiffractionMonitor",
          "enum": [
            "DiffractionMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "interval_space": {
          "title": "Spatial Interval",
          "description": "Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Not all monitors support values different from 1.",
          "default": [
            1,
            1,
            1
          ],
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "enum": [
                1
              ],
              "type": "integer"
            },
            {
              "enum": [
                1
              ],
              "type": "integer"
            },
            {
              "enum": [
                1
              ],
              "type": "integer"
            }
          ]
        },
        "colocate": {
          "title": "Colocate Fields",
          "description": "Defines whether fields are colocated to grid cell boundaries (i.e. to the primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors and is hard-coded for other monitors depending on their specific function.",
          "default": false,
          "enum": [
            false
          ],
          "type": "boolean"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        },
        "apodization": {
          "title": "Apodization Specification",
          "description": "Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.",
          "default": {
            "start": null,
            "end": null,
            "width": null,
            "type": "ApodizationSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ApodizationSpec"
            }
          ]
        },
        "normal_dir": {
          "title": "Normal Vector Orientation",
          "description": "Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Defaults to ``'+'`` if not provided.",
          "default": "+",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        }
      },
      "required": [
        "size",
        "name",
        "freqs"
      ],
      "additionalProperties": false
    },
    "UniformGrid": {
      "title": "UniformGrid",
      "description": "Uniform 1D grid. The most standard way to define a simulation is to use a constant grid size in each of the three directions.\n\nParameters\n----------\ndl : PositiveFloat\n    [units = um].  Grid size for uniform grid generation.\n\nExample\n-------\n>>> grid_1d = UniformGrid(dl=0.1)\n\nSee Also\n--------\n\n:class:`AutoGrid`\n    Specification for non-uniform grid along a given dimension.\n\n**Notebooks:**\n    * `Photonic crystal waveguide polarization filter <../../../notebooks/PhotonicCrystalWaveguidePolarizationFilter.html>`_\n    * `Using automatic nonuniform meshing <../../notebooks/AutoGrid.html>`_",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "UniformGrid",
          "enum": [
            "UniformGrid"
          ],
          "type": "string"
        },
        "dl": {
          "title": "Grid Size",
          "description": "Grid size for uniform grid generation.",
          "units": "um",
          "exclusiveMinimum": 0,
          "type": "number"
        }
      },
      "required": [
        "dl"
      ],
      "additionalProperties": false
    },
    "CustomGrid": {
      "title": "CustomGrid",
      "description": "Custom 1D grid supplied as a list of grid cell sizes centered on the simulation center.\n\nParameters\n----------\ndl : Tuple[PositiveFloat, ...]\n    [units = um].  An array of custom nonuniform grid sizes. The resulting grid is centered on the simulation center such that it spans the region ``(center - sum(dl)/2, center + sum(dl)/2)``, unless a ``custom_offset`` is given. Note: if supplied sizes do not cover the simulation size, the first and last sizes are repeated to cover the simulation domain.\ncustom_offset : Optional[float] = None\n    [units = um].  The starting coordinate of the grid which defines the simulation center. If ``None``, the simulation center is set such that it spans the region ``(center - sum(dl)/2, center + sum(dl)/2)``.\n\nExample\n-------\n>>> grid_1d = CustomGrid(dl=[0.2, 0.2, 0.1, 0.1, 0.1, 0.2, 0.2])",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "CustomGrid",
          "enum": [
            "CustomGrid"
          ],
          "type": "string"
        },
        "dl": {
          "title": "Customized grid sizes.",
          "description": "An array of custom nonuniform grid sizes. The resulting grid is centered on the simulation center such that it spans the region ``(center - sum(dl)/2, center + sum(dl)/2)``, unless a ``custom_offset`` is given. Note: if supplied sizes do not cover the simulation size, the first and last sizes are repeated to cover the simulation domain.",
          "units": "um",
          "type": "array",
          "items": {
            "type": "number",
            "exclusiveMinimum": 0
          }
        },
        "custom_offset": {
          "title": "Customized grid offset.",
          "description": "The starting coordinate of the grid which defines the simulation center. If ``None``, the simulation center is set such that it spans the region ``(center - sum(dl)/2, center + sum(dl)/2)``.",
          "units": "um",
          "type": "number"
        }
      },
      "required": [
        "dl"
      ],
      "additionalProperties": false
    },
    "GradedMesher": {
      "title": "GradedMesher",
      "description": "Implements automatic nonuniform meshing with a set minimum steps per wavelength and\na graded mesh expanding from higher- to lower-resolution regions.\n\nParameters\n----------",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "GradedMesher",
          "enum": [
            "GradedMesher"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "AutoGrid": {
      "title": "AutoGrid",
      "description": "Specification for non-uniform grid along a given dimension.\n\nParameters\n----------\nmin_steps_per_wvl : ConstrainedFloatValue = 10.0\n    Minimal number of steps per wavelength in each medium.\nmax_scale : ConstrainedFloatValue = 1.4\n    Sets the maximum ratio between any two consecutive grid steps.\ndl_min : NonNegativeFloat = 0\n    Lower bound of the grid size along this dimension regardless of structures present in the simulation, including override structures with ``enforced=True``. It is a soft bound, meaning that the actual minimal grid size might be slightly smaller.\nmesher : GradedMesher = GradedMesher(type='GradedMesher')\n    The type of mesher to use to generate the grid automatically.\n\nExample\n-------\n>>> grid_1d = AutoGrid(min_steps_per_wvl=16, max_scale=1.4)\n\nSee Also\n--------\n\n:class:`UniformGrid`\n    Uniform 1D grid.\n\n:class:`GridSpec`\n    Collective grid specification for all three dimensions.\n\n**Notebooks:**\n    * `Using automatic nonuniform meshing <../../notebooks/AutoGrid.html>`_\n\n**Lectures:**\n    *  `Time step size and CFL condition in FDTD <https://www.flexcompute.com/fdtd101/Lecture-7-Time-step-size-and-CFL-condition-in-FDTD/>`_\n    *  `Numerical dispersion in FDTD <https://www.flexcompute.com/fdtd101/Lecture-8-Numerical-dispersion-in-FDTD/>`_",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "AutoGrid",
          "enum": [
            "AutoGrid"
          ],
          "type": "string"
        },
        "min_steps_per_wvl": {
          "title": "Minimal number of steps per wavelength",
          "description": "Minimal number of steps per wavelength in each medium.",
          "default": 10.0,
          "minimum": 6.0,
          "type": "number"
        },
        "max_scale": {
          "title": "Maximum Grid Size Scaling",
          "description": "Sets the maximum ratio between any two consecutive grid steps.",
          "default": 1.4,
          "exclusiveMaximum": 2.0,
          "minimum": 1.2,
          "type": "number"
        },
        "dl_min": {
          "title": "Lower bound of grid size",
          "description": "Lower bound of the grid size along this dimension regardless of structures present in the simulation, including override structures with ``enforced=True``. It is a soft bound, meaning that the actual minimal grid size might be slightly smaller.",
          "default": 0,
          "minimum": 0,
          "type": "number"
        },
        "mesher": {
          "title": "Grid Construction Tool",
          "description": "The type of mesher to use to generate the grid automatically.",
          "default": {
            "type": "GradedMesher"
          },
          "allOf": [
            {
              "$ref": "#/definitions/GradedMesher"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "MeshOverrideStructure": {
      "title": "MeshOverrideStructure",
      "description": "Defines an object that is only used in the process of generating the mesh.\n\nParameters\n----------\ngeometry : Union[Box, Transformed, ClipOperation, GeometryGroup, Sphere, Cylinder, PolySlab, ComplexPolySlabBase, TriangleMesh]\n    Defines geometric properties of the structure.\nname : Optional[str] = None\n    Optional name for the structure.\ndl : Tuple[PositiveFloat, PositiveFloat, PositiveFloat]\n    [units = um].  Grid size along x, y, z directions.\nenforce : bool = False\n    If ``True``, enforce the grid size setup inside the structure even if the structure is inside a structure of smaller grid size. In the intersection region of multiple structures of ``enforce=True``, grid size is decided by the last added structure of ``enforce=True``.\n\nNotes\n-----\n\n    A :class:`MeshOverrideStructure` is a combination of geometry :class:`Geometry`,\n    grid size along ``x``, ``y``, ``z`` directions, and a boolean on whether the override\n    will be enforced.\n\nExample\n-------\n>>> from tidy3d import Box\n>>> box = Box(center=(0,0,1), size=(2, 2, 2))\n>>> struct_override = MeshOverrideStructure(geometry=box, dl=(0.1,0.2,0.3), name='override_box')",
      "type": "object",
      "properties": {
        "geometry": {
          "title": "Geometry",
          "description": "Defines geometric properties of the structure.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "Box": "#/definitions/Box",
              "Transformed": "#/definitions/Transformed",
              "ClipOperation": "#/definitions/ClipOperation",
              "GeometryGroup": "#/definitions/GeometryGroup",
              "Sphere": "#/definitions/Sphere",
              "Cylinder": "#/definitions/Cylinder",
              "PolySlab": "#/definitions/PolySlab",
              "ComplexPolySlabBase": "#/definitions/ComplexPolySlabBase",
              "TriangleMesh": "#/definitions/TriangleMesh"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/Box"
            },
            {
              "$ref": "#/definitions/Transformed"
            },
            {
              "$ref": "#/definitions/ClipOperation"
            },
            {
              "$ref": "#/definitions/GeometryGroup"
            },
            {
              "$ref": "#/definitions/Sphere"
            },
            {
              "$ref": "#/definitions/Cylinder"
            },
            {
              "$ref": "#/definitions/PolySlab"
            },
            {
              "$ref": "#/definitions/ComplexPolySlabBase"
            },
            {
              "$ref": "#/definitions/TriangleMesh"
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Optional name for the structure.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "MeshOverrideStructure",
          "enum": [
            "MeshOverrideStructure"
          ],
          "type": "string"
        },
        "dl": {
          "title": "Grid Size",
          "description": "Grid size along x, y, z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "exclusiveMinimum": 0
            },
            {
              "type": "number",
              "exclusiveMinimum": 0
            },
            {
              "type": "number",
              "exclusiveMinimum": 0
            }
          ]
        },
        "enforce": {
          "title": "Enforce grid size",
          "description": "If ``True``, enforce the grid size setup inside the structure even if the structure is inside a structure of smaller grid size. In the intersection region of multiple structures of ``enforce=True``, grid size is decided by the last added structure of ``enforce=True``.",
          "default": false,
          "type": "boolean"
        }
      },
      "required": [
        "geometry",
        "dl"
      ],
      "additionalProperties": false
    },
    "GridSpec": {
      "title": "GridSpec",
      "description": "Collective grid specification for all three dimensions.\n\nParameters\n----------\ngrid_x : Union[UniformGrid, CustomGrid, AutoGrid] = AutoGrid(type='AutoGrid', min_steps_per_wvl=10.0, max_scale=1.4, dl_min=0.0, mesher=GradedMesher(type='GradedMesher'))\n    Grid specification along x-axis\ngrid_y : Union[UniformGrid, CustomGrid, AutoGrid] = AutoGrid(type='AutoGrid', min_steps_per_wvl=10.0, max_scale=1.4, dl_min=0.0, mesher=GradedMesher(type='GradedMesher'))\n    Grid specification along y-axis\ngrid_z : Union[UniformGrid, CustomGrid, AutoGrid] = AutoGrid(type='AutoGrid', min_steps_per_wvl=10.0, max_scale=1.4, dl_min=0.0, mesher=GradedMesher(type='GradedMesher'))\n    Grid specification along z-axis\nwavelength : Optional[float] = None\n    [units = um].  Free-space wavelength for automatic nonuniform grid. It can be 'None' if there is at least one source in the simulation, in which case it is defined by the source central frequency. Note: it only takes effect when at least one of the three dimensions uses :class:`.AutoGrid`.\noverride_structures : Tuple[Annotated[Union[tidy3d.components.structure.Structure, tidy3d.components.structure.MeshOverrideStructure], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})], ...] = ()\n    A set of structures that is added on top of the simulation structures in the process of generating the grid. This can be used to refine the grid or make it coarser depending than the expected need for higher/lower resolution regions. Note: it only takes effect when at least one of the three dimensions uses :class:`.AutoGrid`.\n\nExample\n-------\n>>> uniform = UniformGrid(dl=0.1)\n>>> custom = CustomGrid(dl=[0.2, 0.2, 0.1, 0.1, 0.1, 0.2, 0.2])\n>>> auto = AutoGrid(min_steps_per_wvl=12)\n>>> grid_spec = GridSpec(grid_x=uniform, grid_y=custom, grid_z=auto, wavelength=1.5)\n\nSee Also\n--------\n\n:class:`UniformGrid`\n    Uniform 1D grid.\n\n:class:`AutoGrid`\n    Specification for non-uniform grid along a given dimension.\n\n**Notebooks:**\n    * `Using automatic nonuniform meshing <../../notebooks/AutoGrid.html>`_\n\n**Lectures:**\n    *  `Time step size and CFL condition in FDTD <https://www.flexcompute.com/fdtd101/Lecture-7-Time-step-size-and-CFL-condition-in-FDTD/>`_\n    *  `Numerical dispersion in FDTD <https://www.flexcompute.com/fdtd101/Lecture-8-Numerical-dispersion-in-FDTD/>`_",
      "type": "object",
      "properties": {
        "grid_x": {
          "title": "Grid specification along x-axis",
          "description": "Grid specification along x-axis",
          "default": {
            "type": "AutoGrid",
            "min_steps_per_wvl": 10.0,
            "max_scale": 1.4,
            "dl_min": 0.0,
            "mesher": {
              "type": "GradedMesher"
            }
          },
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "UniformGrid": "#/definitions/UniformGrid",
              "CustomGrid": "#/definitions/CustomGrid",
              "AutoGrid": "#/definitions/AutoGrid"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/UniformGrid"
            },
            {
              "$ref": "#/definitions/CustomGrid"
            },
            {
              "$ref": "#/definitions/AutoGrid"
            }
          ]
        },
        "grid_y": {
          "title": "Grid specification along y-axis",
          "description": "Grid specification along y-axis",
          "default": {
            "type": "AutoGrid",
            "min_steps_per_wvl": 10.0,
            "max_scale": 1.4,
            "dl_min": 0.0,
            "mesher": {
              "type": "GradedMesher"
            }
          },
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "UniformGrid": "#/definitions/UniformGrid",
              "CustomGrid": "#/definitions/CustomGrid",
              "AutoGrid": "#/definitions/AutoGrid"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/UniformGrid"
            },
            {
              "$ref": "#/definitions/CustomGrid"
            },
            {
              "$ref": "#/definitions/AutoGrid"
            }
          ]
        },
        "grid_z": {
          "title": "Grid specification along z-axis",
          "description": "Grid specification along z-axis",
          "default": {
            "type": "AutoGrid",
            "min_steps_per_wvl": 10.0,
            "max_scale": 1.4,
            "dl_min": 0.0,
            "mesher": {
              "type": "GradedMesher"
            }
          },
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "UniformGrid": "#/definitions/UniformGrid",
              "CustomGrid": "#/definitions/CustomGrid",
              "AutoGrid": "#/definitions/AutoGrid"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/UniformGrid"
            },
            {
              "$ref": "#/definitions/CustomGrid"
            },
            {
              "$ref": "#/definitions/AutoGrid"
            }
          ]
        },
        "wavelength": {
          "title": "Free-space wavelength",
          "description": "Free-space wavelength for automatic nonuniform grid. It can be 'None' if there is at least one source in the simulation, in which case it is defined by the source central frequency. Note: it only takes effect when at least one of the three dimensions uses :class:`.AutoGrid`.",
          "units": "um",
          "type": "number"
        },
        "override_structures": {
          "title": "Grid specification override structures",
          "description": "A set of structures that is added on top of the simulation structures in the process of generating the grid. This can be used to refine the grid or make it coarser depending than the expected need for higher/lower resolution regions. Note: it only takes effect when at least one of the three dimensions uses :class:`.AutoGrid`.",
          "default": [],
          "type": "array",
          "items": {
            "discriminator": {
              "propertyName": "type",
              "mapping": {
                "Structure": "#/definitions/Structure",
                "MeshOverrideStructure": "#/definitions/MeshOverrideStructure"
              }
            },
            "oneOf": [
              {
                "$ref": "#/definitions/Structure"
              },
              {
                "$ref": "#/definitions/MeshOverrideStructure"
              }
            ]
          }
        },
        "type": {
          "title": "Type",
          "default": "GridSpec",
          "enum": [
            "GridSpec"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    }
  }
}
{
  "title": "Simulation",
  "description": "Contains all information about Tidy3d simulation.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nmedium : Union[Medium, AnisotropicMedium, PECMedium, PoleResidue, Sellmeier, Lorentz, Debye, Drude, FullyAnisotropicMedium, CustomMedium, CustomPoleResidue, CustomSellmeier, CustomLorentz, CustomDebye, CustomDrude, CustomAnisotropicMedium, PerturbationMedium, PerturbationPoleResidue] = Medium(name=None, frequency_range=None, allow_gain=False, nonlinear_spec=None, modulation_spec=None, heat_spec=None, type='Medium', permittivity=1.0, conductivity=0.0)\n    Background medium of simulation, defaults to vacuum if not specified.\nstructures : Tuple[Structure, ...] = ()\n    Tuple of structures present in simulation. Note: Structures defined later in this list override the simulation material properties in regions of spatial overlap.\nsymmetry : Tuple[Literal[0, -1, 1], Literal[0, -1, 1], Literal[0, -1, 1]] = (0, 0, 0)\n    Tuple of integers defining reflection symmetry across a plane bisecting the simulation domain normal to the x-, y-, and z-axis at the simulation center of each axis, respectively. Each element can be ``0`` (no symmetry), ``1`` (even, i.e. 'PMC' symmetry) or ``-1`` (odd, i.e. 'PEC' symmetry). Note that the vectorial nature of the fields must be taken into account to correctly determine the symmetry value.\nsources : Tuple[Annotated[Union[tidy3d.components.source.UniformCurrentSource, tidy3d.components.source.PointDipole, tidy3d.components.source.GaussianBeam, tidy3d.components.source.AstigmaticGaussianBeam, tidy3d.components.source.ModeSource, tidy3d.components.source.PlaneWave, tidy3d.components.source.CustomFieldSource, tidy3d.components.source.CustomCurrentSource, tidy3d.components.source.TFSF], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})], ...] = ()\n    Tuple of electric current sources injecting fields into the simulation.\nboundary_spec : BoundarySpec = BoundarySpec(x=Boundary(plus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)),, minus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)),, type='Boundary'), y=Boundary(plus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)),, minus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)),, type='Boundary'), z=Boundary(plus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)),, minus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)),, type='Boundary'), type='BoundarySpec')\n    Specification of boundary conditions along each dimension. If ``None``, PML boundary conditions are applied on all sides.\nmonitors : Tuple[Annotated[Union[tidy3d.components.monitor.FieldMonitor, tidy3d.components.monitor.FieldTimeMonitor, tidy3d.components.monitor.PermittivityMonitor, tidy3d.components.monitor.FluxMonitor, tidy3d.components.monitor.FluxTimeMonitor, tidy3d.components.monitor.ModeMonitor, tidy3d.components.monitor.ModeSolverMonitor, tidy3d.components.monitor.FieldProjectionAngleMonitor, tidy3d.components.monitor.FieldProjectionCartesianMonitor, tidy3d.components.monitor.FieldProjectionKSpaceMonitor, tidy3d.components.monitor.DiffractionMonitor], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})], ...] = ()\n    Tuple of monitors in the simulation. Note: monitor names are used to access data after simulation is run.\ngrid_spec : GridSpec = GridSpec(grid_x=AutoGrid(type='AutoGrid',, min_steps_per_wvl=10.0,, max_scale=1.4,, dl_min=0.0,, mesher=GradedMesher(type='GradedMesher')), grid_y=AutoGrid(type='AutoGrid',, min_steps_per_wvl=10.0,, max_scale=1.4,, dl_min=0.0,, mesher=GradedMesher(type='GradedMesher')), grid_z=AutoGrid(type='AutoGrid',, min_steps_per_wvl=10.0,, max_scale=1.4,, dl_min=0.0,, mesher=GradedMesher(type='GradedMesher')), wavelength=None, override_structures=(), type='GridSpec')\n    Specifications for the simulation grid along each of the three directions.\nversion : str = 2.5.2\n    String specifying the front end version number.\nrun_time : PositiveFloat\n    [units = sec].  Total electromagnetic evolution time in seconds. Note: If simulation 'shutoff' is specified, simulation will terminate early when shutoff condition met. \nshutoff : NonNegativeFloat = 1e-05\n    Ratio of the instantaneous integrated E-field intensity to the maximum value at which the simulation will automatically terminate time stepping. Used to prevent extraneous run time of simulations with fully decayed fields. Set to ``0`` to disable this feature.\nsubpixel : bool = True\n    If ``True``, uses subpixel averaging of the permittivity based on structure definition, resulting in much higher accuracy for a given grid size.\nnormalize_index : Optional[NonNegativeInt] = 0\n    Index of the source in the tuple of sources whose spectrum will be used to normalize the frequency-dependent data. If ``None``, the raw field data is returned unnormalized.\ncourant : ConstrainedFloatValue = 0.99\n    Courant stability factor, controls time step to spatial step ratio. Lower values lead to more stable simulations for dispersive materials, but result in longer simulation times. This factor is normalized to no larger than 1 when CFL stability condition is met in 3D.\n\nExample\n-------\n>>> from tidy3d import Sphere, Cylinder, PolySlab\n>>> from tidy3d import UniformCurrentSource, GaussianPulse\n>>> from tidy3d import FieldMonitor, FluxMonitor\n>>> from tidy3d import GridSpec, AutoGrid\n>>> from tidy3d import BoundarySpec, Boundary\n>>> sim = Simulation(\n...     size=(3.0, 3.0, 3.0),\n...     grid_spec=GridSpec(\n...         grid_x = AutoGrid(min_steps_per_wvl = 20),\n...         grid_y = AutoGrid(min_steps_per_wvl = 20),\n...         grid_z = AutoGrid(min_steps_per_wvl = 20)\n...     ),\n...     run_time=40e-11,\n...     structures=[\n...         Structure(\n...             geometry=Box(size=(1, 1, 1), center=(0, 0, 0)),\n...             medium=Medium(permittivity=2.0),\n...         ),\n...     ],\n...     sources=[\n...         UniformCurrentSource(\n...             size=(0, 0, 0),\n...             center=(0, 0.5, 0),\n...             polarization=\"Hx\",\n...             source_time=GaussianPulse(\n...                 freq0=2e14,\n...                 fwidth=4e13,\n...             ),\n...         )\n...     ],\n...     monitors=[\n...         FluxMonitor(size=(1, 1, 0), center=(0, 0, 0), freqs=[2e14, 2.5e14], name='flux'),\n...     ],\n...     symmetry=(0, 0, 0),\n...     boundary_spec=BoundarySpec(\n...         x = Boundary.pml(num_layers=20),\n...         y = Boundary.pml(num_layers=30),\n...         z = Boundary.periodic(),\n...     ),\n...     shutoff=1e-6,\n...     courant=0.8,\n...     subpixel=False,\n... )",
  "type": "object",
  "properties": {
    "type": {
      "title": "Type",
      "default": "Simulation",
      "enum": [
        "Simulation"
      ],
      "type": "string"
    },
    "center": {
      "title": "Center",
      "description": "Center of object in x, y, and z.",
      "default": [
        0.0,
        0.0,
        0.0
      ],
      "units": "um",
      "type": "array",
      "minItems": 3,
      "maxItems": 3,
      "items": [
        {
          "type": "number"
        },
        {
          "type": "number"
        },
        {
          "type": "number"
        }
      ]
    },
    "size": {
      "title": "Size",
      "description": "Size in x, y, and z directions.",
      "units": "um",
      "type": "array",
      "minItems": 3,
      "maxItems": 3,
      "items": [
        {
          "type": "number",
          "minimum": 0
        },
        {
          "type": "number",
          "minimum": 0
        },
        {
          "type": "number",
          "minimum": 0
        }
      ]
    },
    "medium": {
      "title": "Background Medium",
      "description": "Background medium of simulation, defaults to vacuum if not specified.",
      "default": {
        "name": null,
        "frequency_range": null,
        "allow_gain": false,
        "nonlinear_spec": null,
        "modulation_spec": null,
        "heat_spec": null,
        "type": "Medium",
        "permittivity": 1.0,
        "conductivity": 0.0
      },
      "discriminator": {
        "propertyName": "type",
        "mapping": {
          "Medium": "#/definitions/Medium",
          "AnisotropicMedium": "#/definitions/AnisotropicMedium",
          "PECMedium": "#/definitions/PECMedium",
          "PoleResidue": "#/definitions/PoleResidue",
          "Sellmeier": "#/definitions/Sellmeier",
          "Lorentz": "#/definitions/Lorentz",
          "Debye": "#/definitions/Debye",
          "Drude": "#/definitions/Drude",
          "FullyAnisotropicMedium": "#/definitions/FullyAnisotropicMedium",
          "CustomMedium": "#/definitions/CustomMedium",
          "CustomPoleResidue": "#/definitions/CustomPoleResidue",
          "CustomSellmeier": "#/definitions/CustomSellmeier",
          "CustomLorentz": "#/definitions/CustomLorentz",
          "CustomDebye": "#/definitions/CustomDebye",
          "CustomDrude": "#/definitions/CustomDrude",
          "CustomAnisotropicMedium": "#/definitions/CustomAnisotropicMedium",
          "PerturbationMedium": "#/definitions/PerturbationMedium",
          "PerturbationPoleResidue": "#/definitions/PerturbationPoleResidue"
        }
      },
      "oneOf": [
        {
          "$ref": "#/definitions/Medium"
        },
        {
          "$ref": "#/definitions/AnisotropicMedium"
        },
        {
          "$ref": "#/definitions/PECMedium"
        },
        {
          "$ref": "#/definitions/PoleResidue"
        },
        {
          "$ref": "#/definitions/Sellmeier"
        },
        {
          "$ref": "#/definitions/Lorentz"
        },
        {
          "$ref": "#/definitions/Debye"
        },
        {
          "$ref": "#/definitions/Drude"
        },
        {
          "$ref": "#/definitions/FullyAnisotropicMedium"
        },
        {
          "$ref": "#/definitions/CustomMedium"
        },
        {
          "$ref": "#/definitions/CustomPoleResidue"
        },
        {
          "$ref": "#/definitions/CustomSellmeier"
        },
        {
          "$ref": "#/definitions/CustomLorentz"
        },
        {
          "$ref": "#/definitions/CustomDebye"
        },
        {
          "$ref": "#/definitions/CustomDrude"
        },
        {
          "$ref": "#/definitions/CustomAnisotropicMedium"
        },
        {
          "$ref": "#/definitions/PerturbationMedium"
        },
        {
          "$ref": "#/definitions/PerturbationPoleResidue"
        }
      ]
    },
    "structures": {
      "title": "Structures",
      "description": "Tuple of structures present in simulation. Note: Structures defined later in this list override the simulation material properties in regions of spatial overlap.",
      "default": [],
      "type": "array",
      "items": {
        "$ref": "#/definitions/Structure"
      }
    },
    "symmetry": {
      "title": "Symmetries",
      "description": "Tuple of integers defining reflection symmetry across a plane bisecting the simulation domain normal to the x-, y-, and z-axis at the simulation center of each axis, respectively. Each element can be ``0`` (no symmetry), ``1`` (even, i.e. 'PMC' symmetry) or ``-1`` (odd, i.e. 'PEC' symmetry). Note that the vectorial nature of the fields must be taken into account to correctly determine the symmetry value.",
      "default": [
        0,
        0,
        0
      ],
      "type": "array",
      "minItems": 3,
      "maxItems": 3,
      "items": [
        {
          "enum": [
            0,
            -1,
            1
          ],
          "type": "integer"
        },
        {
          "enum": [
            0,
            -1,
            1
          ],
          "type": "integer"
        },
        {
          "enum": [
            0,
            -1,
            1
          ],
          "type": "integer"
        }
      ]
    },
    "sources": {
      "title": "Sources",
      "description": "Tuple of electric current sources injecting fields into the simulation.",
      "default": [],
      "type": "array",
      "items": {
        "discriminator": {
          "propertyName": "type",
          "mapping": {
            "UniformCurrentSource": "#/definitions/UniformCurrentSource",
            "PointDipole": "#/definitions/PointDipole",
            "GaussianBeam": "#/definitions/GaussianBeam",
            "AstigmaticGaussianBeam": "#/definitions/AstigmaticGaussianBeam",
            "ModeSource": "#/definitions/ModeSource",
            "PlaneWave": "#/definitions/PlaneWave",
            "CustomFieldSource": "#/definitions/CustomFieldSource",
            "CustomCurrentSource": "#/definitions/CustomCurrentSource",
            "TFSF": "#/definitions/TFSF"
          }
        },
        "oneOf": [
          {
            "$ref": "#/definitions/UniformCurrentSource"
          },
          {
            "$ref": "#/definitions/PointDipole"
          },
          {
            "$ref": "#/definitions/GaussianBeam"
          },
          {
            "$ref": "#/definitions/AstigmaticGaussianBeam"
          },
          {
            "$ref": "#/definitions/ModeSource"
          },
          {
            "$ref": "#/definitions/PlaneWave"
          },
          {
            "$ref": "#/definitions/CustomFieldSource"
          },
          {
            "$ref": "#/definitions/CustomCurrentSource"
          },
          {
            "$ref": "#/definitions/TFSF"
          }
        ]
      }
    },
    "boundary_spec": {
      "title": "Boundaries",
      "description": "Specification of boundary conditions along each dimension. If ``None``, PML boundary conditions are applied on all sides.",
      "default": {
        "x": {
          "plus": {
            "name": null,
            "type": "PML",
            "num_layers": 12,
            "parameters": {
              "sigma_order": 3,
              "sigma_min": 0.0,
              "sigma_max": 1.5,
              "type": "PMLParams",
              "kappa_order": 3,
              "kappa_min": 1.0,
              "kappa_max": 3.0,
              "alpha_order": 1,
              "alpha_min": 0.0,
              "alpha_max": 0.0
            }
          },
          "minus": {
            "name": null,
            "type": "PML",
            "num_layers": 12,
            "parameters": {
              "sigma_order": 3,
              "sigma_min": 0.0,
              "sigma_max": 1.5,
              "type": "PMLParams",
              "kappa_order": 3,
              "kappa_min": 1.0,
              "kappa_max": 3.0,
              "alpha_order": 1,
              "alpha_min": 0.0,
              "alpha_max": 0.0
            }
          },
          "type": "Boundary"
        },
        "y": {
          "plus": {
            "name": null,
            "type": "PML",
            "num_layers": 12,
            "parameters": {
              "sigma_order": 3,
              "sigma_min": 0.0,
              "sigma_max": 1.5,
              "type": "PMLParams",
              "kappa_order": 3,
              "kappa_min": 1.0,
              "kappa_max": 3.0,
              "alpha_order": 1,
              "alpha_min": 0.0,
              "alpha_max": 0.0
            }
          },
          "minus": {
            "name": null,
            "type": "PML",
            "num_layers": 12,
            "parameters": {
              "sigma_order": 3,
              "sigma_min": 0.0,
              "sigma_max": 1.5,
              "type": "PMLParams",
              "kappa_order": 3,
              "kappa_min": 1.0,
              "kappa_max": 3.0,
              "alpha_order": 1,
              "alpha_min": 0.0,
              "alpha_max": 0.0
            }
          },
          "type": "Boundary"
        },
        "z": {
          "plus": {
            "name": null,
            "type": "PML",
            "num_layers": 12,
            "parameters": {
              "sigma_order": 3,
              "sigma_min": 0.0,
              "sigma_max": 1.5,
              "type": "PMLParams",
              "kappa_order": 3,
              "kappa_min": 1.0,
              "kappa_max": 3.0,
              "alpha_order": 1,
              "alpha_min": 0.0,
              "alpha_max": 0.0
            }
          },
          "minus": {
            "name": null,
            "type": "PML",
            "num_layers": 12,
            "parameters": {
              "sigma_order": 3,
              "sigma_min": 0.0,
              "sigma_max": 1.5,
              "type": "PMLParams",
              "kappa_order": 3,
              "kappa_min": 1.0,
              "kappa_max": 3.0,
              "alpha_order": 1,
              "alpha_min": 0.0,
              "alpha_max": 0.0
            }
          },
          "type": "Boundary"
        },
        "type": "BoundarySpec"
      },
      "allOf": [
        {
          "$ref": "#/definitions/BoundarySpec"
        }
      ]
    },
    "monitors": {
      "title": "Monitors",
      "description": "Tuple of monitors in the simulation. Note: monitor names are used to access data after simulation is run.",
      "default": [],
      "type": "array",
      "items": {
        "discriminator": {
          "propertyName": "type",
          "mapping": {
            "FieldMonitor": "#/definitions/FieldMonitor",
            "FieldTimeMonitor": "#/definitions/FieldTimeMonitor",
            "PermittivityMonitor": "#/definitions/PermittivityMonitor",
            "FluxMonitor": "#/definitions/FluxMonitor",
            "FluxTimeMonitor": "#/definitions/FluxTimeMonitor",
            "ModeMonitor": "#/definitions/ModeMonitor",
            "ModeSolverMonitor": "#/definitions/ModeSolverMonitor",
            "FieldProjectionAngleMonitor": "#/definitions/FieldProjectionAngleMonitor",
            "FieldProjectionCartesianMonitor": "#/definitions/FieldProjectionCartesianMonitor",
            "FieldProjectionKSpaceMonitor": "#/definitions/FieldProjectionKSpaceMonitor",
            "DiffractionMonitor": "#/definitions/DiffractionMonitor"
          }
        },
        "oneOf": [
          {
            "$ref": "#/definitions/FieldMonitor"
          },
          {
            "$ref": "#/definitions/FieldTimeMonitor"
          },
          {
            "$ref": "#/definitions/PermittivityMonitor"
          },
          {
            "$ref": "#/definitions/FluxMonitor"
          },
          {
            "$ref": "#/definitions/FluxTimeMonitor"
          },
          {
            "$ref": "#/definitions/ModeMonitor"
          },
          {
            "$ref": "#/definitions/ModeSolverMonitor"
          },
          {
            "$ref": "#/definitions/FieldProjectionAngleMonitor"
          },
          {
            "$ref": "#/definitions/FieldProjectionCartesianMonitor"
          },
          {
            "$ref": "#/definitions/FieldProjectionKSpaceMonitor"
          },
          {
            "$ref": "#/definitions/DiffractionMonitor"
          }
        ]
      }
    },
    "grid_spec": {
      "title": "Grid Specification",
      "description": "Specifications for the simulation grid along each of the three directions.",
      "default": {
        "grid_x": {
          "type": "AutoGrid",
          "min_steps_per_wvl": 10.0,
          "max_scale": 1.4,
          "dl_min": 0.0,
          "mesher": {
            "type": "GradedMesher"
          }
        },
        "grid_y": {
          "type": "AutoGrid",
          "min_steps_per_wvl": 10.0,
          "max_scale": 1.4,
          "dl_min": 0.0,
          "mesher": {
            "type": "GradedMesher"
          }
        },
        "grid_z": {
          "type": "AutoGrid",
          "min_steps_per_wvl": 10.0,
          "max_scale": 1.4,
          "dl_min": 0.0,
          "mesher": {
            "type": "GradedMesher"
          }
        },
        "wavelength": null,
        "override_structures": [],
        "type": "GridSpec"
      },
      "allOf": [
        {
          "$ref": "#/definitions/GridSpec"
        }
      ]
    },
    "version": {
      "title": "Version",
      "description": "String specifying the front end version number.",
      "default": "2.5.2",
      "type": "string"
    },
    "run_time": {
      "title": "Run Time",
      "description": "Total electromagnetic evolution time in seconds. Note: If simulation 'shutoff' is specified, simulation will terminate early when shutoff condition met. ",
      "units": "sec",
      "exclusiveMinimum": 0,
      "type": "number"
    },
    "shutoff": {
      "title": "Shutoff Condition",
      "description": "Ratio of the instantaneous integrated E-field intensity to the maximum value at which the simulation will automatically terminate time stepping. Used to prevent extraneous run time of simulations with fully decayed fields. Set to ``0`` to disable this feature.",
      "default": 1e-05,
      "minimum": 0,
      "type": "number"
    },
    "subpixel": {
      "title": "Subpixel Averaging",
      "description": "If ``True``, uses subpixel averaging of the permittivity based on structure definition, resulting in much higher accuracy for a given grid size.",
      "default": true,
      "type": "boolean"
    },
    "normalize_index": {
      "title": "Normalization index",
      "description": "Index of the source in the tuple of sources whose spectrum will be used to normalize the frequency-dependent data. If ``None``, the raw field data is returned unnormalized.",
      "default": 0,
      "minimum": 0,
      "type": "integer"
    },
    "courant": {
      "title": "Courant Factor",
      "description": "Courant stability factor, controls time step to spatial step ratio. Lower values lead to more stable simulations for dispersive materials, but result in longer simulation times. This factor is normalized to no larger than 1 when CFL stability condition is met in 3D.",
      "default": 0.99,
      "exclusiveMinimum": 0.0,
      "maximum": 1.0,
      "type": "number"
    }
  },
  "required": [
    "size",
    "run_time"
  ],
  "additionalProperties": false,
  "definitions": {
    "NonlinearSusceptibility": {
      "title": "NonlinearSusceptibility",
      "description": "Model for an instantaneous nonlinear chi3 susceptibility.\nThe expression for the instantaneous nonlinear polarization is given below.\n\nParameters\n----------\nchi3 : float = 0\n    [units = um^2 / V^2].  Chi3 nonlinear susceptibility.\nnumiters : Optional[PositiveInt] = None\n    Deprecated. The old usage 'nonlinear_spec=model' with 'model.numiters' is deprecated and will be removed in a future release. The new usage is 'nonlinear_spec=NonlinearSpec(models=\\[model], num_iters=num_iters)'. Under the new usage, this parameter is ignored, and 'NonlinearSpec.num_iters' is used instead.\n\nNote\n----\n.. math::\n\n    P_{NL} = \\varepsilon_0 \\chi_3 |E|^2 E\n\nNote\n----\nThis model uses real time-domain fields, so :math:`\\chi_3` must be real.\nFor complex fields (e.g. when using Bloch boundary conditions), the nonlinearity\nis applied separately to the real and imaginary parts, so that the above equation\nholds when both E and :math:`P_{NL}` are replaced by their real or imaginary parts.\nThe nonlinearity is applied to the real and imaginary components separately since\neach of those represents a physical field.\n\nNote\n----\nDifferent field components do not interact nonlinearly. For example,\nwhen calculating :math:`P_{NL, x}`, we approximate :math:`|E|^2 \\approx |E_x|^2`.\nThis approximation is valid when the E field is predominantly polarized along one\nof the x, y, or z axes.\n\nExample\n-------\n>>> nonlinear_susceptibility = NonlinearSusceptibility(chi3=1)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "NonlinearSusceptibility",
          "enum": [
            "NonlinearSusceptibility"
          ],
          "type": "string"
        },
        "chi3": {
          "title": "Chi3",
          "description": "Chi3 nonlinear susceptibility.",
          "default": 0,
          "units": "um^2 / V^2",
          "type": "number"
        },
        "numiters": {
          "title": "Number of iterations",
          "description": "Deprecated. The old usage 'nonlinear_spec=model' with 'model.numiters' is deprecated and will be removed in a future release. The new usage is 'nonlinear_spec=NonlinearSpec(models=\\[model], num_iters=num_iters)'. Under the new usage, this parameter is ignored, and 'NonlinearSpec.num_iters' is used instead.",
          "exclusiveMinimum": 0,
          "type": "integer"
        }
      },
      "additionalProperties": false
    },
    "ComplexNumber": {
      "title": "ComplexNumber",
      "description": "Complex number with a well defined schema.",
      "type": "object",
      "properties": {
        "real": {
          "title": "Real",
          "type": "number"
        },
        "imag": {
          "title": "Imag",
          "type": "number"
        }
      },
      "required": [
        "real",
        "imag"
      ]
    },
    "TwoPhotonAbsorption": {
      "title": "TwoPhotonAbsorption",
      "description": "Model for two-photon absorption (TPA) nonlinearity which gives an intensity-dependent\nabsorption of the form :math:`\\alpha = \\alpha_0 + \\beta I`.\nThe expression for the nonlinear polarization is given below.\n\nParameters\n----------\nbeta : Union[tidycomplex, ComplexNumber] = 0\n    [units = um / W].  Coefficient for two-photon absorption (TPA).\nn0 : Union[tidycomplex, ComplexNumber, NoneType] = None\n    Complex linear refractive index of the medium, computed for instance using 'medium.nk_model'. If not provided, it is calculated automatically using the central frequencies of the simulation sources (as long as these are all equal).\n\nNote\n----\n.. math::\n\n    P_{NL} = -\\frac{c_0^2 \\varepsilon_0^2 n_0 \\operatorname{Re}(n_0) \\beta}{2 i \\omega} |E|^2 E\n\nNote\n----\nThis frequency-domain equation is implemented in the time domain using complex-valued fields.\n\nNote\n----\nDifferent field components do not interact nonlinearly. For example,\nwhen calculating :math:`P_{NL, x}`, we approximate :math:`|E|^2 \\approx |E_x|^2`.\nThis approximation is valid when the E field is predominantly polarized along one\nof the x, y, or z axes.\n\nNote\n----\nThe implementation is described in::\n\n    N. Suzuki, \"FDTD Analysis of Two-Photon Absorption and Free-Carrier Absorption in Si\n    High-Index-Contrast Waveguides,\" J. Light. Technol. 25, 9 (2007).\n\nExample\n-------\n>>> tpa_model = TwoPhotonAbsorption(beta=1)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "TwoPhotonAbsorption",
          "enum": [
            "TwoPhotonAbsorption"
          ],
          "type": "string"
        },
        "beta": {
          "title": "TPA coefficient",
          "description": "Coefficient for two-photon absorption (TPA).",
          "default": 0,
          "units": "um / W",
          "anyOf": [
            {
              "title": "ComplexNumber",
              "description": "Complex number with a well defined schema.",
              "type": "object",
              "properties": {
                "real": {
                  "title": "Real",
                  "type": "number"
                },
                "imag": {
                  "title": "Imag",
                  "type": "number"
                }
              },
              "required": [
                "real",
                "imag"
              ]
            },
            {
              "$ref": "#/definitions/ComplexNumber"
            }
          ]
        },
        "n0": {
          "title": "Complex linear refractive index",
          "description": "Complex linear refractive index of the medium, computed for instance using 'medium.nk_model'. If not provided, it is calculated automatically using the central frequencies of the simulation sources (as long as these are all equal).",
          "anyOf": [
            {
              "title": "ComplexNumber",
              "description": "Complex number with a well defined schema.",
              "type": "object",
              "properties": {
                "real": {
                  "title": "Real",
                  "type": "number"
                },
                "imag": {
                  "title": "Imag",
                  "type": "number"
                }
              },
              "required": [
                "real",
                "imag"
              ]
            },
            {
              "$ref": "#/definitions/ComplexNumber"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "KerrNonlinearity": {
      "title": "KerrNonlinearity",
      "description": "Model for Kerr nonlinearity which gives an intensity-dependent refractive index\nof the form :math:`n = n_0 + n_2 I`. The expression for the nonlinear polarization\nis given below.\n\nParameters\n----------\nn2 : Union[tidycomplex, ComplexNumber] = 0\n    [units = um^2 / W].  Nonlinear refractive index in the Kerr nonlinearity.\nn0 : Union[tidycomplex, ComplexNumber, NoneType] = None\n    Complex linear refractive index of the medium, computed for instance using 'medium.nk_model'. If not provided, it is calculated automatically using the central frequencies of the simulation sources (as long as these are all equal).\n\nNote\n----\n.. math::\n\n    P_{NL} = \\varepsilon_0 c_0 n_0 \\operatorname{Re}(n_0) n_2 |E|^2 E\n\nNote\n----\nThe fields in this equation are complex-valued, allowing a direct implementation of the Kerr\nnonlinearity. In contrast, the model :class:`.NonlinearSusceptibility` implements a\nchi3 nonlinear susceptibility using real-valued fields, giving rise to Kerr nonlinearity\nas well as third-harmonic generation. The relationship between the parameters is given by\n:math:`n_2 = \\frac{3}{4} \\frac{1}{\\varepsilon_0 c_0 n_0 \\operatorname{Re}(n_0)} \\chi_3`. The additional\nfactor of :math:`\\frac{3}{4}` comes from the usage of complex-valued fields for the Kerr\nnonlinearity and real-valued fields for the nonlinear susceptibility.\n\nNote\n----\nDifferent field components do not interact nonlinearly. For example,\nwhen calculating :math:`P_{NL, x}`, we approximate :math:`|E|^2 \\approx |E_x|^2`.\nThis approximation is valid when the E field is predominantly polarized along one\nof the x, y, or z axes.\n\nExample\n-------\n>>> kerr_model = KerrNonlinearity(n2=1)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "KerrNonlinearity",
          "enum": [
            "KerrNonlinearity"
          ],
          "type": "string"
        },
        "n2": {
          "title": "Nonlinear refractive index",
          "description": "Nonlinear refractive index in the Kerr nonlinearity.",
          "default": 0,
          "units": "um^2 / W",
          "anyOf": [
            {
              "title": "ComplexNumber",
              "description": "Complex number with a well defined schema.",
              "type": "object",
              "properties": {
                "real": {
                  "title": "Real",
                  "type": "number"
                },
                "imag": {
                  "title": "Imag",
                  "type": "number"
                }
              },
              "required": [
                "real",
                "imag"
              ]
            },
            {
              "$ref": "#/definitions/ComplexNumber"
            }
          ]
        },
        "n0": {
          "title": "Complex linear refractive index",
          "description": "Complex linear refractive index of the medium, computed for instance using 'medium.nk_model'. If not provided, it is calculated automatically using the central frequencies of the simulation sources (as long as these are all equal).",
          "anyOf": [
            {
              "title": "ComplexNumber",
              "description": "Complex number with a well defined schema.",
              "type": "object",
              "properties": {
                "real": {
                  "title": "Real",
                  "type": "number"
                },
                "imag": {
                  "title": "Imag",
                  "type": "number"
                }
              },
              "required": [
                "real",
                "imag"
              ]
            },
            {
              "$ref": "#/definitions/ComplexNumber"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "NonlinearSpec": {
      "title": "NonlinearSpec",
      "description": "Abstract specification for adding nonlinearities to a medium.\n\nParameters\n----------\nmodels : Tuple[Union[NonlinearSusceptibility, TwoPhotonAbsorption, KerrNonlinearity], ...] = ()\n    The nonlinear models present in this nonlinear spec. Nonlinear models of different types are additive. Multiple nonlinear models of the same type are not allowed.\nnum_iters : PositiveInt = 5\n    Number of iterations for solving nonlinear constitutive relation.\n\nNote\n----\nThe nonlinear constitutive relation is solved iteratively; it may not converge\nfor strong nonlinearities. Increasing ``num_iters`` can help with convergence.\n\nExample\n-------\n>>> nonlinear_susceptibility = NonlinearSusceptibility(chi3=1)\n>>> nonlinear_spec = NonlinearSpec(models=[nonlinear_susceptibility])\n>>> medium = Medium(permittivity=2, nonlinear_spec=nonlinear_spec)",
      "type": "object",
      "properties": {
        "models": {
          "title": "Nonlinear models",
          "description": "The nonlinear models present in this nonlinear spec. Nonlinear models of different types are additive. Multiple nonlinear models of the same type are not allowed.",
          "default": [],
          "type": "array",
          "items": {
            "anyOf": [
              {
                "$ref": "#/definitions/NonlinearSusceptibility"
              },
              {
                "$ref": "#/definitions/TwoPhotonAbsorption"
              },
              {
                "$ref": "#/definitions/KerrNonlinearity"
              }
            ]
          }
        },
        "num_iters": {
          "title": "Number of iterations",
          "description": "Number of iterations for solving nonlinear constitutive relation.",
          "default": 5,
          "exclusiveMinimum": 0,
          "type": "integer"
        },
        "type": {
          "title": "Type",
          "default": "NonlinearSpec",
          "enum": [
            "NonlinearSpec"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "SpaceModulation": {
      "title": "SpaceModulation",
      "description": "The modulation profile with a user-supplied spatial distribution of\namplitude and phase.\n\nParameters\n----------\namplitude : Union[float, SpatialDataArray] = 1\n    Amplitude of modulation that can vary spatially. It takes the unit of whatever is being modulated.\nphase : Union[float, SpatialDataArray] = 0\n    [units = rad].  Phase of modulation that can vary spatially.\ninterp_method : Literal['nearest', 'linear'] = nearest\n    Method of interpolation to use to obtain values at spatial locations on the Yee grids.\n\nNote\n----\n.. math::\n\n    amp\\_space(r) = amplitude(r) \\cdot e^{i \\cdot phase(r)}\n\nThe full space-time modulation is,\n\n.. math::\n\n    amp(r, t) = \\Re[amp\\_time(t) \\cdot amp\\_space(r)]\n\nExample\n-------\n>>> Nx, Ny, Nz = 10, 9, 8\n>>> X = np.linspace(-1, 1, Nx)\n>>> Y = np.linspace(-1, 1, Ny)\n>>> Z = np.linspace(-1, 1, Nz)\n>>> coords = dict(x=X, y=Y, z=Z)\n>>> amp = SpatialDataArray(np.random.random((Nx, Ny, Nz)), coords=coords)\n>>> phase = SpatialDataArray(np.random.random((Nx, Ny, Nz)), coords=coords)\n>>> space = SpaceModulation(amplitude=amp, phase=phase)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "SpaceModulation",
          "enum": [
            "SpaceModulation"
          ],
          "type": "string"
        },
        "amplitude": {
          "title": "Amplitude of modulation in space",
          "description": "Amplitude of modulation that can vary spatially. It takes the unit of whatever is being modulated.",
          "default": 1,
          "anyOf": [
            {
              "type": "number"
            },
            {
              "title": "DataArray",
              "type": "xr.DataArray",
              "properties": {
                "_dims": {
                  "title": "_dims",
                  "type": "Tuple[str, ...]"
                }
              },
              "required": [
                "_dims"
              ]
            }
          ]
        },
        "phase": {
          "title": "Phase of modulation in space",
          "description": "Phase of modulation that can vary spatially.",
          "default": 0,
          "units": "rad",
          "anyOf": [
            {
              "type": "number"
            },
            {
              "title": "DataArray",
              "type": "xr.DataArray",
              "properties": {
                "_dims": {
                  "title": "_dims",
                  "type": "Tuple[str, ...]"
                }
              },
              "required": [
                "_dims"
              ]
            }
          ]
        },
        "interp_method": {
          "title": "Interpolation method",
          "description": "Method of interpolation to use to obtain values at spatial locations on the Yee grids.",
          "default": "nearest",
          "enum": [
            "nearest",
            "linear"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "ContinuousWaveTimeModulation": {
      "title": "ContinuousWaveTimeModulation",
      "description": "Class describing modulation with a harmonic time dependence.\n\nParameters\n----------\namplitude : NonNegativeFloat = 1.0\n    Real-valued maximum amplitude of the time dependence.\nphase : float = 0.0\n    [units = rad].  Phase shift of the time dependence.\nfreq0 : PositiveFloat\n    [units = Hz].  Modulation frequency.\n\nNote\n----\n.. math::\n\n    amp\\_time(t) = amplitude \\cdot \\\n            e^{i \\cdot phase - 2 \\pi i \\cdot freq0 \\cdot t}\n\nNote\n----\nThe full space-time modulation is,\n\n.. math::\n\n    amp(r, t) = \\Re[amp\\_time(t) \\cdot amp\\_space(r)]\n\n\nExample\n-------\n>>> cw = ContinuousWaveTimeModulation(freq0=200e12, amplitude=1, phase=0)",
      "type": "object",
      "properties": {
        "amplitude": {
          "title": "Amplitude",
          "description": "Real-valued maximum amplitude of the time dependence.",
          "default": 1.0,
          "minimum": 0,
          "type": "number"
        },
        "phase": {
          "title": "Phase",
          "description": "Phase shift of the time dependence.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "type": {
          "title": "Type",
          "default": "ContinuousWaveTimeModulation",
          "enum": [
            "ContinuousWaveTimeModulation"
          ],
          "type": "string"
        },
        "freq0": {
          "title": "Modulation Frequency",
          "description": "Modulation frequency.",
          "units": "Hz",
          "exclusiveMinimum": 0,
          "type": "number"
        }
      },
      "required": [
        "freq0"
      ],
      "additionalProperties": false
    },
    "SpaceTimeModulation": {
      "title": "SpaceTimeModulation",
      "description": "Space-time modulation applied to a medium, adding\non top of the time-independent part.\n\nParameters\n----------\nspace_modulation : SpaceModulation = SpaceModulation(type='SpaceModulation', amplitude=1.0, phase=0.0, interp_method='nearest')\n    Space modulation part from the separable SpaceTimeModulation.\ntime_modulation : ContinuousWaveTimeModulation\n    Time modulation part from the separable SpaceTimeModulation.\n\n\nNote\n----\nThe space-time modulation must be separable in space and time.\ne.g. when applied to permittivity,\n\n.. math::\n\n    \\delta \\epsilon(r, t) = \\Re[amp\\_time(t) \\cdot amp\\_space(r)]",
      "type": "object",
      "properties": {
        "space_modulation": {
          "title": "Space modulation",
          "description": "Space modulation part from the separable SpaceTimeModulation.",
          "default": {
            "type": "SpaceModulation",
            "amplitude": 1.0,
            "phase": 0.0,
            "interp_method": "nearest"
          },
          "allOf": [
            {
              "$ref": "#/definitions/SpaceModulation"
            }
          ]
        },
        "time_modulation": {
          "title": "Time modulation",
          "description": "Time modulation part from the separable SpaceTimeModulation.",
          "allOf": [
            {
              "$ref": "#/definitions/ContinuousWaveTimeModulation"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "SpaceTimeModulation",
          "enum": [
            "SpaceTimeModulation"
          ],
          "type": "string"
        }
      },
      "required": [
        "time_modulation"
      ],
      "additionalProperties": false
    },
    "ModulationSpec": {
      "title": "ModulationSpec",
      "description": "Specification adding space-time modulation to the non-dispersive part of medium\nincluding relative permittivity at infinite frequency and electric conductivity.\n\n\nParameters\n----------\npermittivity : Optional[SpaceTimeModulation] = None\n    Space-time modulation of relative permittivity at infinite frequency applied on top of the base permittivity at infinite frequency.\nconductivity : Optional[SpaceTimeModulation] = None\n    Space-time modulation of electric conductivity applied on top of the base conductivity.",
      "type": "object",
      "properties": {
        "permittivity": {
          "title": "Space-time modulation of relative permittivity",
          "description": "Space-time modulation of relative permittivity at infinite frequency applied on top of the base permittivity at infinite frequency.",
          "allOf": [
            {
              "$ref": "#/definitions/SpaceTimeModulation"
            }
          ]
        },
        "conductivity": {
          "title": "Space-time modulation of conductivity",
          "description": "Space-time modulation of electric conductivity applied on top of the base conductivity.",
          "allOf": [
            {
              "$ref": "#/definitions/SpaceTimeModulation"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "ModulationSpec",
          "enum": [
            "ModulationSpec"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "FluidSpec": {
      "title": "FluidSpec",
      "description": "Fluid medium.\n\nParameters\n----------\n\nExample\n-------\n>>> solid = FluidSpec()",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "FluidSpec",
          "enum": [
            "FluidSpec"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "SolidSpec": {
      "title": "SolidSpec",
      "description": "Solid medium.\n\nParameters\n----------\ncapacity : PositiveFloat\n    [units = J/(kg*K)].  Volumetric heat capacity in unit of J/(kg*K).\nconductivity : PositiveFloat\n    [units = W/(um*K)].  Thermal conductivity of material in units of W/(um*K).\n\nExample\n-------\n>>> solid = SolidSpec(\n...     capacity=2,\n...     conductivity=3,\n... )",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "SolidSpec",
          "enum": [
            "SolidSpec"
          ],
          "type": "string"
        },
        "capacity": {
          "title": "Heat capacity",
          "description": "Volumetric heat capacity in unit of J/(kg*K).",
          "units": "J/(kg*K)",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "conductivity": {
          "title": "Thermal conductivity",
          "description": "Thermal conductivity of material in units of W/(um*K).",
          "units": "W/(um*K)",
          "exclusiveMinimum": 0,
          "type": "number"
        }
      },
      "required": [
        "capacity",
        "conductivity"
      ],
      "additionalProperties": false
    },
    "Medium": {
      "title": "Medium",
      "description": "Dispersionless medium.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\npermittivity : ConstrainedFloatValue = 1.0\n    [units = None (relative permittivity)].  Relative permittivity.\nconductivity : float = 0.0\n    [units = S/um].  Electric conductivity. Defined such that the imaginary part of the complex permittivity at angular frequency omega is given by conductivity/omega.\n\nExample\n-------\n>>> dielectric = Medium(permittivity=4.0, name='my_medium')\n>>> eps = dielectric.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Medium",
          "enum": [
            "Medium"
          ],
          "type": "string"
        },
        "permittivity": {
          "title": "Permittivity",
          "description": "Relative permittivity.",
          "default": 1.0,
          "minimum": 1.0,
          "units": "None (relative permittivity)",
          "type": "number"
        },
        "conductivity": {
          "title": "Conductivity",
          "description": "Electric conductivity. Defined such that the imaginary part of the complex permittivity at angular frequency omega is given by conductivity/omega.",
          "default": 0.0,
          "units": "S/um",
          "type": "number"
        }
      },
      "additionalProperties": false
    },
    "PoleResidue": {
      "title": "PoleResidue",
      "description": "A dispersive medium described by the pole-residue pair model.\nThe frequency-dependence of the complex-valued permittivity is described by:\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\neps_inf : PositiveFloat = 1.0\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\npoles : Tuple[Tuple[Union[tidy3d.components.types.tidycomplex, tidy3d.components.types.ComplexNumber], Union[tidy3d.components.types.tidycomplex, tidy3d.components.types.ComplexNumber]], ...] = ()\n    [units = (rad/sec, rad/sec)].  Tuple of complex-valued (:math:`a_i, c_i`) poles for the model.\n\nNote\n----\n.. math::\n\n    \\epsilon(\\omega) = \\epsilon_\\infty - \\sum_i\n    \\left[\\frac{c_i}{j \\omega + a_i} +\n    \\frac{c_i^*}{j \\omega + a_i^*}\\right]\n\nExample\n-------\n>>> pole_res = PoleResidue(eps_inf=2.0, poles=[((-1+2j), (3+4j)), ((-5+6j), (7+8j))])\n>>> eps = pole_res.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "PoleResidue",
          "enum": [
            "PoleResidue"
          ],
          "type": "string"
        },
        "eps_inf": {
          "title": "Epsilon at Infinity",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "default": 1.0,
          "units": "None (relative permittivity)",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "poles": {
          "title": "Poles",
          "description": "Tuple of complex-valued (:math:`a_i, c_i`) poles for the model.",
          "default": [],
          "units": [
            "rad/sec",
            "rad/sec"
          ],
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "anyOf": [
                  {
                    "title": "ComplexNumber",
                    "description": "Complex number with a well defined schema.",
                    "type": "object",
                    "properties": {
                      "real": {
                        "title": "Real",
                        "type": "number"
                      },
                      "imag": {
                        "title": "Imag",
                        "type": "number"
                      }
                    },
                    "required": [
                      "real",
                      "imag"
                    ]
                  },
                  {
                    "$ref": "#/definitions/ComplexNumber"
                  }
                ]
              },
              {
                "anyOf": [
                  {
                    "title": "ComplexNumber",
                    "description": "Complex number with a well defined schema.",
                    "type": "object",
                    "properties": {
                      "real": {
                        "title": "Real",
                        "type": "number"
                      },
                      "imag": {
                        "title": "Imag",
                        "type": "number"
                      }
                    },
                    "required": [
                      "real",
                      "imag"
                    ]
                  },
                  {
                    "$ref": "#/definitions/ComplexNumber"
                  }
                ]
              }
            ]
          }
        }
      },
      "additionalProperties": false
    },
    "Sellmeier": {
      "title": "Sellmeier",
      "description": "A dispersive medium described by the Sellmeier model.\nThe frequency-dependence of the refractive index is described by:\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\ncoeffs : Tuple[Tuple[float, pydantic.v1.types.PositiveFloat], ...]\n    [units = (None, um^2)].  List of Sellmeier (:math:`B_i, C_i`) coefficients.\n\nNote\n----\n.. math::\n\n    n(\\lambda)^2 = 1 + \\sum_i \\frac{B_i \\lambda^2}{\\lambda^2 - C_i}\n\nExample\n-------\n>>> sellmeier_medium = Sellmeier(coeffs=[(1,2), (3,4)])\n>>> eps = sellmeier_medium.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Sellmeier",
          "enum": [
            "Sellmeier"
          ],
          "type": "string"
        },
        "coeffs": {
          "title": "Coefficients",
          "description": "List of Sellmeier (:math:`B_i, C_i`) coefficients.",
          "units": [
            null,
            "um^2"
          ],
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "type": "number"
              },
              {
                "type": "number",
                "exclusiveMinimum": 0
              }
            ]
          }
        }
      },
      "required": [
        "coeffs"
      ],
      "additionalProperties": false
    },
    "Lorentz": {
      "title": "Lorentz",
      "description": "A dispersive medium described by the Lorentz model.\nThe frequency-dependence of the complex-valued permittivity is described by:\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\neps_inf : PositiveFloat = 1.0\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\ncoeffs : Tuple[Tuple[float, float, pydantic.v1.types.NonNegativeFloat], ...]\n    [units = (None (relative permittivity), Hz, Hz)].  List of (:math:`\\Delta\\epsilon_i, f_i, \\delta_i`) values for model.\n\nNote\n----\n.. math::\n\n    \\epsilon(f) = \\epsilon_\\infty + \\sum_i\n    \\frac{\\Delta\\epsilon_i f_i^2}{f_i^2 - 2jf\\delta_i - f^2}\n\nExample\n-------\n>>> lorentz_medium = Lorentz(eps_inf=2.0, coeffs=[(1,2,3), (4,5,6)])\n>>> eps = lorentz_medium.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Lorentz",
          "enum": [
            "Lorentz"
          ],
          "type": "string"
        },
        "eps_inf": {
          "title": "Epsilon at Infinity",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "default": 1.0,
          "units": "None (relative permittivity)",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "coeffs": {
          "title": "Coefficients",
          "description": "List of (:math:`\\Delta\\epsilon_i, f_i, \\delta_i`) values for model.",
          "units": [
            "None (relative permittivity)",
            "Hz",
            "Hz"
          ],
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 3,
            "maxItems": 3,
            "items": [
              {
                "type": "number"
              },
              {
                "type": "number"
              },
              {
                "type": "number",
                "minimum": 0
              }
            ]
          }
        }
      },
      "required": [
        "coeffs"
      ],
      "additionalProperties": false
    },
    "Debye": {
      "title": "Debye",
      "description": "A dispersive medium described by the Debye model.\nThe frequency-dependence of the complex-valued permittivity is described by:\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\neps_inf : PositiveFloat = 1.0\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\ncoeffs : Tuple[Tuple[float, pydantic.v1.types.PositiveFloat], ...]\n    [units = (None (relative permittivity), sec)].  List of (:math:`\\Delta\\epsilon_i, \\tau_i`) values for model.\n\nNote\n----\n.. math::\n\n    \\epsilon(f) = \\epsilon_\\infty + \\sum_i\n    \\frac{\\Delta\\epsilon_i}{1 - jf\\tau_i}\n\nExample\n-------\n>>> debye_medium = Debye(eps_inf=2.0, coeffs=[(1,2),(3,4)])\n>>> eps = debye_medium.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Debye",
          "enum": [
            "Debye"
          ],
          "type": "string"
        },
        "eps_inf": {
          "title": "Epsilon at Infinity",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "default": 1.0,
          "units": "None (relative permittivity)",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "coeffs": {
          "title": "Coefficients",
          "description": "List of (:math:`\\Delta\\epsilon_i, \\tau_i`) values for model.",
          "units": [
            "None (relative permittivity)",
            "sec"
          ],
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "type": "number"
              },
              {
                "type": "number",
                "exclusiveMinimum": 0
              }
            ]
          }
        }
      },
      "required": [
        "coeffs"
      ],
      "additionalProperties": false
    },
    "Drude": {
      "title": "Drude",
      "description": "A dispersive medium described by the Drude model.\nThe frequency-dependence of the complex-valued permittivity is described by:\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\neps_inf : PositiveFloat = 1.0\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\ncoeffs : Tuple[Tuple[float, pydantic.v1.types.PositiveFloat], ...]\n    [units = (Hz, Hz)].  List of (:math:`f_i, \\delta_i`) values for model.\n\nNote\n----\n.. math::\n\n    \\epsilon(f) = \\epsilon_\\infty - \\sum_i\n    \\frac{ f_i^2}{f^2 + jf\\delta_i}\n\nExample\n-------\n>>> drude_medium = Drude(eps_inf=2.0, coeffs=[(1,2), (3,4)])\n>>> eps = drude_medium.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Drude",
          "enum": [
            "Drude"
          ],
          "type": "string"
        },
        "eps_inf": {
          "title": "Epsilon at Infinity",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "default": 1.0,
          "units": "None (relative permittivity)",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "coeffs": {
          "title": "Coefficients",
          "description": "List of (:math:`f_i, \\delta_i`) values for model.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "type": "number"
              },
              {
                "type": "number",
                "exclusiveMinimum": 0
              }
            ]
          }
        }
      },
      "required": [
        "coeffs"
      ],
      "additionalProperties": false
    },
    "PECMedium": {
      "title": "PECMedium",
      "description": "Perfect electrical conductor class.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\n\nNote\n----\nTo avoid confusion from duplicate PECs, must import ``tidy3d.PEC`` instance directly.",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "PECMedium",
          "enum": [
            "PECMedium"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "AnisotropicMedium": {
      "title": "AnisotropicMedium",
      "description": "Diagonally anisotropic medium.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : Optional[bool] = None\n    This field is ignored. Please set ``allow_gain`` in each component\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\nxx : Union[Medium, PoleResidue, Sellmeier, Lorentz, Debye, Drude, PECMedium]\n    Medium describing the xx-component of the diagonal permittivity tensor.\nyy : Union[Medium, PoleResidue, Sellmeier, Lorentz, Debye, Drude, PECMedium]\n    Medium describing the yy-component of the diagonal permittivity tensor.\nzz : Union[Medium, PoleResidue, Sellmeier, Lorentz, Debye, Drude, PECMedium]\n    Medium describing the zz-component of the diagonal permittivity tensor.\n\nNote\n----\nOnly diagonal anisotropy is currently supported.\n\nExample\n-------\n>>> medium_xx = Medium(permittivity=4.0)\n>>> medium_yy = Medium(permittivity=4.1)\n>>> medium_zz = Medium(permittivity=3.9)\n>>> anisotropic_dielectric = AnisotropicMedium(xx=medium_xx, yy=medium_yy, zz=medium_zz)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "This field is ignored. Please set ``allow_gain`` in each component",
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "AnisotropicMedium",
          "enum": [
            "AnisotropicMedium"
          ],
          "type": "string"
        },
        "xx": {
          "title": "XX Component",
          "description": "Medium describing the xx-component of the diagonal permittivity tensor.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "Medium": "#/definitions/Medium",
              "PoleResidue": "#/definitions/PoleResidue",
              "Sellmeier": "#/definitions/Sellmeier",
              "Lorentz": "#/definitions/Lorentz",
              "Debye": "#/definitions/Debye",
              "Drude": "#/definitions/Drude",
              "PECMedium": "#/definitions/PECMedium"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/Medium"
            },
            {
              "$ref": "#/definitions/PoleResidue"
            },
            {
              "$ref": "#/definitions/Sellmeier"
            },
            {
              "$ref": "#/definitions/Lorentz"
            },
            {
              "$ref": "#/definitions/Debye"
            },
            {
              "$ref": "#/definitions/Drude"
            },
            {
              "$ref": "#/definitions/PECMedium"
            }
          ]
        },
        "yy": {
          "title": "YY Component",
          "description": "Medium describing the yy-component of the diagonal permittivity tensor.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "Medium": "#/definitions/Medium",
              "PoleResidue": "#/definitions/PoleResidue",
              "Sellmeier": "#/definitions/Sellmeier",
              "Lorentz": "#/definitions/Lorentz",
              "Debye": "#/definitions/Debye",
              "Drude": "#/definitions/Drude",
              "PECMedium": "#/definitions/PECMedium"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/Medium"
            },
            {
              "$ref": "#/definitions/PoleResidue"
            },
            {
              "$ref": "#/definitions/Sellmeier"
            },
            {
              "$ref": "#/definitions/Lorentz"
            },
            {
              "$ref": "#/definitions/Debye"
            },
            {
              "$ref": "#/definitions/Drude"
            },
            {
              "$ref": "#/definitions/PECMedium"
            }
          ]
        },
        "zz": {
          "title": "ZZ Component",
          "description": "Medium describing the zz-component of the diagonal permittivity tensor.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "Medium": "#/definitions/Medium",
              "PoleResidue": "#/definitions/PoleResidue",
              "Sellmeier": "#/definitions/Sellmeier",
              "Lorentz": "#/definitions/Lorentz",
              "Debye": "#/definitions/Debye",
              "Drude": "#/definitions/Drude",
              "PECMedium": "#/definitions/PECMedium"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/Medium"
            },
            {
              "$ref": "#/definitions/PoleResidue"
            },
            {
              "$ref": "#/definitions/Sellmeier"
            },
            {
              "$ref": "#/definitions/Lorentz"
            },
            {
              "$ref": "#/definitions/Debye"
            },
            {
              "$ref": "#/definitions/Drude"
            },
            {
              "$ref": "#/definitions/PECMedium"
            }
          ]
        }
      },
      "required": [
        "xx",
        "yy",
        "zz"
      ],
      "additionalProperties": false
    },
    "FullyAnisotropicMedium": {
      "title": "FullyAnisotropicMedium",
      "description": "Fully anisotropic medium including all 9 components of the permittivity and conductivity\ntensors. Provided permittivity tensor and the symmetric part of the conductivity tensor must\nhave coinciding main directions. A non-symmetric conductivity tensor can be used to model\nmagneto-optic effects. Note that dispersive properties and subpixel averaging are currently not\nsupported for fully anisotropic materials.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\npermittivity : ArrayLike[dtype=float, ndim=2, shape=(3, 3)] = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    [units = None (relative permittivity)].  Relative permittivity tensor.\nconductivity : ArrayLike[dtype=float, ndim=2, shape=(3, 3)] = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    [units = S/um].  Electric conductivity tensor. Defined such that the imaginary part of the complex permittivity at angular frequency omega is given by conductivity/omega.\n\nNote\n----\nSimulations involving fully anisotropic materials are computationally more intensive, thus,\nthey take longer time to complete. This increase strongly depends on the filling fraction of\nthe simulation domain by fully anisotropic materials, varying approximately in the range from\n1.5 to 5. Cost of running a simulation is adjusted correspondingly.\n\nExample\n-------\n>>> perm = [[2, 0, 0], [0, 1, 0], [0, 0, 3]]\n>>> cond = [[0.1, 0, 0], [0, 0, 0], [0, 0, 0]]\n>>> anisotropic_dielectric = FullyAnisotropicMedium(permittivity=perm, conductivity=cond)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "FullyAnisotropicMedium",
          "enum": [
            "FullyAnisotropicMedium"
          ],
          "type": "string"
        },
        "permittivity": {
          "title": "Permittivity",
          "description": "Relative permittivity tensor.",
          "default": [
            [
              1,
              0,
              0
            ],
            [
              0,
              1,
              0
            ],
            [
              0,
              0,
              1
            ]
          ],
          "units": "None (relative permittivity)",
          "type": "ArrayLike"
        },
        "conductivity": {
          "title": "Conductivity",
          "description": "Electric conductivity tensor. Defined such that the imaginary part of the complex permittivity at angular frequency omega is given by conductivity/omega.",
          "default": [
            [
              0,
              0,
              0
            ],
            [
              0,
              0,
              0
            ],
            [
              0,
              0,
              0
            ]
          ],
          "units": "S/um",
          "type": "ArrayLike"
        }
      },
      "additionalProperties": false
    },
    "PermittivityDataset": {
      "title": "PermittivityDataset",
      "description": "Dataset storing the diagonal components of the permittivity tensor.\n\nParameters\n----------\neps_xx : ScalarFieldDataArray\n    Spatial distribution of the xx-component of the relative permittivity.\neps_yy : ScalarFieldDataArray\n    Spatial distribution of the yy-component of the relative permittivity.\neps_zz : ScalarFieldDataArray\n    Spatial distribution of the zz-component of the relative permittivity.\n\nExample\n-------\n>>> x = [-1,1]\n>>> y = [-2,0,2]\n>>> z = [-3,-1,1,3]\n>>> f = [2e14, 3e14]\n>>> coords = dict(x=x, y=y, z=z, f=f)\n>>> sclr_fld = ScalarFieldDataArray((1+1j) * np.random.random((2,3,4,2)), coords=coords)\n>>> data = PermittivityDataset(eps_xx=sclr_fld, eps_yy=sclr_fld, eps_zz=sclr_fld)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "PermittivityDataset",
          "enum": [
            "PermittivityDataset"
          ],
          "type": "string"
        },
        "eps_xx": {
          "title": "DataArray",
          "description": "Spatial distribution of the xx-component of the relative permittivity.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "eps_yy": {
          "title": "DataArray",
          "description": "Spatial distribution of the yy-component of the relative permittivity.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "eps_zz": {
          "title": "DataArray",
          "description": "Spatial distribution of the zz-component of the relative permittivity.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        }
      },
      "required": [
        "eps_xx",
        "eps_yy",
        "eps_zz"
      ],
      "additionalProperties": false
    },
    "CustomMedium": {
      "title": "CustomMedium",
      "description": ":class:`.Medium` with user-supplied permittivity distribution.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\ninterp_method : Literal['nearest', 'linear'] = nearest\n    Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.\nsubpixel : bool = False\n    If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.\neps_dataset : Optional[PermittivityDataset] = None\n    [To be deprecated] User-supplied dataset containing complex-valued permittivity as a function of space. Permittivity distribution over the Yee-grid will be interpolated based on ``interp_method``.\npermittivity : Optional[SpatialDataArray] = None\n    [units = None (relative permittivity)].  Spatial profile of relative permittivity.\nconductivity : Optional[SpatialDataArray] = None\n    [units = S/um].  Spatial profile Electric conductivity. Defined such that the imaginary part of the complex permittivity at angular frequency omega is given by conductivity/omega.\n\nExample\n-------\n>>> Nx, Ny, Nz = 10, 9, 8\n>>> X = np.linspace(-1, 1, Nx)\n>>> Y = np.linspace(-1, 1, Ny)\n>>> Z = np.linspace(-1, 1, Nz)\n>>> coords = dict(x=X, y=Y, z=Z)\n>>> permittivity= SpatialDataArray(np.ones((Nx, Ny, Nz)), coords=coords)\n>>> conductivity= SpatialDataArray(np.ones((Nx, Ny, Nz)), coords=coords)\n>>> dielectric = CustomMedium(permittivity=permittivity, conductivity=conductivity)\n>>> eps = dielectric.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "CustomMedium",
          "enum": [
            "CustomMedium"
          ],
          "type": "string"
        },
        "interp_method": {
          "title": "Interpolation method",
          "description": "Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.",
          "default": "nearest",
          "enum": [
            "nearest",
            "linear"
          ],
          "type": "string"
        },
        "subpixel": {
          "title": "Subpixel averaging",
          "description": "If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.",
          "default": false,
          "type": "boolean"
        },
        "eps_dataset": {
          "title": "Permittivity Dataset",
          "description": "[To be deprecated] User-supplied dataset containing complex-valued permittivity as a function of space. Permittivity distribution over the Yee-grid will be interpolated based on ``interp_method``.",
          "allOf": [
            {
              "$ref": "#/definitions/PermittivityDataset"
            }
          ]
        },
        "permittivity": {
          "title": "DataArray",
          "description": "Spatial profile of relative permittivity.",
          "units": "None (relative permittivity)",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "conductivity": {
          "title": "DataArray",
          "description": "Spatial profile Electric conductivity. Defined such that the imaginary part of the complex permittivity at angular frequency omega is given by conductivity/omega.",
          "units": "S/um",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        }
      },
      "additionalProperties": false
    },
    "CustomPoleResidue": {
      "title": "CustomPoleResidue",
      "description": "A spatially varying dispersive medium described by the pole-residue pair model.\nThe frequency-dependence of the complex-valued permittivity is described by:\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\neps_inf : SpatialDataArray\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\npoles : Tuple[Tuple[tidy3d.components.data.data_array.SpatialDataArray, tidy3d.components.data.data_array.SpatialDataArray], ...] = ()\n    [units = (rad/sec, rad/sec)].  Tuple of complex-valued (:math:`a_i, c_i`) poles for the model.\ninterp_method : Literal['nearest', 'linear'] = nearest\n    Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.\nsubpixel : bool = False\n    If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.\n\nNote\n----\n.. math::\n\n    \\epsilon(\\omega) = \\epsilon_\\infty - \\sum_i\n    \\left[\\frac{c_i}{j \\omega + a_i} +\n    \\frac{c_i^*}{j \\omega + a_i^*}\\right]\n\nExample\n-------\n>>> x = np.linspace(-1, 1, 5)\n>>> y = np.linspace(-1, 1, 6)\n>>> z = np.linspace(-1, 1, 7)\n>>> coords = dict(x=x, y=y, z=z)\n>>> eps_inf = SpatialDataArray(np.ones((5, 6, 7)), coords=coords)\n>>> a1 = SpatialDataArray(-np.random.random((5, 6, 7)), coords=coords)\n>>> c1 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> a2 = SpatialDataArray(-np.random.random((5, 6, 7)), coords=coords)\n>>> c2 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> pole_res = CustomPoleResidue(eps_inf=eps_inf, poles=[(a1, c1), (a2, c2)])\n>>> eps = pole_res.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "CustomPoleResidue",
          "enum": [
            "CustomPoleResidue"
          ],
          "type": "string"
        },
        "eps_inf": {
          "title": "DataArray",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "units": "None (relative permittivity)",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "poles": {
          "title": "Poles",
          "description": "Tuple of complex-valued (:math:`a_i, c_i`) poles for the model.",
          "default": [],
          "units": [
            "rad/sec",
            "rad/sec"
          ],
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "title": "DataArray",
                "type": "xr.DataArray",
                "properties": {
                  "_dims": {
                    "title": "_dims",
                    "type": "Tuple[str, ...]"
                  }
                },
                "required": [
                  "_dims"
                ]
              },
              {
                "title": "DataArray",
                "type": "xr.DataArray",
                "properties": {
                  "_dims": {
                    "title": "_dims",
                    "type": "Tuple[str, ...]"
                  }
                },
                "required": [
                  "_dims"
                ]
              }
            ]
          }
        },
        "interp_method": {
          "title": "Interpolation method",
          "description": "Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.",
          "default": "nearest",
          "enum": [
            "nearest",
            "linear"
          ],
          "type": "string"
        },
        "subpixel": {
          "title": "Subpixel averaging",
          "description": "If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.",
          "default": false,
          "type": "boolean"
        }
      },
      "required": [
        "eps_inf"
      ],
      "additionalProperties": false
    },
    "CustomSellmeier": {
      "title": "CustomSellmeier",
      "description": "A spatially varying dispersive medium described by the Sellmeier model.\nThe frequency-dependence of the refractive index is described by:\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\ncoeffs : Tuple[Tuple[tidy3d.components.data.data_array.SpatialDataArray, tidy3d.components.data.data_array.SpatialDataArray], ...]\n    [units = (None, um^2)].  List of Sellmeier (:math:`B_i, C_i`) coefficients.\ninterp_method : Literal['nearest', 'linear'] = nearest\n    Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.\nsubpixel : bool = False\n    If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.\n\nNote\n----\n.. math::\n\n    n(\\lambda)^2 = 1 + \\sum_i \\frac{B_i \\lambda^2}{\\lambda^2 - C_i}\n\nExample\n-------\n>>> x = np.linspace(-1, 1, 5)\n>>> y = np.linspace(-1, 1, 6)\n>>> z = np.linspace(-1, 1, 7)\n>>> coords = dict(x=x, y=y, z=z)\n>>> b1 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> c1 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> sellmeier_medium = CustomSellmeier(coeffs=[(b1,c1),])\n>>> eps = sellmeier_medium.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "CustomSellmeier",
          "enum": [
            "CustomSellmeier"
          ],
          "type": "string"
        },
        "coeffs": {
          "title": "Coefficients",
          "description": "List of Sellmeier (:math:`B_i, C_i`) coefficients.",
          "units": [
            null,
            "um^2"
          ],
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "title": "DataArray",
                "type": "xr.DataArray",
                "properties": {
                  "_dims": {
                    "title": "_dims",
                    "type": "Tuple[str, ...]"
                  }
                },
                "required": [
                  "_dims"
                ]
              },
              {
                "title": "DataArray",
                "type": "xr.DataArray",
                "properties": {
                  "_dims": {
                    "title": "_dims",
                    "type": "Tuple[str, ...]"
                  }
                },
                "required": [
                  "_dims"
                ]
              }
            ]
          }
        },
        "interp_method": {
          "title": "Interpolation method",
          "description": "Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.",
          "default": "nearest",
          "enum": [
            "nearest",
            "linear"
          ],
          "type": "string"
        },
        "subpixel": {
          "title": "Subpixel averaging",
          "description": "If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.",
          "default": false,
          "type": "boolean"
        }
      },
      "required": [
        "coeffs"
      ],
      "additionalProperties": false
    },
    "CustomLorentz": {
      "title": "CustomLorentz",
      "description": "A spatially varying dispersive medium described by the Lorentz model.\nThe frequency-dependence of the complex-valued permittivity is described by:\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\neps_inf : SpatialDataArray\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\ncoeffs : Tuple[Tuple[tidy3d.components.data.data_array.SpatialDataArray, tidy3d.components.data.data_array.SpatialDataArray, tidy3d.components.data.data_array.SpatialDataArray], ...]\n    [units = (None (relative permittivity), Hz, Hz)].  List of (:math:`\\Delta\\epsilon_i, f_i, \\delta_i`) values for model.\ninterp_method : Literal['nearest', 'linear'] = nearest\n    Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.\nsubpixel : bool = False\n    If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.\n\nNote\n----\n.. math::\n\n    \\epsilon(f) = \\epsilon_\\infty + \\sum_i\n    \\frac{\\Delta\\epsilon_i f_i^2}{f_i^2 - 2jf\\delta_i - f^2}\n\nExample\n-------\n>>> x = np.linspace(-1, 1, 5)\n>>> y = np.linspace(-1, 1, 6)\n>>> z = np.linspace(-1, 1, 7)\n>>> coords = dict(x=x, y=y, z=z)\n>>> eps_inf = SpatialDataArray(np.ones((5, 6, 7)), coords=coords)\n>>> d_epsilon = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> f = SpatialDataArray(1+np.random.random((5, 6, 7)), coords=coords)\n>>> delta = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> lorentz_medium = CustomLorentz(eps_inf=eps_inf, coeffs=[(d_epsilon,f,delta),])\n>>> eps = lorentz_medium.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "CustomLorentz",
          "enum": [
            "CustomLorentz"
          ],
          "type": "string"
        },
        "eps_inf": {
          "title": "DataArray",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "units": "None (relative permittivity)",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "coeffs": {
          "title": "Coefficients",
          "description": "List of (:math:`\\Delta\\epsilon_i, f_i, \\delta_i`) values for model.",
          "units": [
            "None (relative permittivity)",
            "Hz",
            "Hz"
          ],
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 3,
            "maxItems": 3,
            "items": [
              {
                "title": "DataArray",
                "type": "xr.DataArray",
                "properties": {
                  "_dims": {
                    "title": "_dims",
                    "type": "Tuple[str, ...]"
                  }
                },
                "required": [
                  "_dims"
                ]
              },
              {
                "title": "DataArray",
                "type": "xr.DataArray",
                "properties": {
                  "_dims": {
                    "title": "_dims",
                    "type": "Tuple[str, ...]"
                  }
                },
                "required": [
                  "_dims"
                ]
              },
              {
                "title": "DataArray",
                "type": "xr.DataArray",
                "properties": {
                  "_dims": {
                    "title": "_dims",
                    "type": "Tuple[str, ...]"
                  }
                },
                "required": [
                  "_dims"
                ]
              }
            ]
          }
        },
        "interp_method": {
          "title": "Interpolation method",
          "description": "Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.",
          "default": "nearest",
          "enum": [
            "nearest",
            "linear"
          ],
          "type": "string"
        },
        "subpixel": {
          "title": "Subpixel averaging",
          "description": "If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.",
          "default": false,
          "type": "boolean"
        }
      },
      "required": [
        "eps_inf",
        "coeffs"
      ],
      "additionalProperties": false
    },
    "CustomDebye": {
      "title": "CustomDebye",
      "description": "A spatially varying dispersive medium described by the Debye model.\nThe frequency-dependence of the complex-valued permittivity is described by:\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\neps_inf : SpatialDataArray\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\ncoeffs : Tuple[Tuple[tidy3d.components.data.data_array.SpatialDataArray, tidy3d.components.data.data_array.SpatialDataArray], ...]\n    [units = (None (relative permittivity), sec)].  List of (:math:`\\Delta\\epsilon_i, \\tau_i`) values for model.\ninterp_method : Literal['nearest', 'linear'] = nearest\n    Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.\nsubpixel : bool = False\n    If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.\n\nNote\n----\n.. math::\n\n    \\epsilon(f) = \\epsilon_\\infty + \\sum_i\n    \\frac{\\Delta\\epsilon_i}{1 - jf\\tau_i}\n\nExample\n-------\n>>> x = np.linspace(-1, 1, 5)\n>>> y = np.linspace(-1, 1, 6)\n>>> z = np.linspace(-1, 1, 7)\n>>> coords = dict(x=x, y=y, z=z)\n>>> eps_inf = SpatialDataArray(1+np.random.random((5, 6, 7)), coords=coords)\n>>> eps1 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> tau1 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> debye_medium = CustomDebye(eps_inf=eps_inf, coeffs=[(eps1,tau1),])\n>>> eps = debye_medium.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "CustomDebye",
          "enum": [
            "CustomDebye"
          ],
          "type": "string"
        },
        "eps_inf": {
          "title": "DataArray",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "units": "None (relative permittivity)",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "coeffs": {
          "title": "Coefficients",
          "description": "List of (:math:`\\Delta\\epsilon_i, \\tau_i`) values for model.",
          "units": [
            "None (relative permittivity)",
            "sec"
          ],
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "title": "DataArray",
                "type": "xr.DataArray",
                "properties": {
                  "_dims": {
                    "title": "_dims",
                    "type": "Tuple[str, ...]"
                  }
                },
                "required": [
                  "_dims"
                ]
              },
              {
                "title": "DataArray",
                "type": "xr.DataArray",
                "properties": {
                  "_dims": {
                    "title": "_dims",
                    "type": "Tuple[str, ...]"
                  }
                },
                "required": [
                  "_dims"
                ]
              }
            ]
          }
        },
        "interp_method": {
          "title": "Interpolation method",
          "description": "Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.",
          "default": "nearest",
          "enum": [
            "nearest",
            "linear"
          ],
          "type": "string"
        },
        "subpixel": {
          "title": "Subpixel averaging",
          "description": "If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.",
          "default": false,
          "type": "boolean"
        }
      },
      "required": [
        "eps_inf",
        "coeffs"
      ],
      "additionalProperties": false
    },
    "CustomDrude": {
      "title": "CustomDrude",
      "description": "A spatially varying dispersive medium described by the Drude model.\nThe frequency-dependence of the complex-valued permittivity is described by:\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\neps_inf : SpatialDataArray\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\ncoeffs : Tuple[Tuple[tidy3d.components.data.data_array.SpatialDataArray, tidy3d.components.data.data_array.SpatialDataArray], ...]\n    [units = (Hz, Hz)].  List of (:math:`f_i, \\delta_i`) values for model.\ninterp_method : Literal['nearest', 'linear'] = nearest\n    Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.\nsubpixel : bool = False\n    If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.\n\nNote\n----\n.. math::\n\n    \\epsilon(f) = \\epsilon_\\infty - \\sum_i\n    \\frac{ f_i^2}{f^2 + jf\\delta_i}\n\nExample\n-------\n>>> x = np.linspace(-1, 1, 5)\n>>> y = np.linspace(-1, 1, 6)\n>>> z = np.linspace(-1, 1, 7)\n>>> coords = dict(x=x, y=y, z=z)\n>>> eps_inf = SpatialDataArray(np.ones((5, 6, 7)), coords=coords)\n>>> f1 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> delta1 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> drude_medium = CustomDrude(eps_inf=eps_inf, coeffs=[(f1,delta1),])\n>>> eps = drude_medium.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "CustomDrude",
          "enum": [
            "CustomDrude"
          ],
          "type": "string"
        },
        "eps_inf": {
          "title": "DataArray",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "units": "None (relative permittivity)",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "coeffs": {
          "title": "Coefficients",
          "description": "List of (:math:`f_i, \\delta_i`) values for model.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "title": "DataArray",
                "type": "xr.DataArray",
                "properties": {
                  "_dims": {
                    "title": "_dims",
                    "type": "Tuple[str, ...]"
                  }
                },
                "required": [
                  "_dims"
                ]
              },
              {
                "title": "DataArray",
                "type": "xr.DataArray",
                "properties": {
                  "_dims": {
                    "title": "_dims",
                    "type": "Tuple[str, ...]"
                  }
                },
                "required": [
                  "_dims"
                ]
              }
            ]
          }
        },
        "interp_method": {
          "title": "Interpolation method",
          "description": "Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.",
          "default": "nearest",
          "enum": [
            "nearest",
            "linear"
          ],
          "type": "string"
        },
        "subpixel": {
          "title": "Subpixel averaging",
          "description": "If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.",
          "default": false,
          "type": "boolean"
        }
      },
      "required": [
        "eps_inf",
        "coeffs"
      ],
      "additionalProperties": false
    },
    "CustomAnisotropicMedium": {
      "title": "CustomAnisotropicMedium",
      "description": "Diagonally anisotropic medium with spatially varying permittivity in each component.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : Optional[bool] = None\n    This field is ignored. Please set ``allow_gain`` in each component\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\nxx : Union[CustomPoleResidue, CustomSellmeier, CustomLorentz, CustomDebye, CustomDrude, CustomMedium]\n    Medium describing the xx-component of the diagonal permittivity tensor.\nyy : Union[CustomPoleResidue, CustomSellmeier, CustomLorentz, CustomDebye, CustomDrude, CustomMedium]\n    Medium describing the yy-component of the diagonal permittivity tensor.\nzz : Union[CustomPoleResidue, CustomSellmeier, CustomLorentz, CustomDebye, CustomDrude, CustomMedium]\n    Medium describing the zz-component of the diagonal permittivity tensor.\ninterp_method : Optional[Literal['nearest', 'linear']] = None\n    When the value is 'None', each component will follow its own interpolation method. When the value is other than 'None', the interpolation method specified by this field will override the one in each component.\nsubpixel : Optional[bool] = None\n    This field is ignored. Please set ``subpixel`` in each component\n\nNote\n----\nOnly diagonal anisotropy is currently supported.\n\nExample\n-------\n>>> Nx, Ny, Nz = 10, 9, 8\n>>> x = np.linspace(-1, 1, Nx)\n>>> y = np.linspace(-1, 1, Ny)\n>>> z = np.linspace(-1, 1, Nz)\n>>> coords = dict(x=x, y=y, z=z)\n>>> permittivity= SpatialDataArray(np.ones((Nx, Ny, Nz)), coords=coords)\n>>> conductivity= SpatialDataArray(np.ones((Nx, Ny, Nz)), coords=coords)\n>>> medium_xx = CustomMedium(permittivity=permittivity, conductivity=conductivity)\n>>> medium_yy = CustomMedium(permittivity=permittivity, conductivity=conductivity)\n>>> d_epsilon = SpatialDataArray(np.random.random((Nx, Ny, Nz)), coords=coords)\n>>> f = SpatialDataArray(1+np.random.random((Nx, Ny, Nz)), coords=coords)\n>>> delta = SpatialDataArray(np.random.random((Nx, Ny, Nz)), coords=coords)\n>>> medium_zz = CustomLorentz(eps_inf=permittivity, coeffs=[(d_epsilon,f,delta),])\n>>> anisotropic_dielectric = CustomAnisotropicMedium(xx=medium_xx, yy=medium_yy, zz=medium_zz)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "This field is ignored. Please set ``allow_gain`` in each component",
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "CustomAnisotropicMedium",
          "enum": [
            "CustomAnisotropicMedium"
          ],
          "type": "string"
        },
        "xx": {
          "title": "XX Component",
          "description": "Medium describing the xx-component of the diagonal permittivity tensor.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "CustomPoleResidue": "#/definitions/CustomPoleResidue",
              "CustomSellmeier": "#/definitions/CustomSellmeier",
              "CustomLorentz": "#/definitions/CustomLorentz",
              "CustomDebye": "#/definitions/CustomDebye",
              "CustomDrude": "#/definitions/CustomDrude",
              "CustomMedium": "#/definitions/CustomMedium"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/CustomPoleResidue"
            },
            {
              "$ref": "#/definitions/CustomSellmeier"
            },
            {
              "$ref": "#/definitions/CustomLorentz"
            },
            {
              "$ref": "#/definitions/CustomDebye"
            },
            {
              "$ref": "#/definitions/CustomDrude"
            },
            {
              "$ref": "#/definitions/CustomMedium"
            }
          ]
        },
        "yy": {
          "title": "YY Component",
          "description": "Medium describing the yy-component of the diagonal permittivity tensor.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "CustomPoleResidue": "#/definitions/CustomPoleResidue",
              "CustomSellmeier": "#/definitions/CustomSellmeier",
              "CustomLorentz": "#/definitions/CustomLorentz",
              "CustomDebye": "#/definitions/CustomDebye",
              "CustomDrude": "#/definitions/CustomDrude",
              "CustomMedium": "#/definitions/CustomMedium"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/CustomPoleResidue"
            },
            {
              "$ref": "#/definitions/CustomSellmeier"
            },
            {
              "$ref": "#/definitions/CustomLorentz"
            },
            {
              "$ref": "#/definitions/CustomDebye"
            },
            {
              "$ref": "#/definitions/CustomDrude"
            },
            {
              "$ref": "#/definitions/CustomMedium"
            }
          ]
        },
        "zz": {
          "title": "ZZ Component",
          "description": "Medium describing the zz-component of the diagonal permittivity tensor.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "CustomPoleResidue": "#/definitions/CustomPoleResidue",
              "CustomSellmeier": "#/definitions/CustomSellmeier",
              "CustomLorentz": "#/definitions/CustomLorentz",
              "CustomDebye": "#/definitions/CustomDebye",
              "CustomDrude": "#/definitions/CustomDrude",
              "CustomMedium": "#/definitions/CustomMedium"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/CustomPoleResidue"
            },
            {
              "$ref": "#/definitions/CustomSellmeier"
            },
            {
              "$ref": "#/definitions/CustomLorentz"
            },
            {
              "$ref": "#/definitions/CustomDebye"
            },
            {
              "$ref": "#/definitions/CustomDrude"
            },
            {
              "$ref": "#/definitions/CustomMedium"
            }
          ]
        },
        "interp_method": {
          "title": "Interpolation method",
          "description": "When the value is 'None', each component will follow its own interpolation method. When the value is other than 'None', the interpolation method specified by this field will override the one in each component.",
          "enum": [
            "nearest",
            "linear"
          ],
          "type": "string"
        },
        "subpixel": {
          "title": "Subpixel averaging",
          "description": "This field is ignored. Please set ``subpixel`` in each component",
          "type": "boolean"
        }
      },
      "required": [
        "xx",
        "yy",
        "zz"
      ],
      "additionalProperties": false
    },
    "LinearHeatPerturbation": {
      "title": "LinearHeatPerturbation",
      "description": "Specifies parameter's perturbation due to thermal effects as a linear function of\ntemperature:\n\nParameters\n----------\ntemperature_range : Tuple[NonNegativeFloat, NonNegativeFloat] = (0, inf)\n    [units = K].  Temparature range in which perturbation model is valid.\ntemperature_ref : NonNegativeFloat\n    [units = K].  Temperature at which perturbation is zero.\ncoeff : Union[float, tidycomplex, ComplexNumber]\n    [units = 1/K].  Sensitivity (derivative) of perturbation with respect to temperature.\n\nNote\n----\n.. math::\n\n    \\Delta X (T) = \\text{coeff} \\times (T - \\text{temperature\\_ref}),\n\nwhere ``coeff`` is the parameter's sensitivity (thermo-optic coefficient) to temperature and\n``temperature_ref`` is the reference temperature point. A temperature range in which such\na model is deemed accurate may be provided as a field ``temperature_range``\n(default: ``[0, inf]``). Wherever is applied, Tidy3D will check that the parameter's value\ndoes not go out of its physical bounds within ``temperature_range`` due to perturbations and\nraise a warning if this check fails. A warning is also issued if the perturbation model is\nevaluated outside of ``temperature_range``.\n\nExample\n-------\n>>> heat_perturb = LinearHeatPerturbation(\n...     temperature_ref=300,\n...     coeff=0.0001,\n...     temperature_range=[200, 500],\n... )",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "LinearHeatPerturbation",
          "enum": [
            "LinearHeatPerturbation"
          ],
          "type": "string"
        },
        "temperature_range": {
          "title": "Temperature range",
          "description": "Temparature range in which perturbation model is valid.",
          "default": [
            0,
            Infinity
          ],
          "units": "K",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "temperature_ref": {
          "title": "Reference temperature",
          "description": "Temperature at which perturbation is zero.",
          "units": "K",
          "minimum": 0,
          "type": "number"
        },
        "coeff": {
          "title": "Thermo-optic Coefficient",
          "description": "Sensitivity (derivative) of perturbation with respect to temperature.",
          "units": "1/K",
          "anyOf": [
            {
              "type": "number"
            },
            {
              "title": "ComplexNumber",
              "description": "Complex number with a well defined schema.",
              "type": "object",
              "properties": {
                "real": {
                  "title": "Real",
                  "type": "number"
                },
                "imag": {
                  "title": "Imag",
                  "type": "number"
                }
              },
              "required": [
                "real",
                "imag"
              ]
            },
            {
              "$ref": "#/definitions/ComplexNumber"
            }
          ]
        }
      },
      "required": [
        "temperature_ref",
        "coeff"
      ],
      "additionalProperties": false
    },
    "CustomHeatPerturbation": {
      "title": "CustomHeatPerturbation",
      "description": "Specifies parameter's perturbation due to thermal effects as a custom function of\ntemperature defined as an array of perturbation values at sample temperature points. The linear\ninterpolation is used to calculate perturbation values between sample temperature points. For\ntemperature values outside of the provided sample region the perturbation value is extrapolated\nas a constant.\nThe temperature range, ``temperature_range``, in which the perturbation model is assumed to be\naccurate is calculated automatically as the minimal and maximal sample temperature points.\nWherever is applied, Tidy3D will check that the parameter's value\ndoes not go out of its physical bounds within ``temperature_range`` due to perturbations and\nraise a warning if this check fails. A warning is also issued if the perturbation model is\nevaluated outside of ``temperature_range``.\n\nParameters\n----------\ntemperature_range : Optional[Tuple[NonNegativeFloat, NonNegativeFloat]] = None\n    [units = K].  Temparature range in which perturbation model is valid. For :class:`.CustomHeatPerturbation` this field is computed automatically based on temperature sample points provided in ``perturbation_values``.\nperturbation_values : HeatDataArray\n    Sampled perturbation values.\ninterp_method : Literal['nearest', 'linear'] = linear\n    Interpolation method to obtain perturbation values between sample points.\n\nExample\n-------\n>>> from tidy3d import HeatDataArray\n>>> perturbation_data = HeatDataArray([0.001, 0.002, 0.004], coords=dict(T=[250, 300, 350]))\n>>> heat_perturb = CustomHeatPerturbation(\n...     perturbation_values=perturbation_data\n... )",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "CustomHeatPerturbation",
          "enum": [
            "CustomHeatPerturbation"
          ],
          "type": "string"
        },
        "temperature_range": {
          "title": "Temperature range",
          "description": "Temparature range in which perturbation model is valid. For :class:`.CustomHeatPerturbation` this field is computed automatically based on temperature sample points provided in ``perturbation_values``.",
          "units": "K",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "perturbation_values": {
          "title": "DataArray",
          "description": "Sampled perturbation values.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "interp_method": {
          "title": "Interpolation method",
          "description": "Interpolation method to obtain perturbation values between sample points.",
          "default": "linear",
          "enum": [
            "nearest",
            "linear"
          ],
          "type": "string"
        }
      },
      "required": [
        "perturbation_values"
      ],
      "additionalProperties": false
    },
    "LinearChargePerturbation": {
      "title": "LinearChargePerturbation",
      "description": "Specifies parameter's perturbation due to free carrier effects as a linear function of\nelectron and hole densities:\n\nParameters\n----------\nelectron_range : Tuple[NonNegativeFloat, NonNegativeFloat] = (0, inf)\n    Range of electrons densities in which perturbation model is valid.\nhole_range : Tuple[NonNegativeFloat, NonNegativeFloat] = (0, inf)\n    Range of holes densities in which perturbation model is valid.\nelectron_ref : NonNegativeFloat\n    [units = 1/cm^3].  Electron density value at which there is no perturbation due to electrons's presence.\nhole_ref : NonNegativeFloat\n    [units = 1/cm^3].  Hole density value at which there is no perturbation due to holes' presence.\nelectron_coeff : float\n    [units = cm^3].  Sensitivity (derivative) of perturbation with respect to electron density.\nhole_coeff : float\n    [units = cm^3].  Sensitivity (derivative) of perturbation with respect to hole density.\n\nNote\n----\n.. math::\n\n    \\Delta X (T) = \\text{electron\\_coeff} \\times (N_e - \\text{electron\\_ref})\n    + \\text{hole\\_coeff} \\times (N_h - \\text{hole\\_ref}),\n\nwhere ``electron_coeff`` and ``hole_coeff`` are the parameter's sensitivities to electron and\nhole densities, while ``electron_ref`` and ``hole_ref`` are reference electron and hole density\nvalues. Ranges of electron and hole densities in which such\na model is deemed accurate may be provided as fields ``electron_range`` and ``hole_range``\n(default: ``[0, inf]`` each). Wherever is applied, Tidy3D will check that the parameter's value\ndoes not go out of its physical bounds within ``electron_range`` x ``hole_range`` due to\nperturbations and raise a warning if this check fails. A warning is also issued if\nthe perturbation model is evaluated outside of ``electron_range`` x ``hole_range``.\n\nExample\n-------\n>>> charge_perturb = LinearChargePerturbation(\n...     electron_ref=0,\n...     electron_coeff=0.0001,\n...     electron_range=[0, 1e19],\n...     hole_ref=0,\n...     hole_coeff=0.0002,\n...     hole_range=[0, 2e19],\n... )",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "LinearChargePerturbation",
          "enum": [
            "LinearChargePerturbation"
          ],
          "type": "string"
        },
        "electron_range": {
          "title": "Electron Density Range",
          "description": "Range of electrons densities in which perturbation model is valid.",
          "default": [
            0,
            Infinity
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "hole_range": {
          "title": "Hole Density Range",
          "description": "Range of holes densities in which perturbation model is valid.",
          "default": [
            0,
            Infinity
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "electron_ref": {
          "title": "Reference Electron Density",
          "description": "Electron density value at which there is no perturbation due to electrons's presence.",
          "units": "1/cm^3",
          "minimum": 0,
          "type": "number"
        },
        "hole_ref": {
          "title": "Reference Hole Density",
          "description": "Hole density value at which there is no perturbation due to holes' presence.",
          "units": "1/cm^3",
          "minimum": 0,
          "type": "number"
        },
        "electron_coeff": {
          "title": "Sensitivity to Electron Density",
          "description": "Sensitivity (derivative) of perturbation with respect to electron density.",
          "units": "cm^3",
          "type": "number"
        },
        "hole_coeff": {
          "title": "Sensitivity to Hole Density",
          "description": "Sensitivity (derivative) of perturbation with respect to hole density.",
          "units": "cm^3",
          "type": "number"
        }
      },
      "required": [
        "electron_ref",
        "hole_ref",
        "electron_coeff",
        "hole_coeff"
      ],
      "additionalProperties": false
    },
    "CustomChargePerturbation": {
      "title": "CustomChargePerturbation",
      "description": "Specifies parameter's perturbation due to free carrier effects as a custom function of\nelectron and hole densities defined as a two-dimensional array of perturbation values at sample\nelectron and hole density points. The linear interpolation is used to calculate perturbation\nvalues between sample points. For electron and hole density values outside of the provided\nsample region the perturbation value is extrapolated as a constant.\nThe electron and hole density ranges, ``electron_range`` and ``hole_range``, in which\nthe perturbation model is assumed to be accurate is calculated automatically as the minimal and\nmaximal density values provided in ``perturbation_values``. Wherever is applied, Tidy3D will\ncheck that the parameter's value does not go out of its physical bounds within\n``electron_range`` x ``hole_range`` due to perturbations and raise a warning if this check\nfails. A warning is also issued if the perturbation model is evaluated outside of\n``electron_range`` x ``hole_range``.\n\nParameters\n----------\nelectron_range : Optional[Tuple[NonNegativeFloat, NonNegativeFloat]] = None\n    Range of electrons densities in which perturbation model is valid. For :class:`.CustomChargePerturbation` this field is computed automatically based on provided ``perturbation_values``\nhole_range : Optional[Tuple[NonNegativeFloat, NonNegativeFloat]] = None\n    Range of holes densities in which perturbation model is valid. For :class:`.CustomChargePerturbation` this field is computed automatically based on provided ``perturbation_values``\nperturbation_values : ChargeDataArray\n    2D array (vs electron and hole densities) of sampled perturbation values.\ninterp_method : Literal['nearest', 'linear'] = linear\n    Interpolation method to obtain perturbation values between sample points.\n\nExample\n-------\n>>> from tidy3d import ChargeDataArray\n>>> perturbation_data = ChargeDataArray(\n...     [[0.001, 0.002, 0.004], [0.003, 0.002, 0.001]],\n...     coords=dict(n=[2e15, 2e19], p=[1e16, 1e17, 1e18]),\n... )\n>>> charge_perturb = CustomChargePerturbation(\n...     perturbation_values=perturbation_data,\n... )",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "CustomChargePerturbation",
          "enum": [
            "CustomChargePerturbation"
          ],
          "type": "string"
        },
        "electron_range": {
          "title": "Electron Density Range",
          "description": "Range of electrons densities in which perturbation model is valid. For :class:`.CustomChargePerturbation` this field is computed automatically based on provided ``perturbation_values``",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "hole_range": {
          "title": "Hole Density Range",
          "description": "Range of holes densities in which perturbation model is valid. For :class:`.CustomChargePerturbation` this field is computed automatically based on provided ``perturbation_values``",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "perturbation_values": {
          "title": "DataArray",
          "description": "2D array (vs electron and hole densities) of sampled perturbation values.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "interp_method": {
          "title": "Interpolation method",
          "description": "Interpolation method to obtain perturbation values between sample points.",
          "default": "linear",
          "enum": [
            "nearest",
            "linear"
          ],
          "type": "string"
        }
      },
      "required": [
        "perturbation_values"
      ],
      "additionalProperties": false
    },
    "ParameterPerturbation": {
      "title": "ParameterPerturbation",
      "description": "Stores information about parameter perturbations due to different physical effect. If both\nheat and charge perturbation models are included their effects are superimposed.\n\nParameters\n----------\nheat : Union[LinearHeatPerturbation, CustomHeatPerturbation] = None\n    Heat perturbation to apply.\ncharge : Union[LinearChargePerturbation, CustomChargePerturbation] = None\n    Charge perturbation to apply.\n\nExample\n-------\n>>> from tidy3d import LinearChargePerturbation, CustomHeatPerturbation, HeatDataArray\n>>>\n>>> perturbation_data = HeatDataArray([0.001, 0.002, 0.004], coords=dict(T=[250, 300, 350]))\n>>> heat_perturb = CustomHeatPerturbation(\n...     perturbation_values=perturbation_data\n... )\n>>> charge_perturb = LinearChargePerturbation(\n...     electron_ref=0,\n...     electron_coeff=0.0001,\n...     electron_range=[0, 1e19],\n...     hole_ref=0,\n...     hole_coeff=0.0002,\n...     hole_range=[0, 2e19],\n... )\n>>> param_perturb = ParameterPerturbation(heat=heat_perturb, charge=charge_perturb)",
      "type": "object",
      "properties": {
        "heat": {
          "title": "Heat Perturbation",
          "description": "Heat perturbation to apply.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "LinearHeatPerturbation": "#/definitions/LinearHeatPerturbation",
              "CustomHeatPerturbation": "#/definitions/CustomHeatPerturbation"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/LinearHeatPerturbation"
            },
            {
              "$ref": "#/definitions/CustomHeatPerturbation"
            }
          ]
        },
        "charge": {
          "title": "Charge Perturbation",
          "description": "Charge perturbation to apply.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "LinearChargePerturbation": "#/definitions/LinearChargePerturbation",
              "CustomChargePerturbation": "#/definitions/CustomChargePerturbation"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/LinearChargePerturbation"
            },
            {
              "$ref": "#/definitions/CustomChargePerturbation"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "ParameterPerturbation",
          "enum": [
            "ParameterPerturbation"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PerturbationMedium": {
      "title": "PerturbationMedium",
      "description": "Dispersionless medium with perturbations.\n\nParameters\n----------\nsubpixel : bool = True\n    This value will be transferred to the resulting custom medium. That is, if ``True``, the subpixel averaging will be applied to the custom medium provided the corresponding ``Simulation``'s field ``subpixel`` is set to ``True`` as well. If the resulting medium is not a custom medium (no perturbations), this field does not have an effect.\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\npermittivity : ConstrainedFloatValue = 1.0\n    [units = None (relative permittivity)].  Relative permittivity.\nconductivity : float = 0.0\n    [units = S/um].  Electric conductivity. Defined such that the imaginary part of the complex permittivity at angular frequency omega is given by conductivity/omega.\npermittivity_perturbation : Optional[ParameterPerturbation] = None\n    [units = None (relative permittivity)].  List of heat and/or charge perturbations to permittivity.\nconductivity_perturbation : Optional[ParameterPerturbation] = None\n    [units = S/um].  List of heat and/or charge perturbations to permittivity.\n\nExample\n-------\n>>> from tidy3d import ParameterPerturbation, LinearHeatPerturbation\n>>> dielectric = PerturbationMedium(\n...     permittivity=4.0,\n...     permittivity_perturbation=ParameterPerturbation(\n...         heat=LinearHeatPerturbation(temperature_ref=300, coeff=0.0001),\n...     ),\n...     name='my_medium',\n... )",
      "type": "object",
      "properties": {
        "subpixel": {
          "title": "Subpixel averaging",
          "description": "This value will be transferred to the resulting custom medium. That is, if ``True``, the subpixel averaging will be applied to the custom medium provided the corresponding ``Simulation``'s field ``subpixel`` is set to ``True`` as well. If the resulting medium is not a custom medium (no perturbations), this field does not have an effect.",
          "default": true,
          "type": "boolean"
        },
        "type": {
          "title": "Type",
          "default": "PerturbationMedium",
          "enum": [
            "PerturbationMedium"
          ],
          "type": "string"
        },
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "permittivity": {
          "title": "Permittivity",
          "description": "Relative permittivity.",
          "default": 1.0,
          "minimum": 1.0,
          "units": "None (relative permittivity)",
          "type": "number"
        },
        "conductivity": {
          "title": "Conductivity",
          "description": "Electric conductivity. Defined such that the imaginary part of the complex permittivity at angular frequency omega is given by conductivity/omega.",
          "default": 0.0,
          "units": "S/um",
          "type": "number"
        },
        "permittivity_perturbation": {
          "title": "Permittivity Perturbation",
          "description": "List of heat and/or charge perturbations to permittivity.",
          "units": "None (relative permittivity)",
          "allOf": [
            {
              "$ref": "#/definitions/ParameterPerturbation"
            }
          ]
        },
        "conductivity_perturbation": {
          "title": "Permittivity Perturbation",
          "description": "List of heat and/or charge perturbations to permittivity.",
          "units": "S/um",
          "allOf": [
            {
              "$ref": "#/definitions/ParameterPerturbation"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "PerturbationPoleResidue": {
      "title": "PerturbationPoleResidue",
      "description": "A dispersive medium described by the pole-residue pair model with perturbations.\nThe frequency-dependence of the complex-valued permittivity is described by:\n\nParameters\n----------\nsubpixel : bool = True\n    This value will be transferred to the resulting custom medium. That is, if ``True``, the subpixel averaging will be applied to the custom medium provided the corresponding ``Simulation``'s field ``subpixel`` is set to ``True`` as well. If the resulting medium is not a custom medium (no perturbations), this field does not have an effect.\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\neps_inf : PositiveFloat = 1.0\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\npoles : Tuple[Tuple[Union[tidy3d.components.types.tidycomplex, tidy3d.components.types.ComplexNumber], Union[tidy3d.components.types.tidycomplex, tidy3d.components.types.ComplexNumber]], ...] = ()\n    [units = (rad/sec, rad/sec)].  Tuple of complex-valued (:math:`a_i, c_i`) poles for the model.\neps_inf_perturbation : Optional[ParameterPerturbation] = None\n    [units = None (relative permittivity)].  Perturbations to relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\npoles_perturbation : Tuple[Tuple[Optional[tidy3d.components.parameter_perturbation.ParameterPerturbation], Optional[tidy3d.components.parameter_perturbation.ParameterPerturbation]], ...] = ()\n    [units = (rad/sec, rad/sec)].  Perturbations to poles of the model.\n\nNote\n----\n.. math::\n\n    \\epsilon(\\omega) = \\epsilon_\\infty - \\sum_i\n    \\left[\\frac{c_i}{j \\omega + a_i} +\n    \\frac{c_i^*}{j \\omega + a_i^*}\\right]\n\nExample\n-------\n>>> from tidy3d import ParameterPerturbation, LinearHeatPerturbation\n>>> c0_perturbation = ParameterPerturbation(\n...     heat=LinearHeatPerturbation(temperature_ref=300, coeff=0.0001),\n... )\n>>> pole_res = PerturbationPoleResidue(\n...     eps_inf=2.0,\n...     poles=[((-1+2j), (3+4j)), ((-5+6j), (7+8j))],\n...     poles_perturbation=[(None, c0_perturbation), (None, None)],\n... )",
      "type": "object",
      "properties": {
        "subpixel": {
          "title": "Subpixel averaging",
          "description": "This value will be transferred to the resulting custom medium. That is, if ``True``, the subpixel averaging will be applied to the custom medium provided the corresponding ``Simulation``'s field ``subpixel`` is set to ``True`` as well. If the resulting medium is not a custom medium (no perturbations), this field does not have an effect.",
          "default": true,
          "type": "boolean"
        },
        "type": {
          "title": "Type",
          "default": "PerturbationPoleResidue",
          "enum": [
            "PerturbationPoleResidue"
          ],
          "type": "string"
        },
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "eps_inf": {
          "title": "Epsilon at Infinity",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "default": 1.0,
          "units": "None (relative permittivity)",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "poles": {
          "title": "Poles",
          "description": "Tuple of complex-valued (:math:`a_i, c_i`) poles for the model.",
          "default": [],
          "units": [
            "rad/sec",
            "rad/sec"
          ],
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "anyOf": [
                  {
                    "title": "ComplexNumber",
                    "description": "Complex number with a well defined schema.",
                    "type": "object",
                    "properties": {
                      "real": {
                        "title": "Real",
                        "type": "number"
                      },
                      "imag": {
                        "title": "Imag",
                        "type": "number"
                      }
                    },
                    "required": [
                      "real",
                      "imag"
                    ]
                  },
                  {
                    "$ref": "#/definitions/ComplexNumber"
                  }
                ]
              },
              {
                "anyOf": [
                  {
                    "title": "ComplexNumber",
                    "description": "Complex number with a well defined schema.",
                    "type": "object",
                    "properties": {
                      "real": {
                        "title": "Real",
                        "type": "number"
                      },
                      "imag": {
                        "title": "Imag",
                        "type": "number"
                      }
                    },
                    "required": [
                      "real",
                      "imag"
                    ]
                  },
                  {
                    "$ref": "#/definitions/ComplexNumber"
                  }
                ]
              }
            ]
          }
        },
        "eps_inf_perturbation": {
          "title": "Perturbation of Epsilon at Infinity",
          "description": "Perturbations to relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "units": "None (relative permittivity)",
          "allOf": [
            {
              "$ref": "#/definitions/ParameterPerturbation"
            }
          ]
        },
        "poles_perturbation": {
          "title": "Perturbations of Poles",
          "description": "Perturbations to poles of the model.",
          "default": [],
          "units": [
            "rad/sec",
            "rad/sec"
          ],
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "$ref": "#/definitions/ParameterPerturbation"
              },
              {
                "$ref": "#/definitions/ParameterPerturbation"
              }
            ]
          }
        }
      },
      "additionalProperties": false
    },
    "Box": {
      "title": "Box",
      "description": "Rectangular prism.\n   Also base class for :class:`Simulation`, :class:`Monitor`, and :class:`Source`.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\n\nExample\n-------\n>>> b = Box(center=(1,2,3), size=(2,2,2))",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "Box",
          "enum": [
            "Box"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        }
      },
      "required": [
        "size"
      ],
      "additionalProperties": false
    },
    "Sphere": {
      "title": "Sphere",
      "description": "Spherical geometry.\n\nParameters\n----------\nradius : NonNegativeFloat\n    [units = um].  Radius of geometry.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\n\nExample\n-------\n>>> b = Sphere(center=(1,2,3), radius=2)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "Sphere",
          "enum": [
            "Sphere"
          ],
          "type": "string"
        },
        "radius": {
          "title": "Radius",
          "description": "Radius of geometry.",
          "units": "um",
          "minimum": 0,
          "type": "number"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        }
      },
      "required": [
        "radius"
      ],
      "additionalProperties": false
    },
    "Cylinder": {
      "title": "Cylinder",
      "description": "Cylindrical geometry with optional sidewall angle along axis\ndirection. When ``sidewall_angle`` is nonzero, the shape is a\nconical frustum or a cone.\n\nParameters\n----------\naxis : Literal[0, 1, 2] = 2\n    Specifies dimension of the planar axis (0,1,2) -> (x,y,z).\nsidewall_angle : ConstrainedFloatValue = 0.0\n    [units = rad].  Angle of the sidewall. ``sidewall_angle=0`` (default) specifies a vertical wall; ``0<sidewall_angle<np.pi/2`` specifies a shrinking cross section along the ``axis`` direction; and ``-np.pi/2<sidewall_angle<0`` specifies an expanding cross section along the ``axis`` direction.\nreference_plane : Literal['bottom', 'middle', 'top'] = middle\n    The position of the plane where the supplied cross section are defined. The plane is perpendicular to the ``axis``. The plane is located at the ``bottom``, ``middle``, or ``top`` of the geometry with respect to the axis. E.g. if ``axis=1``, ``bottom`` refers to the negative side of the y-axis, and ``top`` refers to the positive side of the y-axis.\nradius : NonNegativeFloat\n    [units = um].  Radius of geometry at the ``reference_plane``.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nlength : NonNegativeFloat\n    [units = um].  Defines thickness of cylinder along axis dimension.\n\nExample\n-------\n>>> c = Cylinder(center=(1,2,3), radius=2, length=5, axis=2)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "Cylinder",
          "enum": [
            "Cylinder"
          ],
          "type": "string"
        },
        "axis": {
          "title": "Axis",
          "description": "Specifies dimension of the planar axis (0,1,2) -> (x,y,z).",
          "default": 2,
          "enum": [
            0,
            1,
            2
          ],
          "type": "integer"
        },
        "sidewall_angle": {
          "title": "Sidewall angle",
          "description": "Angle of the sidewall. ``sidewall_angle=0`` (default) specifies a vertical wall; ``0<sidewall_angle<np.pi/2`` specifies a shrinking cross section along the ``axis`` direction; and ``-np.pi/2<sidewall_angle<0`` specifies an expanding cross section along the ``axis`` direction.",
          "default": 0.0,
          "exclusiveMinimum": -1.5707963267948966,
          "exclusiveMaximum": 1.5707963267948966,
          "units": "rad",
          "type": "number"
        },
        "reference_plane": {
          "title": "Reference plane for cross section",
          "description": "The position of the plane where the supplied cross section are defined. The plane is perpendicular to the ``axis``. The plane is located at the ``bottom``, ``middle``, or ``top`` of the geometry with respect to the axis. E.g. if ``axis=1``, ``bottom`` refers to the negative side of the y-axis, and ``top`` refers to the positive side of the y-axis.",
          "default": "middle",
          "enum": [
            "bottom",
            "middle",
            "top"
          ],
          "type": "string"
        },
        "radius": {
          "title": "Radius",
          "description": "Radius of geometry at the ``reference_plane``.",
          "units": "um",
          "minimum": 0,
          "type": "number"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "length": {
          "title": "Length",
          "description": "Defines thickness of cylinder along axis dimension.",
          "units": "um",
          "minimum": 0,
          "type": "number"
        }
      },
      "required": [
        "radius",
        "length"
      ],
      "additionalProperties": false
    },
    "PolySlab": {
      "title": "PolySlab",
      "description": "Polygon extruded with optional sidewall angle along axis direction.\n\nParameters\n----------\naxis : Literal[0, 1, 2] = 2\n    Specifies dimension of the planar axis (0,1,2) -> (x,y,z).\nsidewall_angle : ConstrainedFloatValue = 0.0\n    [units = rad].  Angle of the sidewall. ``sidewall_angle=0`` (default) specifies a vertical wall; ``0<sidewall_angle<np.pi/2`` specifies a shrinking cross section along the ``axis`` direction; and ``-np.pi/2<sidewall_angle<0`` specifies an expanding cross section along the ``axis`` direction.\nreference_plane : Literal['bottom', 'middle', 'top'] = middle\n    The position of the plane where the supplied cross section are defined. The plane is perpendicular to the ``axis``. The plane is located at the ``bottom``, ``middle``, or ``top`` of the geometry with respect to the axis. E.g. if ``axis=1``, ``bottom`` refers to the negative side of the y-axis, and ``top`` refers to the positive side of the y-axis.\nslab_bounds : Tuple[float, float]\n    [units = um].  Minimum and maximum positions of the slab along axis dimension.\ndilation : float = 0.0\n    [units = um].  Dilation of the supplied polygon by shifting each edge along its normal outwards direction by a distance; a negative value corresponds to erosion.\nvertices : ArrayLike[dtype=float, ndim=2]\n    [units = um].  List of (d1, d2) defining the 2 dimensional positions of the polygon face vertices at the ``reference_plane``. The index of dimension should be in the ascending order: e.g. if the slab normal axis is ``axis=y``, the coordinate of the vertices will be in (x, z)\n\nExample\n-------\n>>> vertices = np.array([(0,0), (1,0), (1,1)])\n>>> p = PolySlab(vertices=vertices, axis=2, slab_bounds=(-1, 1))",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "PolySlab",
          "enum": [
            "PolySlab"
          ],
          "type": "string"
        },
        "axis": {
          "title": "Axis",
          "description": "Specifies dimension of the planar axis (0,1,2) -> (x,y,z).",
          "default": 2,
          "enum": [
            0,
            1,
            2
          ],
          "type": "integer"
        },
        "sidewall_angle": {
          "title": "Sidewall angle",
          "description": "Angle of the sidewall. ``sidewall_angle=0`` (default) specifies a vertical wall; ``0<sidewall_angle<np.pi/2`` specifies a shrinking cross section along the ``axis`` direction; and ``-np.pi/2<sidewall_angle<0`` specifies an expanding cross section along the ``axis`` direction.",
          "default": 0.0,
          "exclusiveMinimum": -1.5707963267948966,
          "exclusiveMaximum": 1.5707963267948966,
          "units": "rad",
          "type": "number"
        },
        "reference_plane": {
          "title": "Reference plane for cross section",
          "description": "The position of the plane where the supplied cross section are defined. The plane is perpendicular to the ``axis``. The plane is located at the ``bottom``, ``middle``, or ``top`` of the geometry with respect to the axis. E.g. if ``axis=1``, ``bottom`` refers to the negative side of the y-axis, and ``top`` refers to the positive side of the y-axis.",
          "default": "middle",
          "enum": [
            "bottom",
            "middle",
            "top"
          ],
          "type": "string"
        },
        "slab_bounds": {
          "title": "Slab Bounds",
          "description": "Minimum and maximum positions of the slab along axis dimension.",
          "units": "um",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "dilation": {
          "title": "Dilation",
          "description": "Dilation of the supplied polygon by shifting each edge along its normal outwards direction by a distance; a negative value corresponds to erosion.",
          "default": 0.0,
          "units": "um",
          "type": "number"
        },
        "vertices": {
          "title": "Vertices",
          "description": "List of (d1, d2) defining the 2 dimensional positions of the polygon face vertices at the ``reference_plane``. The index of dimension should be in the ascending order: e.g. if the slab normal axis is ``axis=y``, the coordinate of the vertices will be in (x, z)",
          "units": "um",
          "type": "ArrayLike"
        }
      },
      "required": [
        "slab_bounds",
        "vertices"
      ],
      "additionalProperties": false
    },
    "ComplexPolySlabBase": {
      "title": "ComplexPolySlabBase",
      "description": "Interface for dividing a complex polyslab where self-intersecting polygon can\noccur during extrusion. This class should not be used directly. Use instead\n:class:`plugins.polyslab.ComplexPolySlab`.\n\nParameters\n----------\naxis : Literal[0, 1, 2] = 2\n    Specifies dimension of the planar axis (0,1,2) -> (x,y,z).\nsidewall_angle : ConstrainedFloatValue = 0.0\n    [units = rad].  Angle of the sidewall. ``sidewall_angle=0`` (default) specifies a vertical wall; ``0<sidewall_angle<np.pi/2`` specifies a shrinking cross section along the ``axis`` direction; and ``-np.pi/2<sidewall_angle<0`` specifies an expanding cross section along the ``axis`` direction.\nreference_plane : Literal['bottom', 'middle', 'top'] = middle\n    The position of the plane where the supplied cross section are defined. The plane is perpendicular to the ``axis``. The plane is located at the ``bottom``, ``middle``, or ``top`` of the geometry with respect to the axis. E.g. if ``axis=1``, ``bottom`` refers to the negative side of the y-axis, and ``top`` refers to the positive side of the y-axis.\nslab_bounds : Tuple[float, float]\n    [units = um].  Minimum and maximum positions of the slab along axis dimension.\ndilation : float = 0.0\n    [units = um].  Dilation of the supplied polygon by shifting each edge along its normal outwards direction by a distance; a negative value corresponds to erosion.\nvertices : ArrayLike[dtype=float, ndim=2]\n    [units = um].  List of (d1, d2) defining the 2 dimensional positions of the polygon face vertices at the ``reference_plane``. The index of dimension should be in the ascending order: e.g. if the slab normal axis is ``axis=y``, the coordinate of the vertices will be in (x, z)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "ComplexPolySlabBase",
          "enum": [
            "ComplexPolySlabBase"
          ],
          "type": "string"
        },
        "axis": {
          "title": "Axis",
          "description": "Specifies dimension of the planar axis (0,1,2) -> (x,y,z).",
          "default": 2,
          "enum": [
            0,
            1,
            2
          ],
          "type": "integer"
        },
        "sidewall_angle": {
          "title": "Sidewall angle",
          "description": "Angle of the sidewall. ``sidewall_angle=0`` (default) specifies a vertical wall; ``0<sidewall_angle<np.pi/2`` specifies a shrinking cross section along the ``axis`` direction; and ``-np.pi/2<sidewall_angle<0`` specifies an expanding cross section along the ``axis`` direction.",
          "default": 0.0,
          "exclusiveMinimum": -1.5707963267948966,
          "exclusiveMaximum": 1.5707963267948966,
          "units": "rad",
          "type": "number"
        },
        "reference_plane": {
          "title": "Reference plane for cross section",
          "description": "The position of the plane where the supplied cross section are defined. The plane is perpendicular to the ``axis``. The plane is located at the ``bottom``, ``middle``, or ``top`` of the geometry with respect to the axis. E.g. if ``axis=1``, ``bottom`` refers to the negative side of the y-axis, and ``top`` refers to the positive side of the y-axis.",
          "default": "middle",
          "enum": [
            "bottom",
            "middle",
            "top"
          ],
          "type": "string"
        },
        "slab_bounds": {
          "title": "Slab Bounds",
          "description": "Minimum and maximum positions of the slab along axis dimension.",
          "units": "um",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "dilation": {
          "title": "Dilation",
          "description": "Dilation of the supplied polygon by shifting each edge along its normal outwards direction by a distance; a negative value corresponds to erosion.",
          "default": 0.0,
          "units": "um",
          "type": "number"
        },
        "vertices": {
          "title": "Vertices",
          "description": "List of (d1, d2) defining the 2 dimensional positions of the polygon face vertices at the ``reference_plane``. The index of dimension should be in the ascending order: e.g. if the slab normal axis is ``axis=y``, the coordinate of the vertices will be in (x, z)",
          "units": "um",
          "type": "ArrayLike"
        }
      },
      "required": [
        "slab_bounds",
        "vertices"
      ],
      "additionalProperties": false
    },
    "TriangleMeshDataset": {
      "title": "TriangleMeshDataset",
      "description": "Dataset for storing triangular surface data.\n\nParameters\n----------\nsurface_mesh : TriangleMeshDataArray\n    Dataset containing the surface triangles and corresponding face indices for a surface mesh.",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "TriangleMeshDataset",
          "enum": [
            "TriangleMeshDataset"
          ],
          "type": "string"
        },
        "surface_mesh": {
          "title": "DataArray",
          "description": "Dataset containing the surface triangles and corresponding face indices for a surface mesh.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        }
      },
      "required": [
        "surface_mesh"
      ],
      "additionalProperties": false
    },
    "TriangleMesh": {
      "title": "TriangleMesh",
      "description": "Custom surface geometry given by a triangle mesh, as in the STL file format.\n\nParameters\n----------\nmesh_dataset : Optional[TriangleMeshDataset]\n    Surface mesh data.\n\nExample\n-------\n>>> vertices = np.array([[0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1]])\n>>> faces = np.array([[1, 2, 3], [0, 3, 2], [0, 1, 3], [0, 2, 1]])\n>>> stl_geom = TriangleMesh.from_vertices_faces(vertices, faces)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "TriangleMesh",
          "enum": [
            "TriangleMesh"
          ],
          "type": "string"
        },
        "mesh_dataset": {
          "title": "Surface mesh data",
          "description": "Surface mesh data.",
          "allOf": [
            {
              "$ref": "#/definitions/TriangleMeshDataset"
            }
          ]
        }
      },
      "required": [
        "mesh_dataset"
      ],
      "additionalProperties": false
    },
    "GeometryGroup": {
      "title": "GeometryGroup",
      "description": "A collection of Geometry objects that can be called as a single geometry object.\n\nParameters\n----------\ngeometries : ForwardRef('Tuple[annotate_type(GeometryType), ...]')\n    Tuple of geometries in a single grouping. Can provide significant performance enhancement in ``Structure`` when all geometries are assigned the same medium.",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "GeometryGroup",
          "enum": [
            "GeometryGroup"
          ],
          "type": "string"
        },
        "geometries": {
          "title": "Geometries",
          "description": "Tuple of geometries in a single grouping. Can provide significant performance enhancement in ``Structure`` when all geometries are assigned the same medium.",
          "type": "array",
          "items": {
            "discriminator": {
              "propertyName": "type",
              "mapping": {
                "Box": "#/definitions/Box",
                "Transformed": "#/definitions/Transformed",
                "ClipOperation": "#/definitions/ClipOperation",
                "GeometryGroup": "#/definitions/GeometryGroup",
                "Sphere": "#/definitions/Sphere",
                "Cylinder": "#/definitions/Cylinder",
                "PolySlab": "#/definitions/PolySlab",
                "ComplexPolySlabBase": "#/definitions/ComplexPolySlabBase",
                "TriangleMesh": "#/definitions/TriangleMesh"
              }
            },
            "oneOf": [
              {
                "$ref": "#/definitions/Box"
              },
              {
                "$ref": "#/definitions/Transformed"
              },
              {
                "$ref": "#/definitions/ClipOperation"
              },
              {
                "$ref": "#/definitions/GeometryGroup"
              },
              {
                "$ref": "#/definitions/Sphere"
              },
              {
                "$ref": "#/definitions/Cylinder"
              },
              {
                "$ref": "#/definitions/PolySlab"
              },
              {
                "$ref": "#/definitions/ComplexPolySlabBase"
              },
              {
                "$ref": "#/definitions/TriangleMesh"
              }
            ]
          }
        }
      },
      "required": [
        "geometries"
      ],
      "additionalProperties": false
    },
    "ClipOperation": {
      "title": "ClipOperation",
      "description": "Class representing the result of a set operation between geometries.\n\nParameters\n----------\noperation : Literal['union', 'intersection', 'difference', 'symmetric_difference']\n    Operation to be performed between geometries.\ngeometry_a : ForwardRef('annotate_type(GeometryType)')\n    First operand for the set operation. It can be any geometry type, including :class:`GeometryGroup`.\ngeometry_b : ForwardRef('annotate_type(GeometryType)')\n    Second operand for the set operation. It can also be any geometry type.",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "ClipOperation",
          "enum": [
            "ClipOperation"
          ],
          "type": "string"
        },
        "operation": {
          "title": "Operation Type",
          "description": "Operation to be performed between geometries.",
          "enum": [
            "union",
            "intersection",
            "difference",
            "symmetric_difference"
          ],
          "type": "string"
        },
        "geometry_a": {
          "title": "Geometry A",
          "description": "First operand for the set operation. It can be any geometry type, including :class:`GeometryGroup`.",
          "anyOf": [
            {
              "$ref": "#/definitions/Box"
            },
            {
              "$ref": "#/definitions/Transformed"
            },
            {
              "$ref": "#/definitions/ClipOperation"
            },
            {
              "$ref": "#/definitions/GeometryGroup"
            },
            {
              "$ref": "#/definitions/Sphere"
            },
            {
              "$ref": "#/definitions/Cylinder"
            },
            {
              "$ref": "#/definitions/PolySlab"
            },
            {
              "$ref": "#/definitions/ComplexPolySlabBase"
            },
            {
              "$ref": "#/definitions/TriangleMesh"
            }
          ]
        },
        "geometry_b": {
          "title": "Geometry B",
          "description": "Second operand for the set operation. It can also be any geometry type.",
          "anyOf": [
            {
              "$ref": "#/definitions/Box"
            },
            {
              "$ref": "#/definitions/Transformed"
            },
            {
              "$ref": "#/definitions/ClipOperation"
            },
            {
              "$ref": "#/definitions/GeometryGroup"
            },
            {
              "$ref": "#/definitions/Sphere"
            },
            {
              "$ref": "#/definitions/Cylinder"
            },
            {
              "$ref": "#/definitions/PolySlab"
            },
            {
              "$ref": "#/definitions/ComplexPolySlabBase"
            },
            {
              "$ref": "#/definitions/TriangleMesh"
            }
          ]
        }
      },
      "required": [
        "operation",
        "geometry_a",
        "geometry_b"
      ],
      "additionalProperties": false
    },
    "Transformed": {
      "title": "Transformed",
      "description": "Class representing a transformed geometry.\n\nParameters\n----------\ngeometry : ForwardRef('annotate_type(GeometryType)')\n    Base geometry to be transformed.\ntransform : ArrayLike[dtype=float, ndim=2, shape=(4, 4)] = [[1.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0]]\n    Transform matrix applied to the base geometry.",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "Transformed",
          "enum": [
            "Transformed"
          ],
          "type": "string"
        },
        "geometry": {
          "title": "Geometry",
          "description": "Base geometry to be transformed.",
          "anyOf": [
            {
              "$ref": "#/definitions/Box"
            },
            {
              "$ref": "#/definitions/Transformed"
            },
            {
              "$ref": "#/definitions/ClipOperation"
            },
            {
              "$ref": "#/definitions/GeometryGroup"
            },
            {
              "$ref": "#/definitions/Sphere"
            },
            {
              "$ref": "#/definitions/Cylinder"
            },
            {
              "$ref": "#/definitions/PolySlab"
            },
            {
              "$ref": "#/definitions/ComplexPolySlabBase"
            },
            {
              "$ref": "#/definitions/TriangleMesh"
            }
          ]
        },
        "transform": {
          "title": "Transform",
          "description": "Transform matrix applied to the base geometry.",
          "default": [
            [
              1.0,
              0.0,
              0.0,
              0.0
            ],
            [
              0.0,
              1.0,
              0.0,
              0.0
            ],
            [
              0.0,
              0.0,
              1.0,
              0.0
            ],
            [
              0.0,
              0.0,
              0.0,
              1.0
            ]
          ],
          "type": "ArrayLike"
        }
      },
      "required": [
        "geometry"
      ],
      "additionalProperties": false
    },
    "Medium2D": {
      "title": "Medium2D",
      "description": "2D diagonally anisotropic medium.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\nss : Union[Medium, PoleResidue, Sellmeier, Lorentz, Debye, Drude, PECMedium]\n    Medium describing the ss-component of the diagonal permittivity tensor. The ss-component refers to the in-plane dimension of the medium that is the first component in order of 'x', 'y', 'z'. If the 2D material is normal to the y-axis, for example, then this determines the xx-component of the corresponding 3D medium.\ntt : Union[Medium, PoleResidue, Sellmeier, Lorentz, Debye, Drude, PECMedium]\n    Medium describing the tt-component of the diagonal permittivity tensor. The tt-component refers to the in-plane dimension of the medium that is the second component in order of 'x', 'y', 'z'. If the 2D material is normal to the y-axis, for example, then this determines the zz-component of the corresponding 3D medium.\n\nNote\n----\nOnly diagonal anisotropy is currently supported.\n\nExample\n-------\n>>> drude_medium = Drude(eps_inf=2.0, coeffs=[(1,2), (3,4)])\n>>> medium2d = Medium2D(ss=drude_medium, tt=drude_medium)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "allow_gain": {
          "title": "Allow gain medium",
          "description": "Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.",
          "default": false,
          "type": "boolean"
        },
        "nonlinear_spec": {
          "title": "Nonlinear Spec",
          "description": "Nonlinear spec applied on top of the base medium properties.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonlinearSpec"
            },
            {
              "$ref": "#/definitions/NonlinearSusceptibility"
            }
          ]
        },
        "modulation_spec": {
          "title": "Modulation Spec",
          "description": "Modulation spec applied on top of the base medium properties.",
          "allOf": [
            {
              "$ref": "#/definitions/ModulationSpec"
            }
          ]
        },
        "heat_spec": {
          "title": "Heat Specification",
          "description": "Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "FluidSpec": "#/definitions/FluidSpec",
              "SolidSpec": "#/definitions/SolidSpec"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/FluidSpec"
            },
            {
              "$ref": "#/definitions/SolidSpec"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Medium2D",
          "enum": [
            "Medium2D"
          ],
          "type": "string"
        },
        "ss": {
          "title": "SS Component",
          "description": "Medium describing the ss-component of the diagonal permittivity tensor. The ss-component refers to the in-plane dimension of the medium that is the first component in order of 'x', 'y', 'z'. If the 2D material is normal to the y-axis, for example, then this determines the xx-component of the corresponding 3D medium.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "Medium": "#/definitions/Medium",
              "PoleResidue": "#/definitions/PoleResidue",
              "Sellmeier": "#/definitions/Sellmeier",
              "Lorentz": "#/definitions/Lorentz",
              "Debye": "#/definitions/Debye",
              "Drude": "#/definitions/Drude",
              "PECMedium": "#/definitions/PECMedium"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/Medium"
            },
            {
              "$ref": "#/definitions/PoleResidue"
            },
            {
              "$ref": "#/definitions/Sellmeier"
            },
            {
              "$ref": "#/definitions/Lorentz"
            },
            {
              "$ref": "#/definitions/Debye"
            },
            {
              "$ref": "#/definitions/Drude"
            },
            {
              "$ref": "#/definitions/PECMedium"
            }
          ]
        },
        "tt": {
          "title": "TT Component",
          "description": "Medium describing the tt-component of the diagonal permittivity tensor. The tt-component refers to the in-plane dimension of the medium that is the second component in order of 'x', 'y', 'z'. If the 2D material is normal to the y-axis, for example, then this determines the zz-component of the corresponding 3D medium.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "Medium": "#/definitions/Medium",
              "PoleResidue": "#/definitions/PoleResidue",
              "Sellmeier": "#/definitions/Sellmeier",
              "Lorentz": "#/definitions/Lorentz",
              "Debye": "#/definitions/Debye",
              "Drude": "#/definitions/Drude",
              "PECMedium": "#/definitions/PECMedium"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/Medium"
            },
            {
              "$ref": "#/definitions/PoleResidue"
            },
            {
              "$ref": "#/definitions/Sellmeier"
            },
            {
              "$ref": "#/definitions/Lorentz"
            },
            {
              "$ref": "#/definitions/Debye"
            },
            {
              "$ref": "#/definitions/Drude"
            },
            {
              "$ref": "#/definitions/PECMedium"
            }
          ]
        }
      },
      "required": [
        "ss",
        "tt"
      ],
      "additionalProperties": false
    },
    "Structure": {
      "title": "Structure",
      "description": "Defines a physical object that interacts with the electromagnetic fields.\nA :class:`Structure` is a combination of a material property (:class:`AbstractMedium`)\nand a :class:`Geometry`.\n\nParameters\n----------\ngeometry : Union[Box, Transformed, ClipOperation, GeometryGroup, Sphere, Cylinder, PolySlab, ComplexPolySlabBase, TriangleMesh]\n    Defines geometric properties of the structure.\nname : Optional[str] = None\n    Optional name for the structure.\nmedium : Union[Medium, AnisotropicMedium, PECMedium, PoleResidue, Sellmeier, Lorentz, Debye, Drude, FullyAnisotropicMedium, CustomMedium, CustomPoleResidue, CustomSellmeier, CustomLorentz, CustomDebye, CustomDrude, CustomAnisotropicMedium, PerturbationMedium, PerturbationPoleResidue, Medium2D]\n    Defines the electromagnetic properties of the structure's medium.\n\nExample\n-------\n>>> from tidy3d import Box, Medium\n>>> box = Box(center=(0,0,1), size=(2, 2, 2))\n>>> glass = Medium(permittivity=3.9)\n>>> struct = Structure(geometry=box, medium=glass, name='glass_box')",
      "type": "object",
      "properties": {
        "geometry": {
          "title": "Geometry",
          "description": "Defines geometric properties of the structure.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "Box": "#/definitions/Box",
              "Transformed": "#/definitions/Transformed",
              "ClipOperation": "#/definitions/ClipOperation",
              "GeometryGroup": "#/definitions/GeometryGroup",
              "Sphere": "#/definitions/Sphere",
              "Cylinder": "#/definitions/Cylinder",
              "PolySlab": "#/definitions/PolySlab",
              "ComplexPolySlabBase": "#/definitions/ComplexPolySlabBase",
              "TriangleMesh": "#/definitions/TriangleMesh"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/Box"
            },
            {
              "$ref": "#/definitions/Transformed"
            },
            {
              "$ref": "#/definitions/ClipOperation"
            },
            {
              "$ref": "#/definitions/GeometryGroup"
            },
            {
              "$ref": "#/definitions/Sphere"
            },
            {
              "$ref": "#/definitions/Cylinder"
            },
            {
              "$ref": "#/definitions/PolySlab"
            },
            {
              "$ref": "#/definitions/ComplexPolySlabBase"
            },
            {
              "$ref": "#/definitions/TriangleMesh"
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Optional name for the structure.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "Structure",
          "enum": [
            "Structure"
          ],
          "type": "string"
        },
        "medium": {
          "title": "Medium",
          "description": "Defines the electromagnetic properties of the structure's medium.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "Medium": "#/definitions/Medium",
              "AnisotropicMedium": "#/definitions/AnisotropicMedium",
              "PECMedium": "#/definitions/PECMedium",
              "PoleResidue": "#/definitions/PoleResidue",
              "Sellmeier": "#/definitions/Sellmeier",
              "Lorentz": "#/definitions/Lorentz",
              "Debye": "#/definitions/Debye",
              "Drude": "#/definitions/Drude",
              "FullyAnisotropicMedium": "#/definitions/FullyAnisotropicMedium",
              "CustomMedium": "#/definitions/CustomMedium",
              "CustomPoleResidue": "#/definitions/CustomPoleResidue",
              "CustomSellmeier": "#/definitions/CustomSellmeier",
              "CustomLorentz": "#/definitions/CustomLorentz",
              "CustomDebye": "#/definitions/CustomDebye",
              "CustomDrude": "#/definitions/CustomDrude",
              "CustomAnisotropicMedium": "#/definitions/CustomAnisotropicMedium",
              "PerturbationMedium": "#/definitions/PerturbationMedium",
              "PerturbationPoleResidue": "#/definitions/PerturbationPoleResidue",
              "Medium2D": "#/definitions/Medium2D"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/Medium"
            },
            {
              "$ref": "#/definitions/AnisotropicMedium"
            },
            {
              "$ref": "#/definitions/PECMedium"
            },
            {
              "$ref": "#/definitions/PoleResidue"
            },
            {
              "$ref": "#/definitions/Sellmeier"
            },
            {
              "$ref": "#/definitions/Lorentz"
            },
            {
              "$ref": "#/definitions/Debye"
            },
            {
              "$ref": "#/definitions/Drude"
            },
            {
              "$ref": "#/definitions/FullyAnisotropicMedium"
            },
            {
              "$ref": "#/definitions/CustomMedium"
            },
            {
              "$ref": "#/definitions/CustomPoleResidue"
            },
            {
              "$ref": "#/definitions/CustomSellmeier"
            },
            {
              "$ref": "#/definitions/CustomLorentz"
            },
            {
              "$ref": "#/definitions/CustomDebye"
            },
            {
              "$ref": "#/definitions/CustomDrude"
            },
            {
              "$ref": "#/definitions/CustomAnisotropicMedium"
            },
            {
              "$ref": "#/definitions/PerturbationMedium"
            },
            {
              "$ref": "#/definitions/PerturbationPoleResidue"
            },
            {
              "$ref": "#/definitions/Medium2D"
            }
          ]
        }
      },
      "required": [
        "geometry",
        "medium"
      ],
      "additionalProperties": false
    },
    "GaussianPulse": {
      "title": "GaussianPulse",
      "description": "Source time dependence that describes a Gaussian pulse.\n\nParameters\n----------\namplitude : NonNegativeFloat = 1.0\n    Real-valued maximum amplitude of the time dependence.\nphase : float = 0.0\n    [units = rad].  Phase shift of the time dependence.\nfreq0 : PositiveFloat\n    [units = Hz].  Central frequency of the pulse.\nfwidth : PositiveFloat\n    [units = Hz].  Standard deviation of the frequency content of the pulse.\noffset : ConstrainedFloatValue = 5.0\n    Time delay of the maximum value of the pulse in units of 1 / (``2pi * fwidth``).\nremove_dc_component : bool = True\n    Whether to remove the DC component in the Gaussian pulse spectrum. If ``True``, the Gaussian pulse is modified at low frequencies to zero out the DC component, which is usually desirable so that the fields will decay. However, for broadband simulations, it may be better to have non-vanishing source power near zero frequency. Setting this to ``False`` results in an unmodified Gaussian pulse spectrum which can have a nonzero DC component.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)",
      "type": "object",
      "properties": {
        "amplitude": {
          "title": "Amplitude",
          "description": "Real-valued maximum amplitude of the time dependence.",
          "default": 1.0,
          "minimum": 0,
          "type": "number"
        },
        "phase": {
          "title": "Phase",
          "description": "Phase shift of the time dependence.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "type": {
          "title": "Type",
          "default": "GaussianPulse",
          "enum": [
            "GaussianPulse"
          ],
          "type": "string"
        },
        "freq0": {
          "title": "Central Frequency",
          "description": "Central frequency of the pulse.",
          "units": "Hz",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "fwidth": {
          "title": "Fwidth",
          "description": "Standard deviation of the frequency content of the pulse.",
          "units": "Hz",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "offset": {
          "title": "Offset",
          "description": "Time delay of the maximum value of the pulse in units of 1 / (``2pi * fwidth``).",
          "default": 5.0,
          "minimum": 2.5,
          "type": "number"
        },
        "remove_dc_component": {
          "title": "Remove DC Component",
          "description": "Whether to remove the DC component in the Gaussian pulse spectrum. If ``True``, the Gaussian pulse is modified at low frequencies to zero out the DC component, which is usually desirable so that the fields will decay. However, for broadband simulations, it may be better to have non-vanishing source power near zero frequency. Setting this to ``False`` results in an unmodified Gaussian pulse spectrum which can have a nonzero DC component.",
          "default": true,
          "type": "boolean"
        }
      },
      "required": [
        "freq0",
        "fwidth"
      ],
      "additionalProperties": false
    },
    "ContinuousWave": {
      "title": "ContinuousWave",
      "description": "Source time dependence that ramps up to continuous oscillation\nand holds until end of simulation.\n\nParameters\n----------\namplitude : NonNegativeFloat = 1.0\n    Real-valued maximum amplitude of the time dependence.\nphase : float = 0.0\n    [units = rad].  Phase shift of the time dependence.\nfreq0 : PositiveFloat\n    [units = Hz].  Central frequency of the pulse.\nfwidth : PositiveFloat\n    [units = Hz].  Standard deviation of the frequency content of the pulse.\noffset : ConstrainedFloatValue = 5.0\n    Time delay of the maximum value of the pulse in units of 1 / (``2pi * fwidth``).\n\nNote\n----\nField decay will not occur, so the simulation will run for the full ``run_time``.\nAlso, source normalization of frequency-domain monitors is not meaningful.\n\nExample\n-------\n>>> cw = ContinuousWave(freq0=200e12, fwidth=20e12)",
      "type": "object",
      "properties": {
        "amplitude": {
          "title": "Amplitude",
          "description": "Real-valued maximum amplitude of the time dependence.",
          "default": 1.0,
          "minimum": 0,
          "type": "number"
        },
        "phase": {
          "title": "Phase",
          "description": "Phase shift of the time dependence.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "type": {
          "title": "Type",
          "default": "ContinuousWave",
          "enum": [
            "ContinuousWave"
          ],
          "type": "string"
        },
        "freq0": {
          "title": "Central Frequency",
          "description": "Central frequency of the pulse.",
          "units": "Hz",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "fwidth": {
          "title": "Fwidth",
          "description": "Standard deviation of the frequency content of the pulse.",
          "units": "Hz",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "offset": {
          "title": "Offset",
          "description": "Time delay of the maximum value of the pulse in units of 1 / (``2pi * fwidth``).",
          "default": 5.0,
          "minimum": 2.5,
          "type": "number"
        }
      },
      "required": [
        "freq0",
        "fwidth"
      ],
      "additionalProperties": false
    },
    "TimeDataset": {
      "title": "TimeDataset",
      "description": "Dataset for storing a function of time.\n\nParameters\n----------\nvalues : TimeDataArray\n    Values as a function of time.",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "TimeDataset",
          "enum": [
            "TimeDataset"
          ],
          "type": "string"
        },
        "values": {
          "title": "DataArray",
          "description": "Values as a function of time.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        }
      },
      "required": [
        "values"
      ],
      "additionalProperties": false
    },
    "CustomSourceTime": {
      "title": "CustomSourceTime",
      "description": "Custom source time dependence consisting of a real or complex envelope\nmodulated at a central frequency, as shown below.\n\nParameters\n----------\namplitude : NonNegativeFloat = 1.0\n    Real-valued maximum amplitude of the time dependence.\nphase : float = 0.0\n    [units = rad].  Phase shift of the time dependence.\nfreq0 : PositiveFloat\n    [units = Hz].  Central frequency of the pulse.\nfwidth : PositiveFloat\n    [units = Hz].  Standard deviation of the frequency content of the pulse.\noffset : float = 0.0\n    Time delay of the envelope in units of 1 / (``2pi * fwidth``).\nsource_time_dataset : Optional[TimeDataset]\n    Dataset for storing the envelope of the custom source time. This envelope will be modulated by a complex exponential at frequency ``freq0``.\n\nNote\n----\n.. math::\n\n    amp\\_time(t) = amplitude \\cdot \\\n            e^{i \\cdot phase - 2 \\pi i \\cdot freq0 \\cdot t} \\cdot \\\n            envelope(t - offset / (2 \\pi \\cdot fwidth))\n\nNote\n----\nDepending on the envelope, field decay may not occur.\nIf field decay does not occur, then the simulation will run for the full ``run_time``.\nAlso, if field decay does not occur, then source normalization of frequency-domain\nmonitors is not meaningful.\n\nNote\n----\nThe source time dependence is linearly interpolated to the simulation time steps.\nThe sampling rate should be sufficiently fast that this interpolation does not\nintroduce artifacts. The source time dependence should also start at zero and ramp up smoothly.\nThe first and last values of the envelope will be used for times that are out of range\nof the provided data.\n\nExample\n-------\n>>> cst = CustomSourceTime.from_values(freq0=1, fwidth=0.1,\n...     values=np.linspace(0, 9, 10), dt=0.1)",
      "type": "object",
      "properties": {
        "amplitude": {
          "title": "Amplitude",
          "description": "Real-valued maximum amplitude of the time dependence.",
          "default": 1.0,
          "minimum": 0,
          "type": "number"
        },
        "phase": {
          "title": "Phase",
          "description": "Phase shift of the time dependence.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "type": {
          "title": "Type",
          "default": "CustomSourceTime",
          "enum": [
            "CustomSourceTime"
          ],
          "type": "string"
        },
        "freq0": {
          "title": "Central Frequency",
          "description": "Central frequency of the pulse.",
          "units": "Hz",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "fwidth": {
          "title": "Fwidth",
          "description": "Standard deviation of the frequency content of the pulse.",
          "units": "Hz",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "offset": {
          "title": "Offset",
          "description": "Time delay of the envelope in units of 1 / (``2pi * fwidth``).",
          "default": 0.0,
          "type": "number"
        },
        "source_time_dataset": {
          "title": "Source time dataset",
          "description": "Dataset for storing the envelope of the custom source time. This envelope will be modulated by a complex exponential at frequency ``freq0``.",
          "allOf": [
            {
              "$ref": "#/definitions/TimeDataset"
            }
          ]
        }
      },
      "required": [
        "freq0",
        "fwidth",
        "source_time_dataset"
      ],
      "additionalProperties": false
    },
    "UniformCurrentSource": {
      "title": "UniformCurrentSource",
      "description": "Source in a rectangular volume with uniform time dependence. size=(0,0,0) gives point source.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional name for the source.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave, CustomSourceTime]\n    Specification of the source time-dependence.\ninterpolate : bool = True\n    Handles reverse-interpolation of zero-size dimensions of the source. If ``False``, the source data is snapped to the nearest Yee grid point. If ``True``, equivalent source data is applied on the surrounding Yee grid points to emulate placement at the specified location using linear interpolation.\npolarization : Literal['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']\n    Specifies the direction and type of current component.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> pt_source = UniformCurrentSource(size=(0,0,0), source_time=pulse, polarization='Ex')",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "UniformCurrentSource",
          "enum": [
            "UniformCurrentSource"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "GaussianPulse": "#/definitions/GaussianPulse",
              "ContinuousWave": "#/definitions/ContinuousWave",
              "CustomSourceTime": "#/definitions/CustomSourceTime"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            },
            {
              "$ref": "#/definitions/CustomSourceTime"
            }
          ]
        },
        "interpolate": {
          "title": "Enable Interpolation",
          "description": "Handles reverse-interpolation of zero-size dimensions of the source. If ``False``, the source data is snapped to the nearest Yee grid point. If ``True``, equivalent source data is applied on the surrounding Yee grid points to emulate placement at the specified location using linear interpolation.",
          "default": true,
          "type": "boolean"
        },
        "polarization": {
          "title": "Polarization",
          "description": "Specifies the direction and type of current component.",
          "enum": [
            "Ex",
            "Ey",
            "Ez",
            "Hx",
            "Hy",
            "Hz"
          ],
          "type": "string"
        }
      },
      "required": [
        "size",
        "source_time",
        "polarization"
      ],
      "additionalProperties": false
    },
    "PointDipole": {
      "title": "PointDipole",
      "description": "Uniform current source with a zero size.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional name for the source.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[typing_extensions.Literal[0], typing_extensions.Literal[0], typing_extensions.Literal[0]] = (0, 0, 0)\n    [units = um].  Size in x, y, and z directions, constrained to ``(0, 0, 0)``.\nsource_time : Union[GaussianPulse, ContinuousWave, CustomSourceTime]\n    Specification of the source time-dependence.\ninterpolate : bool = True\n    Handles reverse-interpolation of zero-size dimensions of the source. If ``False``, the source data is snapped to the nearest Yee grid point. If ``True``, equivalent source data is applied on the surrounding Yee grid points to emulate placement at the specified location using linear interpolation.\npolarization : Literal['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']\n    Specifies the direction and type of current component.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> pt_dipole = PointDipole(center=(1,2,3), source_time=pulse, polarization='Ex')",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "PointDipole",
          "enum": [
            "PointDipole"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions, constrained to ``(0, 0, 0)``.",
          "default": [
            0,
            0,
            0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "enum": [
                0
              ],
              "type": "integer"
            },
            {
              "enum": [
                0
              ],
              "type": "integer"
            },
            {
              "enum": [
                0
              ],
              "type": "integer"
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "GaussianPulse": "#/definitions/GaussianPulse",
              "ContinuousWave": "#/definitions/ContinuousWave",
              "CustomSourceTime": "#/definitions/CustomSourceTime"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            },
            {
              "$ref": "#/definitions/CustomSourceTime"
            }
          ]
        },
        "interpolate": {
          "title": "Enable Interpolation",
          "description": "Handles reverse-interpolation of zero-size dimensions of the source. If ``False``, the source data is snapped to the nearest Yee grid point. If ``True``, equivalent source data is applied on the surrounding Yee grid points to emulate placement at the specified location using linear interpolation.",
          "default": true,
          "type": "boolean"
        },
        "polarization": {
          "title": "Polarization",
          "description": "Specifies the direction and type of current component.",
          "enum": [
            "Ex",
            "Ey",
            "Ez",
            "Hx",
            "Hy",
            "Hz"
          ],
          "type": "string"
        }
      },
      "required": [
        "source_time",
        "polarization"
      ],
      "additionalProperties": false
    },
    "GaussianBeam": {
      "title": "GaussianBeam",
      "description": "Guassian distribution on finite extent plane.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional name for the source.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave, CustomSourceTime]\n    Specification of the source time-dependence.\nnum_freqs : ConstrainedIntValue = 1\n    Number of points used to approximate the frequency dependence of injected field. A Chebyshev interpolation is used, thus, only a small number of points, i.e., less than 20, is typically sufficient to obtain converged results.\ndirection : Literal['+', '-']\n    Specifies propagation in the positive or negative direction of the injection axis.\nangle_theta : float = 0.0\n    [units = rad].  Polar angle of the propagation axis from the injection axis.\nangle_phi : float = 0.0\n    [units = rad].  Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.\npol_angle : float = 0\n    [units = rad].  Specifies the angle between the electric field polarization of the source and the plane defined by the injection axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.\nwaist_radius : PositiveFloat = 1.0\n    [units = um].  Radius of the beam at the waist.\nwaist_distance : float = 0.0\n    [units = um].  Distance from the beam waist along the propagation direction. When ``direction`` is ``+`` and ``waist_distance`` is positive, the waist is on the ``-`` side (behind) the source plane. When ``direction`` is ``+`` and  ``waist_distance``is negative, the waist is on the ``+`` side (in front) of the source plane.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> gauss = GaussianBeam(\n...     size=(0,3,3),\n...     source_time=pulse,\n...     pol_angle=np.pi / 2,\n...     direction='+',\n...     waist_radius=1.0)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "GaussianBeam",
          "enum": [
            "GaussianBeam"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "GaussianPulse": "#/definitions/GaussianPulse",
              "ContinuousWave": "#/definitions/ContinuousWave",
              "CustomSourceTime": "#/definitions/CustomSourceTime"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            },
            {
              "$ref": "#/definitions/CustomSourceTime"
            }
          ]
        },
        "num_freqs": {
          "title": "Number of Frequency Points",
          "description": "Number of points used to approximate the frequency dependence of injected field. A Chebyshev interpolation is used, thus, only a small number of points, i.e., less than 20, is typically sufficient to obtain converged results.",
          "default": 1,
          "minimum": 1,
          "maximum": 99,
          "type": "integer"
        },
        "direction": {
          "title": "Direction",
          "description": "Specifies propagation in the positive or negative direction of the injection axis.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "angle_theta": {
          "title": "Polar Angle",
          "description": "Polar angle of the propagation axis from the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "angle_phi": {
          "title": "Azimuth Angle",
          "description": "Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "pol_angle": {
          "title": "Polarization Angle",
          "description": "Specifies the angle between the electric field polarization of the source and the plane defined by the injection axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.",
          "default": 0,
          "units": "rad",
          "type": "number"
        },
        "waist_radius": {
          "title": "Waist Radius",
          "description": "Radius of the beam at the waist.",
          "default": 1.0,
          "units": "um",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "waist_distance": {
          "title": "Waist Distance",
          "description": "Distance from the beam waist along the propagation direction. When ``direction`` is ``+`` and ``waist_distance`` is positive, the waist is on the ``-`` side (behind) the source plane. When ``direction`` is ``+`` and  ``waist_distance``is negative, the waist is on the ``+`` side (in front) of the source plane.",
          "default": 0.0,
          "units": "um",
          "type": "number"
        }
      },
      "required": [
        "size",
        "source_time",
        "direction"
      ],
      "additionalProperties": false
    },
    "AstigmaticGaussianBeam": {
      "title": "AstigmaticGaussianBeam",
      "description": "This class implements the simple astigmatic Gaussian beam described in Kochkina et al.,\nApplied Optics, vol. 52, issue 24, 2013. The simple astigmatic Guassian distribution allows\nboth an elliptical intensity profile and different waist locations for the two principal axes\nof the ellipse. When equal waist sizes and equal waist distances are specified in the two\ndirections, this source becomes equivalent to :class:`GaussianBeam`.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional name for the source.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave, CustomSourceTime]\n    Specification of the source time-dependence.\nnum_freqs : ConstrainedIntValue = 1\n    Number of points used to approximate the frequency dependence of injected field. A Chebyshev interpolation is used, thus, only a small number of points, i.e., less than 20, is typically sufficient to obtain converged results.\ndirection : Literal['+', '-']\n    Specifies propagation in the positive or negative direction of the injection axis.\nangle_theta : float = 0.0\n    [units = rad].  Polar angle of the propagation axis from the injection axis.\nangle_phi : float = 0.0\n    [units = rad].  Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.\npol_angle : float = 0\n    [units = rad].  Specifies the angle between the electric field polarization of the source and the plane defined by the injection axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.\nwaist_sizes : Tuple[PositiveFloat, PositiveFloat] = (1.0, 1.0)\n    [units = um].  Size of the beam at the waist in the local x and y directions.\nwaist_distances : Tuple[float, float] = (0.0, 0.0)\n    [units = um].  Distance to the beam waist along the propagation direction for the waist sizes in the local x and y directions. When ``direction`` is ``+`` and ``waist_distances`` are positive, the waist is on the ``-`` side (behind) the source plane. When ``direction`` is ``+`` and ``waist_distances`` are negative, the waist is on the ``+`` side (in front) of the source plane.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> gauss = AstigmaticGaussianBeam(\n...     size=(0,3,3),\n...     source_time=pulse,\n...     pol_angle=np.pi / 2,\n...     direction='+',\n...     waist_sizes=(1.0, 2.0),\n...     waist_distances = (3.0, 4.0))",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "AstigmaticGaussianBeam",
          "enum": [
            "AstigmaticGaussianBeam"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "GaussianPulse": "#/definitions/GaussianPulse",
              "ContinuousWave": "#/definitions/ContinuousWave",
              "CustomSourceTime": "#/definitions/CustomSourceTime"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            },
            {
              "$ref": "#/definitions/CustomSourceTime"
            }
          ]
        },
        "num_freqs": {
          "title": "Number of Frequency Points",
          "description": "Number of points used to approximate the frequency dependence of injected field. A Chebyshev interpolation is used, thus, only a small number of points, i.e., less than 20, is typically sufficient to obtain converged results.",
          "default": 1,
          "minimum": 1,
          "maximum": 99,
          "type": "integer"
        },
        "direction": {
          "title": "Direction",
          "description": "Specifies propagation in the positive or negative direction of the injection axis.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "angle_theta": {
          "title": "Polar Angle",
          "description": "Polar angle of the propagation axis from the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "angle_phi": {
          "title": "Azimuth Angle",
          "description": "Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "pol_angle": {
          "title": "Polarization Angle",
          "description": "Specifies the angle between the electric field polarization of the source and the plane defined by the injection axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.",
          "default": 0,
          "units": "rad",
          "type": "number"
        },
        "waist_sizes": {
          "title": "Waist sizes",
          "description": "Size of the beam at the waist in the local x and y directions.",
          "default": [
            1.0,
            1.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number",
              "exclusiveMinimum": 0
            },
            {
              "type": "number",
              "exclusiveMinimum": 0
            }
          ]
        },
        "waist_distances": {
          "title": "Waist distances",
          "description": "Distance to the beam waist along the propagation direction for the waist sizes in the local x and y directions. When ``direction`` is ``+`` and ``waist_distances`` are positive, the waist is on the ``-`` side (behind) the source plane. When ``direction`` is ``+`` and ``waist_distances`` are negative, the waist is on the ``+`` side (in front) of the source plane.",
          "default": [
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        }
      },
      "required": [
        "size",
        "source_time",
        "direction"
      ],
      "additionalProperties": false
    },
    "ModeSpec": {
      "title": "ModeSpec",
      "description": "Stores specifications for the mode solver to find an electromagntic mode.\nNote, the planar axes are found by popping the injection axis from {x,y,z}.\nFor example, if injection axis is y, the planar axes are ordered {x,z}.\n\nParameters\n----------\nnum_modes : PositiveInt = 1\n    Number of modes returned by mode solver.\ntarget_neff : Optional[PositiveFloat] = None\n    Guess for effective index of the mode.\nnum_pml : Tuple[NonNegativeInt, NonNegativeInt] = (0, 0)\n    Number of standard pml layers to add in the two tangential axes.\nfilter_pol : Optional[Literal['te', 'tm']] = None\n    The solver always computes the ``num_modes`` modes closest to the given ``target_neff``. If ``filter_pol==None``, they are simply sorted in order of decresing effective index. If a polarization filter is selected, the modes are rearranged such that the first ``n_pol`` modes in the list are the ones with the selected polarization fraction larger than or equal to 0.5, while the next ``num_modes - n_pol`` modes are the ones where it is smaller than 0.5 (i.e. the opposite polarization fraction is larger than 0.5). Within each polarization subset, the modes are still ordered by decreasing effective index. ``te``-fraction is defined as the integrated intensity of the E-field component parallel to the first plane axis, normalized to the total in-plane E-field intensity. Conversely, ``tm``-fraction uses the E field component parallel to the second plane axis.\nangle_theta : float = 0.0\n    [units = rad].  Polar angle of the propagation axis from the injection axis.\nangle_phi : float = 0.0\n    [units = rad].  Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.\nprecision : Literal['single', 'double'] = single\n    The solver will be faster and using less memory under single precision, but more accurate under double precision.\nbend_radius : Optional[float] = None\n    [units = um].  A curvature radius for simulation of waveguide bends. Can be negative, in which case the mode plane center has a smaller value than the curvature center along the tangential axis perpendicular to the bend axis.\nbend_axis : Optional[Literal[0, 1]] = None\n    Index into the two tangential axes defining the normal to the plane in which the bend lies. This must be provided if ``bend_radius`` is not ``None``. For example, for a ring in the global xy-plane, and a mode plane in either the xz or the yz plane, the ``bend_axis`` is always 1 (the global z axis).\ntrack_freq : Optional[Literal['central', 'lowest', 'highest']] = central\n    Parameter that turns on/off mode tracking based on their similarity. Can take values ``'lowest'``, ``'central'``, or ``'highest'``, which correspond to mode tracking based on the lowest, central, or highest frequency. If ``None`` no mode tracking is performed.\ngroup_index_step : Union[PositiveFloat, bool] = False\n    Control the computation of the group index alongside the effective index. If set to a positive value, it sets the fractional frequency step used in the numerical differentiation of the effective index to compute the group index. If set to `True`, the default of 0.005 is used.\n\nExample\n-------\n>>> mode_spec = ModeSpec(num_modes=3, target_neff=1.5)",
      "type": "object",
      "properties": {
        "num_modes": {
          "title": "Number of modes",
          "description": "Number of modes returned by mode solver.",
          "default": 1,
          "exclusiveMinimum": 0,
          "type": "integer"
        },
        "target_neff": {
          "title": "Target effective index",
          "description": "Guess for effective index of the mode.",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "num_pml": {
          "title": "Number of PML layers",
          "description": "Number of standard pml layers to add in the two tangential axes.",
          "default": [
            0,
            0
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "integer",
              "minimum": 0
            },
            {
              "type": "integer",
              "minimum": 0
            }
          ]
        },
        "filter_pol": {
          "title": "Polarization filtering",
          "description": "The solver always computes the ``num_modes`` modes closest to the given ``target_neff``. If ``filter_pol==None``, they are simply sorted in order of decresing effective index. If a polarization filter is selected, the modes are rearranged such that the first ``n_pol`` modes in the list are the ones with the selected polarization fraction larger than or equal to 0.5, while the next ``num_modes - n_pol`` modes are the ones where it is smaller than 0.5 (i.e. the opposite polarization fraction is larger than 0.5). Within each polarization subset, the modes are still ordered by decreasing effective index. ``te``-fraction is defined as the integrated intensity of the E-field component parallel to the first plane axis, normalized to the total in-plane E-field intensity. Conversely, ``tm``-fraction uses the E field component parallel to the second plane axis.",
          "enum": [
            "te",
            "tm"
          ],
          "type": "string"
        },
        "angle_theta": {
          "title": "Polar Angle",
          "description": "Polar angle of the propagation axis from the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "angle_phi": {
          "title": "Azimuth Angle",
          "description": "Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "precision": {
          "title": "single or double precision in mode solver",
          "description": "The solver will be faster and using less memory under single precision, but more accurate under double precision.",
          "default": "single",
          "enum": [
            "single",
            "double"
          ],
          "type": "string"
        },
        "bend_radius": {
          "title": "Bend radius",
          "description": "A curvature radius for simulation of waveguide bends. Can be negative, in which case the mode plane center has a smaller value than the curvature center along the tangential axis perpendicular to the bend axis.",
          "units": "um",
          "type": "number"
        },
        "bend_axis": {
          "title": "Bend axis",
          "description": "Index into the two tangential axes defining the normal to the plane in which the bend lies. This must be provided if ``bend_radius`` is not ``None``. For example, for a ring in the global xy-plane, and a mode plane in either the xz or the yz plane, the ``bend_axis`` is always 1 (the global z axis).",
          "enum": [
            0,
            1
          ],
          "type": "integer"
        },
        "track_freq": {
          "title": "Mode Tracking Frequency",
          "description": "Parameter that turns on/off mode tracking based on their similarity. Can take values ``'lowest'``, ``'central'``, or ``'highest'``, which correspond to mode tracking based on the lowest, central, or highest frequency. If ``None`` no mode tracking is performed.",
          "default": "central",
          "enum": [
            "central",
            "lowest",
            "highest"
          ],
          "type": "string"
        },
        "group_index_step": {
          "title": "Frequency step for group index computation",
          "description": "Control the computation of the group index alongside the effective index. If set to a positive value, it sets the fractional frequency step used in the numerical differentiation of the effective index to compute the group index. If set to `True`, the default of 0.005 is used.",
          "default": false,
          "anyOf": [
            {
              "type": "number",
              "exclusiveMinimum": 0
            },
            {
              "type": "boolean"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "ModeSpec",
          "enum": [
            "ModeSpec"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "ModeSource": {
      "title": "ModeSource",
      "description": "Injects current source to excite modal profile on finite extent plane.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional name for the source.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave, CustomSourceTime]\n    Specification of the source time-dependence.\nnum_freqs : ConstrainedIntValue = 1\n    Number of points used to approximate the frequency dependence of injected field. A Chebyshev interpolation is used, thus, only a small number of points, i.e., less than 20, is typically sufficient to obtain converged results.\ndirection : Literal['+', '-']\n    Specifies propagation in the positive or negative direction of the injection axis.\nmode_spec : ModeSpec = ModeSpec(num_modes=1, target_neff=None, num_pml=(0,, 0), filter_pol=None, angle_theta=0.0, angle_phi=0.0, precision='single', bend_radius=None, bend_axis=None, track_freq='central', group_index_step=False, type='ModeSpec')\n    Parameters to feed to mode solver which determine modes measured by monitor.\nmode_index : NonNegativeInt = 0\n    Index into the collection of modes returned by mode solver.  Specifies which mode to inject using this source. If larger than ``mode_spec.num_modes``, ``num_modes`` in the solver will be set to ``mode_index + 1``.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> mode_spec = ModeSpec(target_neff=2.)\n>>> mode_source = ModeSource(\n...     size=(10,10,0),\n...     source_time=pulse,\n...     mode_spec=mode_spec,\n...     mode_index=1,\n...     direction='-')",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "ModeSource",
          "enum": [
            "ModeSource"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "GaussianPulse": "#/definitions/GaussianPulse",
              "ContinuousWave": "#/definitions/ContinuousWave",
              "CustomSourceTime": "#/definitions/CustomSourceTime"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            },
            {
              "$ref": "#/definitions/CustomSourceTime"
            }
          ]
        },
        "num_freqs": {
          "title": "Number of Frequency Points",
          "description": "Number of points used to approximate the frequency dependence of injected field. A Chebyshev interpolation is used, thus, only a small number of points, i.e., less than 20, is typically sufficient to obtain converged results.",
          "default": 1,
          "minimum": 1,
          "maximum": 99,
          "type": "integer"
        },
        "direction": {
          "title": "Direction",
          "description": "Specifies propagation in the positive or negative direction of the injection axis.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "mode_spec": {
          "title": "Mode Specification",
          "description": "Parameters to feed to mode solver which determine modes measured by monitor.",
          "default": {
            "num_modes": 1,
            "target_neff": null,
            "num_pml": [
              0,
              0
            ],
            "filter_pol": null,
            "angle_theta": 0.0,
            "angle_phi": 0.0,
            "precision": "single",
            "bend_radius": null,
            "bend_axis": null,
            "track_freq": "central",
            "group_index_step": false,
            "type": "ModeSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ModeSpec"
            }
          ]
        },
        "mode_index": {
          "title": "Mode Index",
          "description": "Index into the collection of modes returned by mode solver.  Specifies which mode to inject using this source. If larger than ``mode_spec.num_modes``, ``num_modes`` in the solver will be set to ``mode_index + 1``.",
          "default": 0,
          "minimum": 0,
          "type": "integer"
        }
      },
      "required": [
        "size",
        "source_time",
        "direction"
      ],
      "additionalProperties": false
    },
    "PlaneWave": {
      "title": "PlaneWave",
      "description": "Uniform current distribution on an infinite extent plane. One element of size must be zero.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional name for the source.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave, CustomSourceTime]\n    Specification of the source time-dependence.\ndirection : Literal['+', '-']\n    Specifies propagation in the positive or negative direction of the injection axis.\nangle_theta : float = 0.0\n    [units = rad].  Polar angle of the propagation axis from the injection axis.\nangle_phi : float = 0.0\n    [units = rad].  Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.\npol_angle : float = 0\n    [units = rad].  Specifies the angle between the electric field polarization of the source and the plane defined by the injection axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> pw_source = PlaneWave(size=(inf,0,inf), source_time=pulse, pol_angle=0.1, direction='+')",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "PlaneWave",
          "enum": [
            "PlaneWave"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "GaussianPulse": "#/definitions/GaussianPulse",
              "ContinuousWave": "#/definitions/ContinuousWave",
              "CustomSourceTime": "#/definitions/CustomSourceTime"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            },
            {
              "$ref": "#/definitions/CustomSourceTime"
            }
          ]
        },
        "direction": {
          "title": "Direction",
          "description": "Specifies propagation in the positive or negative direction of the injection axis.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "angle_theta": {
          "title": "Polar Angle",
          "description": "Polar angle of the propagation axis from the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "angle_phi": {
          "title": "Azimuth Angle",
          "description": "Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "pol_angle": {
          "title": "Polarization Angle",
          "description": "Specifies the angle between the electric field polarization of the source and the plane defined by the injection axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.",
          "default": 0,
          "units": "rad",
          "type": "number"
        }
      },
      "required": [
        "size",
        "source_time",
        "direction"
      ],
      "additionalProperties": false
    },
    "FieldDataset": {
      "title": "FieldDataset",
      "description": "Dataset storing a collection of the scalar components of E and H fields in the freq. domain\n\nParameters\n----------\nEx : Optional[ScalarFieldDataArray] = None\n    Spatial distribution of the x-component of the electric field.\nEy : Optional[ScalarFieldDataArray] = None\n    Spatial distribution of the y-component of the electric field.\nEz : Optional[ScalarFieldDataArray] = None\n    Spatial distribution of the z-component of the electric field.\nHx : Optional[ScalarFieldDataArray] = None\n    Spatial distribution of the x-component of the magnetic field.\nHy : Optional[ScalarFieldDataArray] = None\n    Spatial distribution of the y-component of the magnetic field.\nHz : Optional[ScalarFieldDataArray] = None\n    Spatial distribution of the z-component of the magnetic field.\n\nExample\n-------\n>>> x = [-1,1]\n>>> y = [-2,0,2]\n>>> z = [-3,-1,1,3]\n>>> f = [2e14, 3e14]\n>>> coords = dict(x=x, y=y, z=z, f=f)\n>>> scalar_field = ScalarFieldDataArray((1+1j) * np.random.random((2,3,4,2)), coords=coords)\n>>> data = FieldDataset(Ex=scalar_field, Hz=scalar_field)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "FieldDataset",
          "enum": [
            "FieldDataset"
          ],
          "type": "string"
        },
        "Ex": {
          "title": "DataArray",
          "description": "Spatial distribution of the x-component of the electric field.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "Ey": {
          "title": "DataArray",
          "description": "Spatial distribution of the y-component of the electric field.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "Ez": {
          "title": "DataArray",
          "description": "Spatial distribution of the z-component of the electric field.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "Hx": {
          "title": "DataArray",
          "description": "Spatial distribution of the x-component of the magnetic field.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "Hy": {
          "title": "DataArray",
          "description": "Spatial distribution of the y-component of the magnetic field.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "Hz": {
          "title": "DataArray",
          "description": "Spatial distribution of the z-component of the magnetic field.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        }
      },
      "additionalProperties": false
    },
    "CustomFieldSource": {
      "title": "CustomFieldSource",
      "description": "Implements a source corresponding to an input dataset containing ``E`` and ``H`` fields,\nusing the equivalence principle to define the actual injected currents. For the injection to\nwork as expected (i.e. to reproduce the required ``E`` and ``H`` fields), the field data must\ndecay by the edges of the source plane, or the source plane must span the entire simulation\ndomain and the fields must match the simulation boundary conditions.\nThe equivalent source currents are fully defined by the field components tangential to the\nsource plane. For e.g. source normal along ``z``, the normal components (``Ez`` and ``Hz``)\ncan be provided but will have no effect on the results, and at least one of the tangential\ncomponents has to be in the dataset, i.e. at least one of ``Ex``, ``Ey``, ``Hx``, and ``Hy``.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional name for the source.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave, CustomSourceTime]\n    Specification of the source time-dependence.\nfield_dataset : Optional[FieldDataset]\n    :class:`.FieldDataset` containing the desired frequency-domain fields patterns to inject. At least one tangetial field component must be specified.\n\nNote\n----\n    The coordinates of all provided fields are assumed to be relative to the source center.\n\nNote\n----\n    If only the ``E`` or only the ``H`` fields are provided, the source will not be directional,\n    but will inject equal power in both directions instead.\n\nExample\n-------\n>>> from tidy3d import ScalarFieldDataArray\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> x = np.linspace(-1, 1, 101)\n>>> y = np.linspace(-1, 1, 101)\n>>> z = np.array([0])\n>>> f = [2e14]\n>>> coords = dict(x=x, y=y, z=z, f=f)\n>>> scalar_field = ScalarFieldDataArray(np.ones((101, 101, 1, 1)), coords=coords)\n>>> dataset = FieldDataset(Ex=scalar_field)\n>>> custom_source = CustomFieldSource(\n...     center=(1, 1, 1),\n...     size=(2, 2, 0),\n...     source_time=pulse,\n...     field_dataset=dataset)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "CustomFieldSource",
          "enum": [
            "CustomFieldSource"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "GaussianPulse": "#/definitions/GaussianPulse",
              "ContinuousWave": "#/definitions/ContinuousWave",
              "CustomSourceTime": "#/definitions/CustomSourceTime"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            },
            {
              "$ref": "#/definitions/CustomSourceTime"
            }
          ]
        },
        "field_dataset": {
          "title": "Field Dataset",
          "description": ":class:`.FieldDataset` containing the desired frequency-domain fields patterns to inject. At least one tangetial field component must be specified.",
          "allOf": [
            {
              "$ref": "#/definitions/FieldDataset"
            }
          ]
        }
      },
      "required": [
        "size",
        "source_time",
        "field_dataset"
      ],
      "additionalProperties": false
    },
    "CustomCurrentSource": {
      "title": "CustomCurrentSource",
      "description": "Implements a source corresponding to an input dataset containing ``E`` and ``H`` fields.\nInjects the specified components of the ``E`` and ``H`` dataset directly as ``J`` and ``M``\ncurrent distributions in the FDTD solver.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional name for the source.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave, CustomSourceTime]\n    Specification of the source time-dependence.\ninterpolate : bool = True\n    Handles reverse-interpolation of zero-size dimensions of the source. If ``False``, the source data is snapped to the nearest Yee grid point. If ``True``, equivalent source data is applied on the surrounding Yee grid points to emulate placement at the specified location using linear interpolation.\ncurrent_dataset : Optional[FieldDataset]\n    :class:`.FieldDataset` containing the desired frequency-domain electric and magnetic current patterns to inject.\n\nNote\n----\n    The coordinates of all provided fields are assumed to be relative to the source center.\n\nExample\n-------\n>>> from tidy3d import ScalarFieldDataArray\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> x = np.linspace(-1, 1, 101)\n>>> y = np.linspace(-1, 1, 101)\n>>> z = np.array([0])\n>>> f = [2e14]\n>>> coords = dict(x=x, y=y, z=z, f=f)\n>>> scalar_field = ScalarFieldDataArray(np.ones((101, 101, 1, 1)), coords=coords)\n>>> dataset = FieldDataset(Ex=scalar_field)\n>>> custom_source = CustomCurrentSource(\n...     center=(1, 1, 1),\n...     size=(2, 2, 0),\n...     source_time=pulse,\n...     current_dataset=dataset)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "CustomCurrentSource",
          "enum": [
            "CustomCurrentSource"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "GaussianPulse": "#/definitions/GaussianPulse",
              "ContinuousWave": "#/definitions/ContinuousWave",
              "CustomSourceTime": "#/definitions/CustomSourceTime"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            },
            {
              "$ref": "#/definitions/CustomSourceTime"
            }
          ]
        },
        "interpolate": {
          "title": "Enable Interpolation",
          "description": "Handles reverse-interpolation of zero-size dimensions of the source. If ``False``, the source data is snapped to the nearest Yee grid point. If ``True``, equivalent source data is applied on the surrounding Yee grid points to emulate placement at the specified location using linear interpolation.",
          "default": true,
          "type": "boolean"
        },
        "current_dataset": {
          "title": "Current Dataset",
          "description": ":class:`.FieldDataset` containing the desired frequency-domain electric and magnetic current patterns to inject.",
          "allOf": [
            {
              "$ref": "#/definitions/FieldDataset"
            }
          ]
        }
      },
      "required": [
        "size",
        "source_time",
        "current_dataset"
      ],
      "additionalProperties": false
    },
    "TFSF": {
      "title": "TFSF",
      "description": "Total-field scattered-field (TFSF) source that can inject a plane wave in a finite region.\nThe TFSF source injects 1 W / um^2 of power along the ``injection_axis``. Note that in the\ncase of angled incidence, 1 W / um^2 is still injected along the source's ``injection_axis``,\nand not the propagation direction, unlike a ``PlaneWave`` source. This allows computing\nscattering and absorption cross sections without the need for additional normalization.\n\n\nParameters\n----------\nname : Optional[str] = None\n    Optional name for the source.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave, CustomSourceTime]\n    Specification of the source time-dependence.\ndirection : Literal['+', '-']\n    Specifies propagation in the positive or negative direction of the injection axis.\nangle_theta : float = 0.0\n    [units = rad].  Polar angle of the propagation axis from the injection axis.\nangle_phi : float = 0.0\n    [units = rad].  Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.\npol_angle : float = 0\n    [units = rad].  Specifies the angle between the electric field polarization of the source and the plane defined by the injection axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.\ninjection_axis : Literal[0, 1, 2]\n    Specifies the injection axis. The plane of incidence is defined via this ``injection_axis`` and the ``direction``. The popagation axis is defined with respect to the ``injection_axis`` by ``angle_theta`` and ``angle_phi``.",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "TFSF",
          "enum": [
            "TFSF"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "GaussianPulse": "#/definitions/GaussianPulse",
              "ContinuousWave": "#/definitions/ContinuousWave",
              "CustomSourceTime": "#/definitions/CustomSourceTime"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            },
            {
              "$ref": "#/definitions/CustomSourceTime"
            }
          ]
        },
        "direction": {
          "title": "Direction",
          "description": "Specifies propagation in the positive or negative direction of the injection axis.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "angle_theta": {
          "title": "Polar Angle",
          "description": "Polar angle of the propagation axis from the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "angle_phi": {
          "title": "Azimuth Angle",
          "description": "Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "pol_angle": {
          "title": "Polarization Angle",
          "description": "Specifies the angle between the electric field polarization of the source and the plane defined by the injection axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.",
          "default": 0,
          "units": "rad",
          "type": "number"
        },
        "injection_axis": {
          "title": "Injection Axis",
          "description": "Specifies the injection axis. The plane of incidence is defined via this ``injection_axis`` and the ``direction``. The popagation axis is defined with respect to the ``injection_axis`` by ``angle_theta`` and ``angle_phi``.",
          "enum": [
            0,
            1,
            2
          ],
          "type": "integer"
        }
      },
      "required": [
        "size",
        "source_time",
        "direction",
        "injection_axis"
      ],
      "additionalProperties": false
    },
    "Periodic": {
      "title": "Periodic",
      "description": "Periodic boundary condition class.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for boundary.",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for boundary.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "Periodic",
          "enum": [
            "Periodic"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PECBoundary": {
      "title": "PECBoundary",
      "description": "Perfect electric conductor boundary condition class.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for boundary.",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for boundary.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "PECBoundary",
          "enum": [
            "PECBoundary"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PMCBoundary": {
      "title": "PMCBoundary",
      "description": "Perfect magnetic conductor boundary condition class.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for boundary.",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for boundary.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "PMCBoundary",
          "enum": [
            "PMCBoundary"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PMLParams": {
      "title": "PMLParams",
      "description": "Specifies full set of parameters needed for complex, frequency-shifted PML.\n\nParameters\n----------\nsigma_order : NonNegativeInt = 3\n    Order of the polynomial describing the absorber profile (~dist^sigma_order).\nsigma_min : NonNegativeFloat = 0.0\n    [units = 2*EPSILON_0/dt].  Minimum value of the absorber conductivity.\nsigma_max : NonNegativeFloat = 1.5\n    [units = 2*EPSILON_0/dt].  Maximum value of the absorber conductivity.\nkappa_order : NonNegativeInt = 3\n    Order of the polynomial describing the PML kappa profile (kappa~dist^kappa_order).\nkappa_min : NonNegativeFloat = 0.0\n    \nkappa_max : NonNegativeFloat = 1.5\n    \nalpha_order : NonNegativeInt = 3\n    Order of the polynomial describing the PML alpha profile (alpha~dist^alpha_order).\nalpha_min : NonNegativeFloat = 0.0\n    [units = 2*EPSILON_0/dt].  Minimum value of the PML alpha.\nalpha_max : NonNegativeFloat = 1.5\n    [units = 2*EPSILON_0/dt].  Maximum value of the PML alpha.\n\nExample\n-------\n>>> params = PMLParams(sigma_order=3, sigma_min=0.0, sigma_max=1.5, kappa_min=0.0)",
      "type": "object",
      "properties": {
        "sigma_order": {
          "title": "Sigma Order",
          "description": "Order of the polynomial describing the absorber profile (~dist^sigma_order).",
          "default": 3,
          "minimum": 0,
          "type": "integer"
        },
        "sigma_min": {
          "title": "Sigma Minimum",
          "description": "Minimum value of the absorber conductivity.",
          "default": 0.0,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        },
        "sigma_max": {
          "title": "Sigma Maximum",
          "description": "Maximum value of the absorber conductivity.",
          "default": 1.5,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        },
        "type": {
          "title": "Type",
          "default": "PMLParams",
          "enum": [
            "PMLParams"
          ],
          "type": "string"
        },
        "kappa_order": {
          "title": "Kappa Order",
          "description": "Order of the polynomial describing the PML kappa profile (kappa~dist^kappa_order).",
          "default": 3,
          "minimum": 0,
          "type": "integer"
        },
        "kappa_min": {
          "title": "Kappa Minimum",
          "default": 0.0,
          "minimum": 0,
          "type": "number"
        },
        "kappa_max": {
          "title": "Kappa Maximum",
          "default": 1.5,
          "minimum": 0,
          "type": "number"
        },
        "alpha_order": {
          "title": "Alpha Order",
          "description": "Order of the polynomial describing the PML alpha profile (alpha~dist^alpha_order).",
          "default": 3,
          "minimum": 0,
          "type": "integer"
        },
        "alpha_min": {
          "title": "Alpha Minimum",
          "description": "Minimum value of the PML alpha.",
          "default": 0.0,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        },
        "alpha_max": {
          "title": "Alpha Maximum",
          "description": "Maximum value of the PML alpha.",
          "default": 1.5,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        }
      },
      "additionalProperties": false
    },
    "PML": {
      "title": "PML",
      "description": "Specifies a standard PML along a single dimension.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for boundary.\nnum_layers : NonNegativeInt = 12\n    Number of layers of standard PML.\nparameters : PMLParams = PMLParams(sigma_order=3, sigma_min=0.0, sigma_max=1.5, type='PMLParams', kappa_order=3, kappa_min=1.0, kappa_max=3.0, alpha_order=1, alpha_min=0.0, alpha_max=0.0)\n    Parameters of the complex frequency-shifted absorption poles.\n\nExample\n-------\n>>> pml = PML(num_layers=10)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for boundary.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "PML",
          "enum": [
            "PML"
          ],
          "type": "string"
        },
        "num_layers": {
          "title": "Number of Layers",
          "description": "Number of layers of standard PML.",
          "default": 12,
          "minimum": 0,
          "type": "integer"
        },
        "parameters": {
          "title": "PML Parameters",
          "description": "Parameters of the complex frequency-shifted absorption poles.",
          "default": {
            "sigma_order": 3,
            "sigma_min": 0.0,
            "sigma_max": 1.5,
            "type": "PMLParams",
            "kappa_order": 3,
            "kappa_min": 1.0,
            "kappa_max": 3.0,
            "alpha_order": 1,
            "alpha_min": 0.0,
            "alpha_max": 0.0
          },
          "allOf": [
            {
              "$ref": "#/definitions/PMLParams"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "StablePML": {
      "title": "StablePML",
      "description": "Specifies a 'stable' PML along a single dimension.\nThis PML deals handles possbly divergent simulations better, but at the expense of more layers.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for boundary.\nnum_layers : NonNegativeInt = 40\n    Number of layers of 'stable' PML.\nparameters : PMLParams = PMLParams(sigma_order=3, sigma_min=0.0, sigma_max=1.0, type='PMLParams', kappa_order=3, kappa_min=1.0, kappa_max=5.0, alpha_order=1, alpha_min=0.0, alpha_max=0.9)\n    'Stable' parameters of the complex frequency-shifted absorption poles.\n\nExample\n-------\n>>> pml = StablePML(num_layers=40)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for boundary.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "StablePML",
          "enum": [
            "StablePML"
          ],
          "type": "string"
        },
        "num_layers": {
          "title": "Number of Layers",
          "description": "Number of layers of 'stable' PML.",
          "default": 40,
          "minimum": 0,
          "type": "integer"
        },
        "parameters": {
          "title": "Stable PML Parameters",
          "description": "'Stable' parameters of the complex frequency-shifted absorption poles.",
          "default": {
            "sigma_order": 3,
            "sigma_min": 0.0,
            "sigma_max": 1.0,
            "type": "PMLParams",
            "kappa_order": 3,
            "kappa_min": 1.0,
            "kappa_max": 5.0,
            "alpha_order": 1,
            "alpha_min": 0.0,
            "alpha_max": 0.9
          },
          "allOf": [
            {
              "$ref": "#/definitions/PMLParams"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "AbsorberParams": {
      "title": "AbsorberParams",
      "description": "Specifies parameters common to Absorbers and PMLs.\n\nParameters\n----------\nsigma_order : NonNegativeInt = 3\n    Order of the polynomial describing the absorber profile (~dist^sigma_order).\nsigma_min : NonNegativeFloat = 0.0\n    [units = 2*EPSILON_0/dt].  Minimum value of the absorber conductivity.\nsigma_max : NonNegativeFloat = 1.5\n    [units = 2*EPSILON_0/dt].  Maximum value of the absorber conductivity.\n\nExample\n-------\n>>> params = AbsorberParams(sigma_order=3, sigma_min=0.0, sigma_max=1.5)",
      "type": "object",
      "properties": {
        "sigma_order": {
          "title": "Sigma Order",
          "description": "Order of the polynomial describing the absorber profile (~dist^sigma_order).",
          "default": 3,
          "minimum": 0,
          "type": "integer"
        },
        "sigma_min": {
          "title": "Sigma Minimum",
          "description": "Minimum value of the absorber conductivity.",
          "default": 0.0,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        },
        "sigma_max": {
          "title": "Sigma Maximum",
          "description": "Maximum value of the absorber conductivity.",
          "default": 1.5,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        },
        "type": {
          "title": "Type",
          "default": "AbsorberParams",
          "enum": [
            "AbsorberParams"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "Absorber": {
      "title": "Absorber",
      "description": "Specifies an adiabatic absorber along a single dimension.\nThis absorber is well-suited for dispersive materials\nintersecting with absorbing edges of the simulation at the expense of more layers.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for boundary.\nnum_layers : NonNegativeInt = 40\n    Number of layers of absorber to add to + and - boundaries.\nparameters : AbsorberParams = AbsorberParams(sigma_order=3, sigma_min=0.0, sigma_max=6.4, type='AbsorberParams')\n    Adiabatic absorber parameters.\n\nExample\n-------\n>>> pml = Absorber(num_layers=40)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for boundary.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "Absorber",
          "enum": [
            "Absorber"
          ],
          "type": "string"
        },
        "num_layers": {
          "title": "Number of Layers",
          "description": "Number of layers of absorber to add to + and - boundaries.",
          "default": 40,
          "minimum": 0,
          "type": "integer"
        },
        "parameters": {
          "title": "Absorber Parameters",
          "description": "Adiabatic absorber parameters.",
          "default": {
            "sigma_order": 3,
            "sigma_min": 0.0,
            "sigma_max": 6.4,
            "type": "AbsorberParams"
          },
          "allOf": [
            {
              "$ref": "#/definitions/AbsorberParams"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "BlochBoundary": {
      "title": "BlochBoundary",
      "description": "Specifies a Bloch boundary condition along a single dimension.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for boundary.\nbloch_vec : float\n    Normalized component of the Bloch vector in units of 2 * pi / (size along dimension) in the background medium, along the dimension in which the boundary is specified.\n\nExample\n-------\n>>> bloch = BlochBoundary(bloch_vec=1)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for boundary.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "BlochBoundary",
          "enum": [
            "BlochBoundary"
          ],
          "type": "string"
        },
        "bloch_vec": {
          "title": "Normalized Bloch vector component",
          "description": "Normalized component of the Bloch vector in units of 2 * pi / (size along dimension) in the background medium, along the dimension in which the boundary is specified.",
          "type": "number"
        }
      },
      "required": [
        "bloch_vec"
      ],
      "additionalProperties": false
    },
    "Boundary": {
      "title": "Boundary",
      "description": "Boundary conditions at the minus and plus extents along a dimension\n\nParameters\n----------\nplus : Union[Periodic, PECBoundary, PMCBoundary, PML, StablePML, Absorber, BlochBoundary] = PML(name=None, type='PML', num_layers=12, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0))\n    Boundary condition on the plus side along a dimension.\nminus : Union[Periodic, PECBoundary, PMCBoundary, PML, StablePML, Absorber, BlochBoundary] = PML(name=None, type='PML', num_layers=12, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0))\n    Boundary condition on the minus side along a dimension.\n\nExample\n-------\n>>> boundary = Boundary(plus = PML(), minus = PECBoundary())",
      "type": "object",
      "properties": {
        "plus": {
          "title": "Plus BC",
          "description": "Boundary condition on the plus side along a dimension.",
          "default": {
            "name": null,
            "type": "PML",
            "num_layers": 12,
            "parameters": {
              "sigma_order": 3,
              "sigma_min": 0.0,
              "sigma_max": 1.5,
              "type": "PMLParams",
              "kappa_order": 3,
              "kappa_min": 1.0,
              "kappa_max": 3.0,
              "alpha_order": 1,
              "alpha_min": 0.0,
              "alpha_max": 0.0
            }
          },
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "Periodic": "#/definitions/Periodic",
              "PECBoundary": "#/definitions/PECBoundary",
              "PMCBoundary": "#/definitions/PMCBoundary",
              "PML": "#/definitions/PML",
              "StablePML": "#/definitions/StablePML",
              "Absorber": "#/definitions/Absorber",
              "BlochBoundary": "#/definitions/BlochBoundary"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/Periodic"
            },
            {
              "$ref": "#/definitions/PECBoundary"
            },
            {
              "$ref": "#/definitions/PMCBoundary"
            },
            {
              "$ref": "#/definitions/PML"
            },
            {
              "$ref": "#/definitions/StablePML"
            },
            {
              "$ref": "#/definitions/Absorber"
            },
            {
              "$ref": "#/definitions/BlochBoundary"
            }
          ]
        },
        "minus": {
          "title": "Minus BC",
          "description": "Boundary condition on the minus side along a dimension.",
          "default": {
            "name": null,
            "type": "PML",
            "num_layers": 12,
            "parameters": {
              "sigma_order": 3,
              "sigma_min": 0.0,
              "sigma_max": 1.5,
              "type": "PMLParams",
              "kappa_order": 3,
              "kappa_min": 1.0,
              "kappa_max": 3.0,
              "alpha_order": 1,
              "alpha_min": 0.0,
              "alpha_max": 0.0
            }
          },
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "Periodic": "#/definitions/Periodic",
              "PECBoundary": "#/definitions/PECBoundary",
              "PMCBoundary": "#/definitions/PMCBoundary",
              "PML": "#/definitions/PML",
              "StablePML": "#/definitions/StablePML",
              "Absorber": "#/definitions/Absorber",
              "BlochBoundary": "#/definitions/BlochBoundary"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/Periodic"
            },
            {
              "$ref": "#/definitions/PECBoundary"
            },
            {
              "$ref": "#/definitions/PMCBoundary"
            },
            {
              "$ref": "#/definitions/PML"
            },
            {
              "$ref": "#/definitions/StablePML"
            },
            {
              "$ref": "#/definitions/Absorber"
            },
            {
              "$ref": "#/definitions/BlochBoundary"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Boundary",
          "enum": [
            "Boundary"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "BoundarySpec": {
      "title": "BoundarySpec",
      "description": "Specifies boundary conditions on each side of the domain and along each dimension.\n\nParameters\n----------\nx : Boundary = Boundary(plus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)), minus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)), type='Boundary')\n    Boundary condition on the plus and minus sides along the x axis. If `None`, periodic boundaries are applied. Default will change to PML in 2.0 so explicitly setting the boundaries is recommended.\ny : Boundary = Boundary(plus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)), minus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)), type='Boundary')\n    Boundary condition on the plus and minus sides along the y axis. If `None`, periodic boundaries are applied. Default will change to PML in 2.0 so explicitly setting the boundaries is recommended.\nz : Boundary = Boundary(plus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)), minus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)), type='Boundary')\n    Boundary condition on the plus and minus sides along the z axis. If `None`, periodic boundaries are applied. Default will change to PML in 2.0 so explicitly setting the boundaries is recommended.",
      "type": "object",
      "properties": {
        "x": {
          "title": "Boundary condition along x.",
          "description": "Boundary condition on the plus and minus sides along the x axis. If `None`, periodic boundaries are applied. Default will change to PML in 2.0 so explicitly setting the boundaries is recommended.",
          "default": {
            "plus": {
              "name": null,
              "type": "PML",
              "num_layers": 12,
              "parameters": {
                "sigma_order": 3,
                "sigma_min": 0.0,
                "sigma_max": 1.5,
                "type": "PMLParams",
                "kappa_order": 3,
                "kappa_min": 1.0,
                "kappa_max": 3.0,
                "alpha_order": 1,
                "alpha_min": 0.0,
                "alpha_max": 0.0
              }
            },
            "minus": {
              "name": null,
              "type": "PML",
              "num_layers": 12,
              "parameters": {
                "sigma_order": 3,
                "sigma_min": 0.0,
                "sigma_max": 1.5,
                "type": "PMLParams",
                "kappa_order": 3,
                "kappa_min": 1.0,
                "kappa_max": 3.0,
                "alpha_order": 1,
                "alpha_min": 0.0,
                "alpha_max": 0.0
              }
            },
            "type": "Boundary"
          },
          "allOf": [
            {
              "$ref": "#/definitions/Boundary"
            }
          ]
        },
        "y": {
          "title": "Boundary condition along y.",
          "description": "Boundary condition on the plus and minus sides along the y axis. If `None`, periodic boundaries are applied. Default will change to PML in 2.0 so explicitly setting the boundaries is recommended.",
          "default": {
            "plus": {
              "name": null,
              "type": "PML",
              "num_layers": 12,
              "parameters": {
                "sigma_order": 3,
                "sigma_min": 0.0,
                "sigma_max": 1.5,
                "type": "PMLParams",
                "kappa_order": 3,
                "kappa_min": 1.0,
                "kappa_max": 3.0,
                "alpha_order": 1,
                "alpha_min": 0.0,
                "alpha_max": 0.0
              }
            },
            "minus": {
              "name": null,
              "type": "PML",
              "num_layers": 12,
              "parameters": {
                "sigma_order": 3,
                "sigma_min": 0.0,
                "sigma_max": 1.5,
                "type": "PMLParams",
                "kappa_order": 3,
                "kappa_min": 1.0,
                "kappa_max": 3.0,
                "alpha_order": 1,
                "alpha_min": 0.0,
                "alpha_max": 0.0
              }
            },
            "type": "Boundary"
          },
          "allOf": [
            {
              "$ref": "#/definitions/Boundary"
            }
          ]
        },
        "z": {
          "title": "Boundary condition along z.",
          "description": "Boundary condition on the plus and minus sides along the z axis. If `None`, periodic boundaries are applied. Default will change to PML in 2.0 so explicitly setting the boundaries is recommended.",
          "default": {
            "plus": {
              "name": null,
              "type": "PML",
              "num_layers": 12,
              "parameters": {
                "sigma_order": 3,
                "sigma_min": 0.0,
                "sigma_max": 1.5,
                "type": "PMLParams",
                "kappa_order": 3,
                "kappa_min": 1.0,
                "kappa_max": 3.0,
                "alpha_order": 1,
                "alpha_min": 0.0,
                "alpha_max": 0.0
              }
            },
            "minus": {
              "name": null,
              "type": "PML",
              "num_layers": 12,
              "parameters": {
                "sigma_order": 3,
                "sigma_min": 0.0,
                "sigma_max": 1.5,
                "type": "PMLParams",
                "kappa_order": 3,
                "kappa_min": 1.0,
                "kappa_max": 3.0,
                "alpha_order": 1,
                "alpha_min": 0.0,
                "alpha_max": 0.0
              }
            },
            "type": "Boundary"
          },
          "allOf": [
            {
              "$ref": "#/definitions/Boundary"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "BoundarySpec",
          "enum": [
            "BoundarySpec"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "ApodizationSpec": {
      "title": "ApodizationSpec",
      "description": "Stores specifications for the apodizaton of frequency-domain monitors.\n\nParameters\n----------\nstart : Optional[NonNegativeFloat] = None\n    [units = sec].  Defines the time at which the start apodization ends.\nend : Optional[NonNegativeFloat] = None\n    [units = sec].  Defines the time at which the end apodization begins.\nwidth : Optional[PositiveFloat] = None\n    [units = sec].  Characteristic decay length of the apodization function.\n\nExample\n-------\n>>> apod_spec = ApodizationSpec(start=1, end=2, width=0.5)",
      "type": "object",
      "properties": {
        "start": {
          "title": "Start Interval",
          "description": "Defines the time at which the start apodization ends.",
          "units": "sec",
          "minimum": 0,
          "type": "number"
        },
        "end": {
          "title": "End Interval",
          "description": "Defines the time at which the end apodization begins.",
          "units": "sec",
          "minimum": 0,
          "type": "number"
        },
        "width": {
          "title": "Apodization Width",
          "description": "Characteristic decay length of the apodization function.",
          "units": "sec",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "type": {
          "title": "Type",
          "default": "ApodizationSpec",
          "enum": [
            "ApodizationSpec"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "FieldMonitor": {
      "title": "FieldMonitor",
      "description": ":class:`Monitor` that records electromagnetic fields in the frequency domain.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\ninterval_space : Tuple[PositiveInt, PositiveInt, PositiveInt] = (1, 1, 1)\n    Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included.\ncolocate : bool = True\n    Toggle whether fields should be colocated to grid cell boundaries (i.e. primal grid nodes).\nfreqs : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\napodization : ApodizationSpec = ApodizationSpec(start=None, end=None, width=None, type='ApodizationSpec')\n    Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.\nfields : Tuple[Literal['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz'], ...] = ['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']\n    Collection of field components to store in the monitor.\n\nExample\n-------\n>>> monitor = FieldMonitor(\n...     center=(1,2,3),\n...     size=(2,2,2),\n...     fields=['Hx'],\n...     freqs=[250e12, 300e12],\n...     name='steady_state_monitor',\n...     colocate=True)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "FieldMonitor",
          "enum": [
            "FieldMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "interval_space": {
          "title": "Spatial Interval",
          "description": "Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included.",
          "default": [
            1,
            1,
            1
          ],
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "integer",
              "exclusiveMinimum": 0
            },
            {
              "type": "integer",
              "exclusiveMinimum": 0
            },
            {
              "type": "integer",
              "exclusiveMinimum": 0
            }
          ]
        },
        "colocate": {
          "title": "Colocate Fields",
          "description": "Toggle whether fields should be colocated to grid cell boundaries (i.e. primal grid nodes).",
          "default": true,
          "type": "boolean"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        },
        "apodization": {
          "title": "Apodization Specification",
          "description": "Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.",
          "default": {
            "start": null,
            "end": null,
            "width": null,
            "type": "ApodizationSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ApodizationSpec"
            }
          ]
        },
        "fields": {
          "title": "Field Components",
          "description": "Collection of field components to store in the monitor.",
          "default": [
            "Ex",
            "Ey",
            "Ez",
            "Hx",
            "Hy",
            "Hz"
          ],
          "type": "array",
          "items": {
            "enum": [
              "Ex",
              "Ey",
              "Ez",
              "Hx",
              "Hy",
              "Hz"
            ],
            "type": "string"
          }
        }
      },
      "required": [
        "size",
        "name",
        "freqs"
      ],
      "additionalProperties": false
    },
    "FieldTimeMonitor": {
      "title": "FieldTimeMonitor",
      "description": ":class:`Monitor` that records electromagnetic fields in the time domain.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\ninterval_space : Tuple[PositiveInt, PositiveInt, PositiveInt] = (1, 1, 1)\n    Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included.\ncolocate : bool = True\n    Toggle whether fields should be colocated to grid cell boundaries (i.e. primal grid nodes).\nstart : NonNegativeFloat = 0.0\n    [units = sec].  Time at which to start monitor recording.\nstop : Optional[NonNegativeFloat] = None\n    [units = sec].  Time at which to stop monitor recording.  If not specified, record until end of simulation.\ninterval : Optional[PositiveInt] = None\n    Sampling rate of the monitor: number of time steps between each measurement. Set ``inverval`` to 1 for the highest possible resolution in time. Higher integer values downsample the data by measuring every ``interval`` time steps. This can be useful for reducing data storage as needed by the application.\nfields : Tuple[Literal['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz'], ...] = ['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']\n    Collection of field components to store in the monitor.\n\nExample\n-------\n>>> monitor = FieldTimeMonitor(\n...     center=(1,2,3),\n...     size=(2,2,2),\n...     fields=['Hx'],\n...     start=1e-13,\n...     stop=5e-13,\n...     interval=2,\n...     colocate=True,\n...     name='movie_monitor')",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "FieldTimeMonitor",
          "enum": [
            "FieldTimeMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "interval_space": {
          "title": "Spatial Interval",
          "description": "Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included.",
          "default": [
            1,
            1,
            1
          ],
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "integer",
              "exclusiveMinimum": 0
            },
            {
              "type": "integer",
              "exclusiveMinimum": 0
            },
            {
              "type": "integer",
              "exclusiveMinimum": 0
            }
          ]
        },
        "colocate": {
          "title": "Colocate Fields",
          "description": "Toggle whether fields should be colocated to grid cell boundaries (i.e. primal grid nodes).",
          "default": true,
          "type": "boolean"
        },
        "start": {
          "title": "Start Time",
          "description": "Time at which to start monitor recording.",
          "default": 0.0,
          "units": "sec",
          "minimum": 0,
          "type": "number"
        },
        "stop": {
          "title": "Stop Time",
          "description": "Time at which to stop monitor recording.  If not specified, record until end of simulation.",
          "units": "sec",
          "minimum": 0,
          "type": "number"
        },
        "interval": {
          "title": "Time Interval",
          "description": "Sampling rate of the monitor: number of time steps between each measurement. Set ``inverval`` to 1 for the highest possible resolution in time. Higher integer values downsample the data by measuring every ``interval`` time steps. This can be useful for reducing data storage as needed by the application.",
          "exclusiveMinimum": 0,
          "type": "integer"
        },
        "fields": {
          "title": "Field Components",
          "description": "Collection of field components to store in the monitor.",
          "default": [
            "Ex",
            "Ey",
            "Ez",
            "Hx",
            "Hy",
            "Hz"
          ],
          "type": "array",
          "items": {
            "enum": [
              "Ex",
              "Ey",
              "Ez",
              "Hx",
              "Hy",
              "Hz"
            ],
            "type": "string"
          }
        }
      },
      "required": [
        "size",
        "name"
      ],
      "additionalProperties": false
    },
    "PermittivityMonitor": {
      "title": "PermittivityMonitor",
      "description": ":class:`Monitor` that records the diagonal components of the complex-valued relative\npermittivity tensor in the frequency domain. The recorded data has the same shape as a\n:class:`.FieldMonitor` of the same geometry: the permittivity values are saved at the\nYee grid locations, and can be interpolated to any point inside the monitor.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\ninterval_space : Tuple[PositiveInt, PositiveInt, PositiveInt] = (1, 1, 1)\n    Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included.\ncolocate : Literal[False] = False\n    Colocation turned off, since colocated permittivity values do not have a physical meaning - they do not correspond to the subpixel-averaged ones.\nfreqs : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\napodization : ApodizationSpec = ApodizationSpec(start=None, end=None, width=None, type='ApodizationSpec')\n    This field is ignored in this monitor.\n\nNote\n----\nIf 2D materials are present, then the permittivity values correspond to the\nvolumetric equivalent of the 2D materials.\n\nExample\n-------\n>>> monitor = PermittivityMonitor(\n...     center=(1,2,3),\n...     size=(2,2,2),\n...     freqs=[250e12, 300e12],\n...     name='eps_monitor')",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "PermittivityMonitor",
          "enum": [
            "PermittivityMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "interval_space": {
          "title": "Spatial Interval",
          "description": "Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included.",
          "default": [
            1,
            1,
            1
          ],
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "integer",
              "exclusiveMinimum": 0
            },
            {
              "type": "integer",
              "exclusiveMinimum": 0
            },
            {
              "type": "integer",
              "exclusiveMinimum": 0
            }
          ]
        },
        "colocate": {
          "title": "Colocate Fields",
          "description": "Colocation turned off, since colocated permittivity values do not have a physical meaning - they do not correspond to the subpixel-averaged ones.",
          "default": false,
          "enum": [
            false
          ],
          "type": "boolean"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        },
        "apodization": {
          "title": "Apodization Specification",
          "description": "This field is ignored in this monitor.",
          "default": {
            "start": null,
            "end": null,
            "width": null,
            "type": "ApodizationSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ApodizationSpec"
            }
          ]
        }
      },
      "required": [
        "size",
        "name",
        "freqs"
      ],
      "additionalProperties": false
    },
    "FluxMonitor": {
      "title": "FluxMonitor",
      "description": ":class:`Monitor` that records power flux in the frequency domain.\nIf the monitor geometry is a 2D box, the total flux through this plane is returned, with a\npositive sign corresponding to power flow in the positive direction along the axis normal to\nthe plane. If the geometry is a 3D box, the total power coming out of the box is returned by\nintegrating the flux over all box surfaces (excpet the ones defined in ``exclude_surfaces``).\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\ninterval_space : Tuple[Literal[1], Literal[1], Literal[1]] = (1, 1, 1)\n    Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Not all monitors support values different from 1.\ncolocate : Literal[True] = True\n    Defines whether fields are colocated to grid cell boundaries (i.e. to the primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors and is hard-coded for other monitors depending on their specific function.\nfreqs : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\napodization : ApodizationSpec = ApodizationSpec(start=None, end=None, width=None, type='ApodizationSpec')\n    Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.\nnormal_dir : Optional[Literal['+', '-']] = None\n    Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.\nexclude_surfaces : Optional[Tuple[Literal['x-', 'x+', 'y-', 'y+', 'z-', 'z+'], ...]] = None\n    Surfaces to exclude in the integration, if a volume monitor.\n\nExample\n-------\n>>> monitor = FluxMonitor(\n...     center=(1,2,3),\n...     size=(2,2,0),\n...     freqs=[200e12, 210e12],\n...     name='flux_monitor')",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "FluxMonitor",
          "enum": [
            "FluxMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "interval_space": {
          "title": "Spatial Interval",
          "description": "Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Not all monitors support values different from 1.",
          "default": [
            1,
            1,
            1
          ],
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "enum": [
                1
              ],
              "type": "integer"
            },
            {
              "enum": [
                1
              ],
              "type": "integer"
            },
            {
              "enum": [
                1
              ],
              "type": "integer"
            }
          ]
        },
        "colocate": {
          "title": "Colocate Fields",
          "description": "Defines whether fields are colocated to grid cell boundaries (i.e. to the primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors and is hard-coded for other monitors depending on their specific function.",
          "default": true,
          "enum": [
            true
          ],
          "type": "boolean"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        },
        "apodization": {
          "title": "Apodization Specification",
          "description": "Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.",
          "default": {
            "start": null,
            "end": null,
            "width": null,
            "type": "ApodizationSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ApodizationSpec"
            }
          ]
        },
        "normal_dir": {
          "title": "Normal Vector Orientation",
          "description": "Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "exclude_surfaces": {
          "title": "Excluded Surfaces",
          "description": "Surfaces to exclude in the integration, if a volume monitor.",
          "type": "array",
          "items": {
            "enum": [
              "x-",
              "x+",
              "y-",
              "y+",
              "z-",
              "z+"
            ],
            "type": "string"
          }
        }
      },
      "required": [
        "size",
        "name",
        "freqs"
      ],
      "additionalProperties": false
    },
    "FluxTimeMonitor": {
      "title": "FluxTimeMonitor",
      "description": ":class:`Monitor` that records power flux in the time domain.\nIf the monitor geometry is a 2D box, the total flux through this plane is returned, with a\npositive sign corresponding to power flow in the positive direction along the axis normal to\nthe plane. If the geometry is a 3D box, the total power coming out of the box is returned by\nintegrating the flux over all box surfaces (excpet the ones defined in ``exclude_surfaces``).\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\ninterval_space : Tuple[Literal[1], Literal[1], Literal[1]] = (1, 1, 1)\n    Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Not all monitors support values different from 1.\ncolocate : Literal[True] = True\n    Defines whether fields are colocated to grid cell boundaries (i.e. to the primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors and is hard-coded for other monitors depending on their specific function.\nstart : NonNegativeFloat = 0.0\n    [units = sec].  Time at which to start monitor recording.\nstop : Optional[NonNegativeFloat] = None\n    [units = sec].  Time at which to stop monitor recording.  If not specified, record until end of simulation.\ninterval : Optional[PositiveInt] = None\n    Sampling rate of the monitor: number of time steps between each measurement. Set ``inverval`` to 1 for the highest possible resolution in time. Higher integer values downsample the data by measuring every ``interval`` time steps. This can be useful for reducing data storage as needed by the application.\nnormal_dir : Optional[Literal['+', '-']] = None\n    Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.\nexclude_surfaces : Optional[Tuple[Literal['x-', 'x+', 'y-', 'y+', 'z-', 'z+'], ...]] = None\n    Surfaces to exclude in the integration, if a volume monitor.\n\nExample\n-------\n>>> monitor = FluxTimeMonitor(\n...     center=(1,2,3),\n...     size=(2,2,0),\n...     start=1e-13,\n...     stop=5e-13,\n...     interval=2,\n...     name='flux_vs_time')",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "FluxTimeMonitor",
          "enum": [
            "FluxTimeMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "interval_space": {
          "title": "Spatial Interval",
          "description": "Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Not all monitors support values different from 1.",
          "default": [
            1,
            1,
            1
          ],
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "enum": [
                1
              ],
              "type": "integer"
            },
            {
              "enum": [
                1
              ],
              "type": "integer"
            },
            {
              "enum": [
                1
              ],
              "type": "integer"
            }
          ]
        },
        "colocate": {
          "title": "Colocate Fields",
          "description": "Defines whether fields are colocated to grid cell boundaries (i.e. to the primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors and is hard-coded for other monitors depending on their specific function.",
          "default": true,
          "enum": [
            true
          ],
          "type": "boolean"
        },
        "start": {
          "title": "Start Time",
          "description": "Time at which to start monitor recording.",
          "default": 0.0,
          "units": "sec",
          "minimum": 0,
          "type": "number"
        },
        "stop": {
          "title": "Stop Time",
          "description": "Time at which to stop monitor recording.  If not specified, record until end of simulation.",
          "units": "sec",
          "minimum": 0,
          "type": "number"
        },
        "interval": {
          "title": "Time Interval",
          "description": "Sampling rate of the monitor: number of time steps between each measurement. Set ``inverval`` to 1 for the highest possible resolution in time. Higher integer values downsample the data by measuring every ``interval`` time steps. This can be useful for reducing data storage as needed by the application.",
          "exclusiveMinimum": 0,
          "type": "integer"
        },
        "normal_dir": {
          "title": "Normal Vector Orientation",
          "description": "Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "exclude_surfaces": {
          "title": "Excluded Surfaces",
          "description": "Surfaces to exclude in the integration, if a volume monitor.",
          "type": "array",
          "items": {
            "enum": [
              "x-",
              "x+",
              "y-",
              "y+",
              "z-",
              "z+"
            ],
            "type": "string"
          }
        }
      },
      "required": [
        "size",
        "name"
      ],
      "additionalProperties": false
    },
    "ModeMonitor": {
      "title": "ModeMonitor",
      "description": ":class:`Monitor` that records amplitudes from modal decomposition of fields on plane.\nThe amplitudes are defined as\n``mode_solver_data.dot(recorded_field) / mode_solver_data.dot(mode_solver_data)``, where\n``recorded_field`` is the field data recorded in the FDTD simulation at the monitor frequencies,\nand ``mode_solver_data`` is the mode data from the mode solver at the monitor plane.\nThis gives the power amplitude of ``recorded_field`` carried by each mode.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\ninterval_space : Tuple[Literal[1], Literal[1], Literal[1]] = (1, 1, 1)\n    Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Not all monitors support values different from 1.\ncolocate : Literal[False] = False\n    Defines whether fields are colocated to grid cell boundaries (i.e. to the primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors and is hard-coded for other monitors depending on their specific function.\nfreqs : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\napodization : ApodizationSpec = ApodizationSpec(start=None, end=None, width=None, type='ApodizationSpec')\n    Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.\nmode_spec : ModeSpec\n    Parameters to feed to mode solver which determine modes measured by monitor.\n\nExample\n-------\n>>> mode_spec = ModeSpec(num_modes=3)\n>>> monitor = ModeMonitor(\n...     center=(1,2,3),\n...     size=(2,2,0),\n...     freqs=[200e12, 210e12],\n...     mode_spec=mode_spec,\n...     name='mode_monitor')",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "ModeMonitor",
          "enum": [
            "ModeMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "interval_space": {
          "title": "Spatial Interval",
          "description": "Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Not all monitors support values different from 1.",
          "default": [
            1,
            1,
            1
          ],
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "enum": [
                1
              ],
              "type": "integer"
            },
            {
              "enum": [
                1
              ],
              "type": "integer"
            },
            {
              "enum": [
                1
              ],
              "type": "integer"
            }
          ]
        },
        "colocate": {
          "title": "Colocate Fields",
          "description": "Defines whether fields are colocated to grid cell boundaries (i.e. to the primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors and is hard-coded for other monitors depending on their specific function.",
          "default": false,
          "enum": [
            false
          ],
          "type": "boolean"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        },
        "apodization": {
          "title": "Apodization Specification",
          "description": "Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.",
          "default": {
            "start": null,
            "end": null,
            "width": null,
            "type": "ApodizationSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ApodizationSpec"
            }
          ]
        },
        "mode_spec": {
          "title": "Mode Specification",
          "description": "Parameters to feed to mode solver which determine modes measured by monitor.",
          "allOf": [
            {
              "$ref": "#/definitions/ModeSpec"
            }
          ]
        }
      },
      "required": [
        "size",
        "name",
        "freqs",
        "mode_spec"
      ],
      "additionalProperties": false
    },
    "ModeSolverMonitor": {
      "title": "ModeSolverMonitor",
      "description": ":class:`Monitor` that stores the mode field profiles returned by the mode solver in the\nmonitor plane.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\ninterval_space : Tuple[Literal[1], Literal[1], Literal[1]] = (1, 1, 1)\n    Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Not all monitors support values different from 1.\ncolocate : bool = True\n    Toggle whether fields should be colocated to grid cell boundaries (i.e. primal grid nodes).\nfreqs : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\napodization : ApodizationSpec = ApodizationSpec(start=None, end=None, width=None, type='ApodizationSpec')\n    Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.\nmode_spec : ModeSpec\n    Parameters to feed to mode solver which determine modes measured by monitor.\ndirection : Literal['+', '-'] = +\n    Direction of waveguide mode propagation along the axis defined by its normal dimension.\n\nExample\n-------\n>>> mode_spec = ModeSpec(num_modes=3)\n>>> monitor = ModeSolverMonitor(\n...     center=(1,2,3),\n...     size=(2,2,0),\n...     freqs=[200e12, 210e12],\n...     mode_spec=mode_spec,\n...     name='mode_monitor')",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "ModeSolverMonitor",
          "enum": [
            "ModeSolverMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "interval_space": {
          "title": "Spatial Interval",
          "description": "Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Not all monitors support values different from 1.",
          "default": [
            1,
            1,
            1
          ],
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "enum": [
                1
              ],
              "type": "integer"
            },
            {
              "enum": [
                1
              ],
              "type": "integer"
            },
            {
              "enum": [
                1
              ],
              "type": "integer"
            }
          ]
        },
        "colocate": {
          "title": "Colocate Fields",
          "description": "Toggle whether fields should be colocated to grid cell boundaries (i.e. primal grid nodes).",
          "default": true,
          "type": "boolean"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        },
        "apodization": {
          "title": "Apodization Specification",
          "description": "Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.",
          "default": {
            "start": null,
            "end": null,
            "width": null,
            "type": "ApodizationSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ApodizationSpec"
            }
          ]
        },
        "mode_spec": {
          "title": "Mode Specification",
          "description": "Parameters to feed to mode solver which determine modes measured by monitor.",
          "allOf": [
            {
              "$ref": "#/definitions/ModeSpec"
            }
          ]
        },
        "direction": {
          "title": "Propagation Direction",
          "description": "Direction of waveguide mode propagation along the axis defined by its normal dimension.",
          "default": "+",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        }
      },
      "required": [
        "size",
        "name",
        "freqs",
        "mode_spec"
      ],
      "additionalProperties": false
    },
    "FieldProjectionAngleMonitor": {
      "title": "FieldProjectionAngleMonitor",
      "description": ":class:`Monitor` that samples electromagnetic near fields in the frequency domain\nand projects them at given observation angles. The ``center`` and ``size`` fields define\nwhere the monitor will be placed in order to record near fields, typically very close\nto the structure of interest. The near fields are then projected\nto far-field locations defined by ``phi``, ``theta``, and ``proj_distance``, relative\nto the ``custom_origin``. If the distance between the near and far field locations is\nmuch larger than the size of the device, one can typically set ``far_field_approx`` to\n``True``, which will make use of the far-field approximation to speed up calculations.\nIf the projection distance is comparable to the size of the device, we recommend setting\n``far_field_approx`` to ``False``, so that the approximations are not used, and the\nprojection is accurate even just a few wavelengths away from the near field locations.\nFor applications where the monitor is an open surface rather than a box that\nencloses the device, it is advisable to pick the size of the monitor such that the\nrecorded near fields decay to negligible values near the edges of the monitor.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\ninterval_space : Tuple[PositiveInt, PositiveInt, PositiveInt] = (1, 1, 1)\n    Number of grid step intervals at which near fields are recorded for projection to the far field, along each direction. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Using values greater than 1 can help speed up server-side far field projections with minimal accuracy loss, especially in cases where it is necessary for the grid resolution to be high for the FDTD simulation, but such a high resolution is unnecessary for the purpose of projecting the recorded near fields to the far field.\ncolocate : Literal[True] = True\n    Defines whether fields are colocated to grid cell boundaries (i.e. to the primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors and is hard-coded for other monitors depending on their specific function.\nfreqs : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\napodization : ApodizationSpec = ApodizationSpec(start=None, end=None, width=None, type='ApodizationSpec')\n    Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.\nnormal_dir : Optional[Literal['+', '-']] = None\n    Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.\nexclude_surfaces : Optional[Tuple[Literal['x-', 'x+', 'y-', 'y+', 'z-', 'z+'], ...]] = None\n    Surfaces to exclude in the integration, if a volume monitor.\ncustom_origin : Optional[Tuple[float, float, float]] = None\n    [units = um].  Local origin used for defining observation points. If ``None``, uses the monitor's center.\nfar_field_approx : bool = True\n    Whether to enable the far field approximation when projecting fields. If ``True``, terms that decay as O(1/r^2) are ignored, as are the radial components of fields. Typically, this should be set to ``True`` only when the projection distance is much larger than the size of the device being modeled, and the projected points are in the far field of the device.\nwindow_size : Tuple[NonNegativeFloat, NonNegativeFloat] = (0, 0)\n    Size of the transition region of the windowing function used to ensure that the recorded near fields decay to zero near the edges of the monitor. The two components refer to the two tangential directions associated with each surface. For surfaces with the normal along ``x``, the two components are (``y``, ``z``). For surfaces with the normal along ``y``, the two components are (``x``, ``z``). For surfaces with the normal along ``z``, the two components are (``x``, ``y``). Each value must be between 0 and 1, inclusive, and denotes the size of the transition region over which fields are scaled to less than a thousandth of the original amplitude, relative to half the size of the monitor in that direction. A value of 0 turns windowing off in that direction, while a value of 1 indicates that the window will be applied to the entire monitor in that direction. This field is applicable for surface monitors only, and otherwise must remain (0, 0).\nmedium : Union[Medium, AnisotropicMedium, PECMedium, PoleResidue, Sellmeier, Lorentz, Debye, Drude, FullyAnisotropicMedium, CustomMedium, CustomPoleResidue, CustomSellmeier, CustomLorentz, CustomDebye, CustomDrude, CustomAnisotropicMedium, PerturbationMedium, PerturbationPoleResidue, Medium2D] = None\n    Medium through which to project fields. Generally, the fields should be projected through the same medium as the one in which this monitor is placed, and this is the default behavior when ``medium=None``. A custom ``medium`` can be useful in some situations for advanced users, but we recommend trying to avoid using a non-default ``medium``.\nproj_distance : float = 1000000.0\n    [units = um].  Radial distance of the projection points from ``local_origin``.\ntheta : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    [units = rad].  Polar angles with respect to the global z axis, relative to the location of ``local_origin``, at which to project fields.\nphi : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    [units = rad].  Azimuth angles with respect to the global z axis, relative to the location of ``local_origin``, at which to project fields.\n\nExample\n-------\n>>> monitor = FieldProjectionAngleMonitor(\n...     center=(1,2,3),\n...     size=(2,2,2),\n...     freqs=[250e12, 300e12],\n...     name='n2f_monitor',\n...     custom_origin=(1,2,3),\n...     phi=[0, np.pi/2],\n...     theta=np.linspace(-np.pi/2, np.pi/2, 100)\n...     )",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "FieldProjectionAngleMonitor",
          "enum": [
            "FieldProjectionAngleMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "interval_space": {
          "title": "Spatial Interval",
          "description": "Number of grid step intervals at which near fields are recorded for projection to the far field, along each direction. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Using values greater than 1 can help speed up server-side far field projections with minimal accuracy loss, especially in cases where it is necessary for the grid resolution to be high for the FDTD simulation, but such a high resolution is unnecessary for the purpose of projecting the recorded near fields to the far field.",
          "default": [
            1,
            1,
            1
          ],
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "integer",
              "exclusiveMinimum": 0
            },
            {
              "type": "integer",
              "exclusiveMinimum": 0
            },
            {
              "type": "integer",
              "exclusiveMinimum": 0
            }
          ]
        },
        "colocate": {
          "title": "Colocate Fields",
          "description": "Defines whether fields are colocated to grid cell boundaries (i.e. to the primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors and is hard-coded for other monitors depending on their specific function.",
          "default": true,
          "enum": [
            true
          ],
          "type": "boolean"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        },
        "apodization": {
          "title": "Apodization Specification",
          "description": "Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.",
          "default": {
            "start": null,
            "end": null,
            "width": null,
            "type": "ApodizationSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ApodizationSpec"
            }
          ]
        },
        "normal_dir": {
          "title": "Normal Vector Orientation",
          "description": "Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "exclude_surfaces": {
          "title": "Excluded Surfaces",
          "description": "Surfaces to exclude in the integration, if a volume monitor.",
          "type": "array",
          "items": {
            "enum": [
              "x-",
              "x+",
              "y-",
              "y+",
              "z-",
              "z+"
            ],
            "type": "string"
          }
        },
        "custom_origin": {
          "title": "Local Origin",
          "description": "Local origin used for defining observation points. If ``None``, uses the monitor's center.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "far_field_approx": {
          "title": "Far Field Approximation",
          "description": "Whether to enable the far field approximation when projecting fields. If ``True``, terms that decay as O(1/r^2) are ignored, as are the radial components of fields. Typically, this should be set to ``True`` only when the projection distance is much larger than the size of the device being modeled, and the projected points are in the far field of the device.",
          "default": true,
          "type": "boolean"
        },
        "window_size": {
          "title": "Spatial filtering window size",
          "description": "Size of the transition region of the windowing function used to ensure that the recorded near fields decay to zero near the edges of the monitor. The two components refer to the two tangential directions associated with each surface. For surfaces with the normal along ``x``, the two components are (``y``, ``z``). For surfaces with the normal along ``y``, the two components are (``x``, ``z``). For surfaces with the normal along ``z``, the two components are (``x``, ``y``). Each value must be between 0 and 1, inclusive, and denotes the size of the transition region over which fields are scaled to less than a thousandth of the original amplitude, relative to half the size of the monitor in that direction. A value of 0 turns windowing off in that direction, while a value of 1 indicates that the window will be applied to the entire monitor in that direction. This field is applicable for surface monitors only, and otherwise must remain (0, 0).",
          "default": [
            0,
            0
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "medium": {
          "title": "Projection medium",
          "description": "Medium through which to project fields. Generally, the fields should be projected through the same medium as the one in which this monitor is placed, and this is the default behavior when ``medium=None``. A custom ``medium`` can be useful in some situations for advanced users, but we recommend trying to avoid using a non-default ``medium``.",
          "anyOf": [
            {
              "$ref": "#/definitions/Medium"
            },
            {
              "$ref": "#/definitions/AnisotropicMedium"
            },
            {
              "$ref": "#/definitions/PECMedium"
            },
            {
              "$ref": "#/definitions/PoleResidue"
            },
            {
              "$ref": "#/definitions/Sellmeier"
            },
            {
              "$ref": "#/definitions/Lorentz"
            },
            {
              "$ref": "#/definitions/Debye"
            },
            {
              "$ref": "#/definitions/Drude"
            },
            {
              "$ref": "#/definitions/FullyAnisotropicMedium"
            },
            {
              "$ref": "#/definitions/CustomMedium"
            },
            {
              "$ref": "#/definitions/CustomPoleResidue"
            },
            {
              "$ref": "#/definitions/CustomSellmeier"
            },
            {
              "$ref": "#/definitions/CustomLorentz"
            },
            {
              "$ref": "#/definitions/CustomDebye"
            },
            {
              "$ref": "#/definitions/CustomDrude"
            },
            {
              "$ref": "#/definitions/CustomAnisotropicMedium"
            },
            {
              "$ref": "#/definitions/PerturbationMedium"
            },
            {
              "$ref": "#/definitions/PerturbationPoleResidue"
            },
            {
              "$ref": "#/definitions/Medium2D"
            }
          ]
        },
        "proj_distance": {
          "title": "Projection Distance",
          "description": "Radial distance of the projection points from ``local_origin``.",
          "default": 1000000.0,
          "units": "um",
          "type": "number"
        },
        "theta": {
          "title": "Polar Angles",
          "description": "Polar angles with respect to the global z axis, relative to the location of ``local_origin``, at which to project fields.",
          "units": "rad",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        },
        "phi": {
          "title": "Azimuth Angles",
          "description": "Azimuth angles with respect to the global z axis, relative to the location of ``local_origin``, at which to project fields.",
          "units": "rad",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        }
      },
      "required": [
        "size",
        "name",
        "freqs",
        "theta",
        "phi"
      ],
      "additionalProperties": false
    },
    "FieldProjectionCartesianMonitor": {
      "title": "FieldProjectionCartesianMonitor",
      "description": ":class:`Monitor` that samples electromagnetic near fields in the frequency domain\nand projects them on a Cartesian observation plane. The ``center`` and ``size`` fields define\nwhere the monitor will be placed in order to record near fields, typically very close\nto the structure of interest. The near fields are then projected\nto far-field locations defined by ``x``, ``y``, and ``proj_distance``, relative\nto the ``custom_origin``. Here, ``x`` and ``y`` correspond to a local coordinate system\nwhere the local z axis is defined by ``proj_axis``: which is the axis normal to this monitor.\nIf the distance between the near and far field locations is much larger than the size of the\ndevice, one can typically set ``far_field_approx`` to ``True``, which will make use of the\nfar-field approximation to speed up calculations. If the projection distance is comparable\nto the size of the device, we recommend setting ``far_field_approx`` to ``False``,\nso that the approximations are not used, and the projection is accurate even just a few\nwavelengths away from the near field locations.\nFor applications where the monitor is an open surface rather than a box that\nencloses the device, it is advisable to pick the size of the monitor such that the\nrecorded near fields decay to negligible values near the edges of the monitor.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\ninterval_space : Tuple[PositiveInt, PositiveInt, PositiveInt] = (1, 1, 1)\n    Number of grid step intervals at which near fields are recorded for projection to the far field, along each direction. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Using values greater than 1 can help speed up server-side far field projections with minimal accuracy loss, especially in cases where it is necessary for the grid resolution to be high for the FDTD simulation, but such a high resolution is unnecessary for the purpose of projecting the recorded near fields to the far field.\ncolocate : Literal[True] = True\n    Defines whether fields are colocated to grid cell boundaries (i.e. to the primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors and is hard-coded for other monitors depending on their specific function.\nfreqs : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\napodization : ApodizationSpec = ApodizationSpec(start=None, end=None, width=None, type='ApodizationSpec')\n    Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.\nnormal_dir : Optional[Literal['+', '-']] = None\n    Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.\nexclude_surfaces : Optional[Tuple[Literal['x-', 'x+', 'y-', 'y+', 'z-', 'z+'], ...]] = None\n    Surfaces to exclude in the integration, if a volume monitor.\ncustom_origin : Optional[Tuple[float, float, float]] = None\n    [units = um].  Local origin used for defining observation points. If ``None``, uses the monitor's center.\nfar_field_approx : bool = True\n    Whether to enable the far field approximation when projecting fields. If ``True``, terms that decay as O(1/r^2) are ignored, as are the radial components of fields. Typically, this should be set to ``True`` only when the projection distance is much larger than the size of the device being modeled, and the projected points are in the far field of the device.\nwindow_size : Tuple[NonNegativeFloat, NonNegativeFloat] = (0, 0)\n    Size of the transition region of the windowing function used to ensure that the recorded near fields decay to zero near the edges of the monitor. The two components refer to the two tangential directions associated with each surface. For surfaces with the normal along ``x``, the two components are (``y``, ``z``). For surfaces with the normal along ``y``, the two components are (``x``, ``z``). For surfaces with the normal along ``z``, the two components are (``x``, ``y``). Each value must be between 0 and 1, inclusive, and denotes the size of the transition region over which fields are scaled to less than a thousandth of the original amplitude, relative to half the size of the monitor in that direction. A value of 0 turns windowing off in that direction, while a value of 1 indicates that the window will be applied to the entire monitor in that direction. This field is applicable for surface monitors only, and otherwise must remain (0, 0).\nmedium : Union[Medium, AnisotropicMedium, PECMedium, PoleResidue, Sellmeier, Lorentz, Debye, Drude, FullyAnisotropicMedium, CustomMedium, CustomPoleResidue, CustomSellmeier, CustomLorentz, CustomDebye, CustomDrude, CustomAnisotropicMedium, PerturbationMedium, PerturbationPoleResidue, Medium2D] = None\n    Medium through which to project fields. Generally, the fields should be projected through the same medium as the one in which this monitor is placed, and this is the default behavior when ``medium=None``. A custom ``medium`` can be useful in some situations for advanced users, but we recommend trying to avoid using a non-default ``medium``.\nproj_axis : Literal[0, 1, 2]\n    Axis along which the observation plane is oriented.\nproj_distance : float = 1000000.0\n    [units = um].  Signed distance of the projection plane along ``proj_axis``. from the plane containing ``local_origin``.\nx : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    [units = um].  Local x observation coordinates w.r.t. ``local_origin`` and ``proj_axis``. When ``proj_axis`` is 0, this corresponds to the global y axis. When ``proj_axis`` is 1, this corresponds to the global x axis. When ``proj_axis`` is 2, this corresponds to the global x axis. \ny : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    [units = um].  Local y observation coordinates w.r.t. ``local_origin`` and ``proj_axis``. When ``proj_axis`` is 0, this corresponds to the global z axis. When ``proj_axis`` is 1, this corresponds to the global z axis. When ``proj_axis`` is 2, this corresponds to the global y axis. \n\nExample\n-------\n>>> monitor = FieldProjectionCartesianMonitor(\n...     center=(1,2,3),\n...     size=(2,2,2),\n...     freqs=[250e12, 300e12],\n...     name='n2f_monitor',\n...     custom_origin=(1,2,3),\n...     x=[-1, 0, 1],\n...     y=[-2, -1, 0, 1, 2],\n...     proj_axis=2,\n...     proj_distance=5\n...     )",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "FieldProjectionCartesianMonitor",
          "enum": [
            "FieldProjectionCartesianMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "interval_space": {
          "title": "Spatial Interval",
          "description": "Number of grid step intervals at which near fields are recorded for projection to the far field, along each direction. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Using values greater than 1 can help speed up server-side far field projections with minimal accuracy loss, especially in cases where it is necessary for the grid resolution to be high for the FDTD simulation, but such a high resolution is unnecessary for the purpose of projecting the recorded near fields to the far field.",
          "default": [
            1,
            1,
            1
          ],
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "integer",
              "exclusiveMinimum": 0
            },
            {
              "type": "integer",
              "exclusiveMinimum": 0
            },
            {
              "type": "integer",
              "exclusiveMinimum": 0
            }
          ]
        },
        "colocate": {
          "title": "Colocate Fields",
          "description": "Defines whether fields are colocated to grid cell boundaries (i.e. to the primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors and is hard-coded for other monitors depending on their specific function.",
          "default": true,
          "enum": [
            true
          ],
          "type": "boolean"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        },
        "apodization": {
          "title": "Apodization Specification",
          "description": "Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.",
          "default": {
            "start": null,
            "end": null,
            "width": null,
            "type": "ApodizationSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ApodizationSpec"
            }
          ]
        },
        "normal_dir": {
          "title": "Normal Vector Orientation",
          "description": "Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "exclude_surfaces": {
          "title": "Excluded Surfaces",
          "description": "Surfaces to exclude in the integration, if a volume monitor.",
          "type": "array",
          "items": {
            "enum": [
              "x-",
              "x+",
              "y-",
              "y+",
              "z-",
              "z+"
            ],
            "type": "string"
          }
        },
        "custom_origin": {
          "title": "Local Origin",
          "description": "Local origin used for defining observation points. If ``None``, uses the monitor's center.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "far_field_approx": {
          "title": "Far Field Approximation",
          "description": "Whether to enable the far field approximation when projecting fields. If ``True``, terms that decay as O(1/r^2) are ignored, as are the radial components of fields. Typically, this should be set to ``True`` only when the projection distance is much larger than the size of the device being modeled, and the projected points are in the far field of the device.",
          "default": true,
          "type": "boolean"
        },
        "window_size": {
          "title": "Spatial filtering window size",
          "description": "Size of the transition region of the windowing function used to ensure that the recorded near fields decay to zero near the edges of the monitor. The two components refer to the two tangential directions associated with each surface. For surfaces with the normal along ``x``, the two components are (``y``, ``z``). For surfaces with the normal along ``y``, the two components are (``x``, ``z``). For surfaces with the normal along ``z``, the two components are (``x``, ``y``). Each value must be between 0 and 1, inclusive, and denotes the size of the transition region over which fields are scaled to less than a thousandth of the original amplitude, relative to half the size of the monitor in that direction. A value of 0 turns windowing off in that direction, while a value of 1 indicates that the window will be applied to the entire monitor in that direction. This field is applicable for surface monitors only, and otherwise must remain (0, 0).",
          "default": [
            0,
            0
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "medium": {
          "title": "Projection medium",
          "description": "Medium through which to project fields. Generally, the fields should be projected through the same medium as the one in which this monitor is placed, and this is the default behavior when ``medium=None``. A custom ``medium`` can be useful in some situations for advanced users, but we recommend trying to avoid using a non-default ``medium``.",
          "anyOf": [
            {
              "$ref": "#/definitions/Medium"
            },
            {
              "$ref": "#/definitions/AnisotropicMedium"
            },
            {
              "$ref": "#/definitions/PECMedium"
            },
            {
              "$ref": "#/definitions/PoleResidue"
            },
            {
              "$ref": "#/definitions/Sellmeier"
            },
            {
              "$ref": "#/definitions/Lorentz"
            },
            {
              "$ref": "#/definitions/Debye"
            },
            {
              "$ref": "#/definitions/Drude"
            },
            {
              "$ref": "#/definitions/FullyAnisotropicMedium"
            },
            {
              "$ref": "#/definitions/CustomMedium"
            },
            {
              "$ref": "#/definitions/CustomPoleResidue"
            },
            {
              "$ref": "#/definitions/CustomSellmeier"
            },
            {
              "$ref": "#/definitions/CustomLorentz"
            },
            {
              "$ref": "#/definitions/CustomDebye"
            },
            {
              "$ref": "#/definitions/CustomDrude"
            },
            {
              "$ref": "#/definitions/CustomAnisotropicMedium"
            },
            {
              "$ref": "#/definitions/PerturbationMedium"
            },
            {
              "$ref": "#/definitions/PerturbationPoleResidue"
            },
            {
              "$ref": "#/definitions/Medium2D"
            }
          ]
        },
        "proj_axis": {
          "title": "Projection Plane Axis",
          "description": "Axis along which the observation plane is oriented.",
          "enum": [
            0,
            1,
            2
          ],
          "type": "integer"
        },
        "proj_distance": {
          "title": "Projection Distance",
          "description": "Signed distance of the projection plane along ``proj_axis``. from the plane containing ``local_origin``.",
          "default": 1000000.0,
          "units": "um",
          "type": "number"
        },
        "x": {
          "title": "Local x Observation Coordinates",
          "description": "Local x observation coordinates w.r.t. ``local_origin`` and ``proj_axis``. When ``proj_axis`` is 0, this corresponds to the global y axis. When ``proj_axis`` is 1, this corresponds to the global x axis. When ``proj_axis`` is 2, this corresponds to the global x axis. ",
          "units": "um",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        },
        "y": {
          "title": "Local y Observation Coordinates",
          "description": "Local y observation coordinates w.r.t. ``local_origin`` and ``proj_axis``. When ``proj_axis`` is 0, this corresponds to the global z axis. When ``proj_axis`` is 1, this corresponds to the global z axis. When ``proj_axis`` is 2, this corresponds to the global y axis. ",
          "units": "um",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        }
      },
      "required": [
        "size",
        "name",
        "freqs",
        "proj_axis",
        "x",
        "y"
      ],
      "additionalProperties": false
    },
    "FieldProjectionKSpaceMonitor": {
      "title": "FieldProjectionKSpaceMonitor",
      "description": ":class:`Monitor` that samples electromagnetic near fields in the frequency domain\nand projects them on an observation plane defined in k-space. The ``center`` and ``size``\nfields define where the monitor will be placed in order to record near fields, typically\nvery close to the structure of interest. The near fields are then\nprojected to far-field locations defined in k-space by ``ux``, ``uy``, and ``proj_distance``,\nrelative to the ``custom_origin``. Here, ``ux`` and ``uy`` are associated with a local\ncoordinate system where the local 'z' axis is defined by ``proj_axis``: which is the axis\nnormal to this monitor. If the distance between the near and far field locations is much\nlarger than the size of the device, one can typically set ``far_field_approx`` to ``True``,\nwhich will make use of the far-field approximation to speed up calculations. If the\nprojection distance is comparable to the size of the device, we recommend setting\n``far_field_approx`` to ``False``, so that the approximations are not used, and the\nprojection is accurate even just a few wavelengths away from the near field locations.\nFor applications where the monitor is an open surface rather than a box that\nencloses the device, it is advisable to pick the size of the monitor such that the\nrecorded near fields decay to negligible values near the edges of the monitor.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\ninterval_space : Tuple[PositiveInt, PositiveInt, PositiveInt] = (1, 1, 1)\n    Number of grid step intervals at which near fields are recorded for projection to the far field, along each direction. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Using values greater than 1 can help speed up server-side far field projections with minimal accuracy loss, especially in cases where it is necessary for the grid resolution to be high for the FDTD simulation, but such a high resolution is unnecessary for the purpose of projecting the recorded near fields to the far field.\ncolocate : Literal[True] = True\n    Defines whether fields are colocated to grid cell boundaries (i.e. to the primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors and is hard-coded for other monitors depending on their specific function.\nfreqs : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\napodization : ApodizationSpec = ApodizationSpec(start=None, end=None, width=None, type='ApodizationSpec')\n    Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.\nnormal_dir : Optional[Literal['+', '-']] = None\n    Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.\nexclude_surfaces : Optional[Tuple[Literal['x-', 'x+', 'y-', 'y+', 'z-', 'z+'], ...]] = None\n    Surfaces to exclude in the integration, if a volume monitor.\ncustom_origin : Optional[Tuple[float, float, float]] = None\n    [units = um].  Local origin used for defining observation points. If ``None``, uses the monitor's center.\nfar_field_approx : bool = True\n    Whether to enable the far field approximation when projecting fields. If ``True``, terms that decay as O(1/r^2) are ignored, as are the radial components of fields. Typically, this should be set to ``True`` only when the projection distance is much larger than the size of the device being modeled, and the projected points are in the far field of the device.\nwindow_size : Tuple[NonNegativeFloat, NonNegativeFloat] = (0, 0)\n    Size of the transition region of the windowing function used to ensure that the recorded near fields decay to zero near the edges of the monitor. The two components refer to the two tangential directions associated with each surface. For surfaces with the normal along ``x``, the two components are (``y``, ``z``). For surfaces with the normal along ``y``, the two components are (``x``, ``z``). For surfaces with the normal along ``z``, the two components are (``x``, ``y``). Each value must be between 0 and 1, inclusive, and denotes the size of the transition region over which fields are scaled to less than a thousandth of the original amplitude, relative to half the size of the monitor in that direction. A value of 0 turns windowing off in that direction, while a value of 1 indicates that the window will be applied to the entire monitor in that direction. This field is applicable for surface monitors only, and otherwise must remain (0, 0).\nmedium : Union[Medium, AnisotropicMedium, PECMedium, PoleResidue, Sellmeier, Lorentz, Debye, Drude, FullyAnisotropicMedium, CustomMedium, CustomPoleResidue, CustomSellmeier, CustomLorentz, CustomDebye, CustomDrude, CustomAnisotropicMedium, PerturbationMedium, PerturbationPoleResidue, Medium2D] = None\n    Medium through which to project fields. Generally, the fields should be projected through the same medium as the one in which this monitor is placed, and this is the default behavior when ``medium=None``. A custom ``medium`` can be useful in some situations for advanced users, but we recommend trying to avoid using a non-default ``medium``.\nproj_axis : Literal[0, 1, 2]\n    Axis along which the observation plane is oriented.\nproj_distance : float = 1000000.0\n    [units = um].  Radial distance of the projection points from ``local_origin``.\nux : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    Local x component of wave vectors on the observation plane, relative to ``local_origin`` and oriented with respect to ``proj_axis``, normalized by (2*pi/lambda) where lambda is the wavelength associated with the background medium. Must be in the range [-1, 1].\nuy : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    Local y component of wave vectors on the observation plane, relative to ``local_origin`` and oriented with respect to ``proj_axis``, normalized by (2*pi/lambda) where lambda is the wavelength associated with the background medium. Must be in the range [-1, 1].\n\nExample\n-------\n>>> monitor = FieldProjectionKSpaceMonitor(\n...     center=(1,2,3),\n...     size=(2,2,2),\n...     freqs=[250e12, 300e12],\n...     name='n2f_monitor',\n...     custom_origin=(1,2,3),\n...     proj_axis=2,\n...     ux=[0.1,0.2],\n...     uy=[0.3,0.4,0.5]\n...     )",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "FieldProjectionKSpaceMonitor",
          "enum": [
            "FieldProjectionKSpaceMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "interval_space": {
          "title": "Spatial Interval",
          "description": "Number of grid step intervals at which near fields are recorded for projection to the far field, along each direction. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Using values greater than 1 can help speed up server-side far field projections with minimal accuracy loss, especially in cases where it is necessary for the grid resolution to be high for the FDTD simulation, but such a high resolution is unnecessary for the purpose of projecting the recorded near fields to the far field.",
          "default": [
            1,
            1,
            1
          ],
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "integer",
              "exclusiveMinimum": 0
            },
            {
              "type": "integer",
              "exclusiveMinimum": 0
            },
            {
              "type": "integer",
              "exclusiveMinimum": 0
            }
          ]
        },
        "colocate": {
          "title": "Colocate Fields",
          "description": "Defines whether fields are colocated to grid cell boundaries (i.e. to the primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors and is hard-coded for other monitors depending on their specific function.",
          "default": true,
          "enum": [
            true
          ],
          "type": "boolean"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        },
        "apodization": {
          "title": "Apodization Specification",
          "description": "Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.",
          "default": {
            "start": null,
            "end": null,
            "width": null,
            "type": "ApodizationSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ApodizationSpec"
            }
          ]
        },
        "normal_dir": {
          "title": "Normal Vector Orientation",
          "description": "Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "exclude_surfaces": {
          "title": "Excluded Surfaces",
          "description": "Surfaces to exclude in the integration, if a volume monitor.",
          "type": "array",
          "items": {
            "enum": [
              "x-",
              "x+",
              "y-",
              "y+",
              "z-",
              "z+"
            ],
            "type": "string"
          }
        },
        "custom_origin": {
          "title": "Local Origin",
          "description": "Local origin used for defining observation points. If ``None``, uses the monitor's center.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "far_field_approx": {
          "title": "Far Field Approximation",
          "description": "Whether to enable the far field approximation when projecting fields. If ``True``, terms that decay as O(1/r^2) are ignored, as are the radial components of fields. Typically, this should be set to ``True`` only when the projection distance is much larger than the size of the device being modeled, and the projected points are in the far field of the device.",
          "default": true,
          "type": "boolean"
        },
        "window_size": {
          "title": "Spatial filtering window size",
          "description": "Size of the transition region of the windowing function used to ensure that the recorded near fields decay to zero near the edges of the monitor. The two components refer to the two tangential directions associated with each surface. For surfaces with the normal along ``x``, the two components are (``y``, ``z``). For surfaces with the normal along ``y``, the two components are (``x``, ``z``). For surfaces with the normal along ``z``, the two components are (``x``, ``y``). Each value must be between 0 and 1, inclusive, and denotes the size of the transition region over which fields are scaled to less than a thousandth of the original amplitude, relative to half the size of the monitor in that direction. A value of 0 turns windowing off in that direction, while a value of 1 indicates that the window will be applied to the entire monitor in that direction. This field is applicable for surface monitors only, and otherwise must remain (0, 0).",
          "default": [
            0,
            0
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "medium": {
          "title": "Projection medium",
          "description": "Medium through which to project fields. Generally, the fields should be projected through the same medium as the one in which this monitor is placed, and this is the default behavior when ``medium=None``. A custom ``medium`` can be useful in some situations for advanced users, but we recommend trying to avoid using a non-default ``medium``.",
          "anyOf": [
            {
              "$ref": "#/definitions/Medium"
            },
            {
              "$ref": "#/definitions/AnisotropicMedium"
            },
            {
              "$ref": "#/definitions/PECMedium"
            },
            {
              "$ref": "#/definitions/PoleResidue"
            },
            {
              "$ref": "#/definitions/Sellmeier"
            },
            {
              "$ref": "#/definitions/Lorentz"
            },
            {
              "$ref": "#/definitions/Debye"
            },
            {
              "$ref": "#/definitions/Drude"
            },
            {
              "$ref": "#/definitions/FullyAnisotropicMedium"
            },
            {
              "$ref": "#/definitions/CustomMedium"
            },
            {
              "$ref": "#/definitions/CustomPoleResidue"
            },
            {
              "$ref": "#/definitions/CustomSellmeier"
            },
            {
              "$ref": "#/definitions/CustomLorentz"
            },
            {
              "$ref": "#/definitions/CustomDebye"
            },
            {
              "$ref": "#/definitions/CustomDrude"
            },
            {
              "$ref": "#/definitions/CustomAnisotropicMedium"
            },
            {
              "$ref": "#/definitions/PerturbationMedium"
            },
            {
              "$ref": "#/definitions/PerturbationPoleResidue"
            },
            {
              "$ref": "#/definitions/Medium2D"
            }
          ]
        },
        "proj_axis": {
          "title": "Projection Plane Axis",
          "description": "Axis along which the observation plane is oriented.",
          "enum": [
            0,
            1,
            2
          ],
          "type": "integer"
        },
        "proj_distance": {
          "title": "Projection Distance",
          "description": "Radial distance of the projection points from ``local_origin``.",
          "default": 1000000.0,
          "units": "um",
          "type": "number"
        },
        "ux": {
          "title": "Normalized kx",
          "description": "Local x component of wave vectors on the observation plane, relative to ``local_origin`` and oriented with respect to ``proj_axis``, normalized by (2*pi/lambda) where lambda is the wavelength associated with the background medium. Must be in the range [-1, 1].",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        },
        "uy": {
          "title": "Normalized ky",
          "description": "Local y component of wave vectors on the observation plane, relative to ``local_origin`` and oriented with respect to ``proj_axis``, normalized by (2*pi/lambda) where lambda is the wavelength associated with the background medium. Must be in the range [-1, 1].",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        }
      },
      "required": [
        "size",
        "name",
        "freqs",
        "proj_axis",
        "ux",
        "uy"
      ],
      "additionalProperties": false
    },
    "DiffractionMonitor": {
      "title": "DiffractionMonitor",
      "description": ":class:`Monitor` that uses a 2D Fourier transform to compute the\ndiffraction amplitudes and efficiency for allowed diffraction orders.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\ninterval_space : Tuple[Literal[1], Literal[1], Literal[1]] = (1, 1, 1)\n    Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Not all monitors support values different from 1.\ncolocate : Literal[False] = False\n    Defines whether fields are colocated to grid cell boundaries (i.e. to the primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors and is hard-coded for other monitors depending on their specific function.\nfreqs : Union[Tuple[float, ...], ArrayLike[dtype=float, ndim=1]]\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\napodization : ApodizationSpec = ApodizationSpec(start=None, end=None, width=None, type='ApodizationSpec')\n    Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.\nnormal_dir : Literal['+', '-'] = +\n    Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Defaults to ``'+'`` if not provided.\n\nExample\n-------\n>>> monitor = DiffractionMonitor(\n...     center=(1,2,3),\n...     size=(inf,inf,0),\n...     freqs=[250e12, 300e12],\n...     name='diffraction_monitor',\n...     normal_dir='+',\n...     )",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "DiffractionMonitor",
          "enum": [
            "DiffractionMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "interval_space": {
          "title": "Spatial Interval",
          "description": "Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, the step will be applied, but the first and last point of the monitor grid are always included. Not all monitors support values different from 1.",
          "default": [
            1,
            1,
            1
          ],
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "enum": [
                1
              ],
              "type": "integer"
            },
            {
              "enum": [
                1
              ],
              "type": "integer"
            },
            {
              "enum": [
                1
              ],
              "type": "integer"
            }
          ]
        },
        "colocate": {
          "title": "Colocate Fields",
          "description": "Defines whether fields are colocated to grid cell boundaries (i.e. to the primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors and is hard-coded for other monitors depending on their specific function.",
          "default": false,
          "enum": [
            false
          ],
          "type": "boolean"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "type": "ArrayLike"
            }
          ]
        },
        "apodization": {
          "title": "Apodization Specification",
          "description": "Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.",
          "default": {
            "start": null,
            "end": null,
            "width": null,
            "type": "ApodizationSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ApodizationSpec"
            }
          ]
        },
        "normal_dir": {
          "title": "Normal Vector Orientation",
          "description": "Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Defaults to ``'+'`` if not provided.",
          "default": "+",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        }
      },
      "required": [
        "size",
        "name",
        "freqs"
      ],
      "additionalProperties": false
    },
    "UniformGrid": {
      "title": "UniformGrid",
      "description": "Uniform 1D grid.\n\nParameters\n----------\ndl : PositiveFloat\n    [units = um].  Grid size for uniform grid generation.\n\nExample\n-------\n>>> grid_1d = UniformGrid(dl=0.1)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "UniformGrid",
          "enum": [
            "UniformGrid"
          ],
          "type": "string"
        },
        "dl": {
          "title": "Grid Size",
          "description": "Grid size for uniform grid generation.",
          "units": "um",
          "exclusiveMinimum": 0,
          "type": "number"
        }
      },
      "required": [
        "dl"
      ],
      "additionalProperties": false
    },
    "CustomGrid": {
      "title": "CustomGrid",
      "description": "Custom 1D grid supplied as a list of grid cell sizes centered on the simulation center.\n\nParameters\n----------\ndl : Tuple[PositiveFloat, ...]\n    [units = um].  An array of custom nonuniform grid sizes. The resulting grid is centered on the simulation center such that it spans the region ``(center - sum(dl)/2, center + sum(dl)/2)``, unless a ``custom_offset`` is given. Note: if supplied sizes do not cover the simulation size, the first and last sizes are repeated to cover the simulation domain.\ncustom_offset : Optional[float] = None\n    [units = um].  The starting coordinate of the grid which defines the simulation center. If ``None``, the simulation center is set such that it spans the region ``(center - sum(dl)/2, center + sum(dl)/2)``.\n\nExample\n-------\n>>> grid_1d = CustomGrid(dl=[0.2, 0.2, 0.1, 0.1, 0.1, 0.2, 0.2])",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "CustomGrid",
          "enum": [
            "CustomGrid"
          ],
          "type": "string"
        },
        "dl": {
          "title": "Customized grid sizes.",
          "description": "An array of custom nonuniform grid sizes. The resulting grid is centered on the simulation center such that it spans the region ``(center - sum(dl)/2, center + sum(dl)/2)``, unless a ``custom_offset`` is given. Note: if supplied sizes do not cover the simulation size, the first and last sizes are repeated to cover the simulation domain.",
          "units": "um",
          "type": "array",
          "items": {
            "type": "number",
            "exclusiveMinimum": 0
          }
        },
        "custom_offset": {
          "title": "Customized grid offset.",
          "description": "The starting coordinate of the grid which defines the simulation center. If ``None``, the simulation center is set such that it spans the region ``(center - sum(dl)/2, center + sum(dl)/2)``.",
          "units": "um",
          "type": "number"
        }
      },
      "required": [
        "dl"
      ],
      "additionalProperties": false
    },
    "GradedMesher": {
      "title": "GradedMesher",
      "description": "Implements automatic nonuniform meshing with a set minimum steps per wavelength and\na graded mesh expanding from higher- to lower-resolution regions.\n\nParameters\n----------",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "GradedMesher",
          "enum": [
            "GradedMesher"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "AutoGrid": {
      "title": "AutoGrid",
      "description": "Specification for non-uniform grid along a given dimension.\n\nParameters\n----------\nmin_steps_per_wvl : ConstrainedFloatValue = 10.0\n    Minimal number of steps per wavelength in each medium.\nmax_scale : ConstrainedFloatValue = 1.4\n    Sets the maximum ratio between any two consecutive grid steps.\ndl_min : NonNegativeFloat = 0\n    Lower bound of the grid size along this dimension regardless of structures present in the simulation, including override structures with ``enforced=True``. It is a soft bound, meaning that the actual minimal grid size might be slightly smaller.\nmesher : GradedMesher = GradedMesher(type='GradedMesher')\n    The type of mesher to use to generate the grid automatically.\n\nExample\n-------\n>>> grid_1d = AutoGrid(min_steps_per_wvl=16, max_scale=1.4)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "AutoGrid",
          "enum": [
            "AutoGrid"
          ],
          "type": "string"
        },
        "min_steps_per_wvl": {
          "title": "Minimal number of steps per wavelength",
          "description": "Minimal number of steps per wavelength in each medium.",
          "default": 10.0,
          "minimum": 6.0,
          "type": "number"
        },
        "max_scale": {
          "title": "Maximum Grid Size Scaling",
          "description": "Sets the maximum ratio between any two consecutive grid steps.",
          "default": 1.4,
          "exclusiveMaximum": 2.0,
          "minimum": 1.2,
          "type": "number"
        },
        "dl_min": {
          "title": "Lower bound of grid size",
          "description": "Lower bound of the grid size along this dimension regardless of structures present in the simulation, including override structures with ``enforced=True``. It is a soft bound, meaning that the actual minimal grid size might be slightly smaller.",
          "default": 0,
          "minimum": 0,
          "type": "number"
        },
        "mesher": {
          "title": "Grid Construction Tool",
          "description": "The type of mesher to use to generate the grid automatically.",
          "default": {
            "type": "GradedMesher"
          },
          "allOf": [
            {
              "$ref": "#/definitions/GradedMesher"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "MeshOverrideStructure": {
      "title": "MeshOverrideStructure",
      "description": "Defines an object that is only used in the process of generating the mesh.\nA :class:`MeshOverrideStructure` is a combination of geometry :class:`Geometry`,\ngrid size along x,y,z directions, and a boolean on whether the override\nwill be enforced.\n\nParameters\n----------\ngeometry : Union[Box, Transformed, ClipOperation, GeometryGroup, Sphere, Cylinder, PolySlab, ComplexPolySlabBase, TriangleMesh]\n    Defines geometric properties of the structure.\nname : Optional[str] = None\n    Optional name for the structure.\ndl : Tuple[PositiveFloat, PositiveFloat, PositiveFloat]\n    [units = um].  Grid size along x, y, z directions.\nenforce : bool = False\n    If ``True``, enforce the grid size setup inside the structure even if the structure is inside a structure of smaller grid size. In the intersection region of multiple structures of ``enforce=True``, grid size is decided by the last added structure of ``enforce=True``.\n\nExample\n-------\n>>> from tidy3d import Box\n>>> box = Box(center=(0,0,1), size=(2, 2, 2))\n>>> struct_override = MeshOverrideStructure(geometry=box, dl=(0.1,0.2,0.3), name='override_box')",
      "type": "object",
      "properties": {
        "geometry": {
          "title": "Geometry",
          "description": "Defines geometric properties of the structure.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "Box": "#/definitions/Box",
              "Transformed": "#/definitions/Transformed",
              "ClipOperation": "#/definitions/ClipOperation",
              "GeometryGroup": "#/definitions/GeometryGroup",
              "Sphere": "#/definitions/Sphere",
              "Cylinder": "#/definitions/Cylinder",
              "PolySlab": "#/definitions/PolySlab",
              "ComplexPolySlabBase": "#/definitions/ComplexPolySlabBase",
              "TriangleMesh": "#/definitions/TriangleMesh"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/Box"
            },
            {
              "$ref": "#/definitions/Transformed"
            },
            {
              "$ref": "#/definitions/ClipOperation"
            },
            {
              "$ref": "#/definitions/GeometryGroup"
            },
            {
              "$ref": "#/definitions/Sphere"
            },
            {
              "$ref": "#/definitions/Cylinder"
            },
            {
              "$ref": "#/definitions/PolySlab"
            },
            {
              "$ref": "#/definitions/ComplexPolySlabBase"
            },
            {
              "$ref": "#/definitions/TriangleMesh"
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Optional name for the structure.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "MeshOverrideStructure",
          "enum": [
            "MeshOverrideStructure"
          ],
          "type": "string"
        },
        "dl": {
          "title": "Grid Size",
          "description": "Grid size along x, y, z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "exclusiveMinimum": 0
            },
            {
              "type": "number",
              "exclusiveMinimum": 0
            },
            {
              "type": "number",
              "exclusiveMinimum": 0
            }
          ]
        },
        "enforce": {
          "title": "Enforce grid size",
          "description": "If ``True``, enforce the grid size setup inside the structure even if the structure is inside a structure of smaller grid size. In the intersection region of multiple structures of ``enforce=True``, grid size is decided by the last added structure of ``enforce=True``.",
          "default": false,
          "type": "boolean"
        }
      },
      "required": [
        "geometry",
        "dl"
      ],
      "additionalProperties": false
    },
    "GridSpec": {
      "title": "GridSpec",
      "description": "Collective grid specification for all three dimensions.\n\nParameters\n----------\ngrid_x : Union[UniformGrid, CustomGrid, AutoGrid] = AutoGrid(type='AutoGrid', min_steps_per_wvl=10.0, max_scale=1.4, dl_min=0.0, mesher=GradedMesher(type='GradedMesher'))\n    Grid specification along x-axis\ngrid_y : Union[UniformGrid, CustomGrid, AutoGrid] = AutoGrid(type='AutoGrid', min_steps_per_wvl=10.0, max_scale=1.4, dl_min=0.0, mesher=GradedMesher(type='GradedMesher'))\n    Grid specification along y-axis\ngrid_z : Union[UniformGrid, CustomGrid, AutoGrid] = AutoGrid(type='AutoGrid', min_steps_per_wvl=10.0, max_scale=1.4, dl_min=0.0, mesher=GradedMesher(type='GradedMesher'))\n    Grid specification along z-axis\nwavelength : Optional[float] = None\n    [units = um].  Free-space wavelength for automatic nonuniform grid. It can be 'None' if there is at least one source in the simulation, in which case it is defined by the source central frequency. Note: it only takes effect when at least one of the three dimensions uses :class:`.AutoGrid`.\noverride_structures : Tuple[Annotated[Union[tidy3d.components.structure.Structure, tidy3d.components.structure.MeshOverrideStructure], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})], ...] = ()\n    A set of structures that is added on top of the simulation structures in the process of generating the grid. This can be used to refine the grid or make it coarser depending than the expected need for higher/lower resolution regions. Note: it only takes effect when at least one of the three dimensions uses :class:`.AutoGrid`.\n\nExample\n-------\n>>> uniform = UniformGrid(dl=0.1)\n>>> custom = CustomGrid(dl=[0.2, 0.2, 0.1, 0.1, 0.1, 0.2, 0.2])\n>>> auto = AutoGrid(min_steps_per_wvl=12)\n>>> grid_spec = GridSpec(grid_x=uniform, grid_y=custom, grid_z=auto, wavelength=1.5)",
      "type": "object",
      "properties": {
        "grid_x": {
          "title": "Grid specification along x-axis",
          "description": "Grid specification along x-axis",
          "default": {
            "type": "AutoGrid",
            "min_steps_per_wvl": 10.0,
            "max_scale": 1.4,
            "dl_min": 0.0,
            "mesher": {
              "type": "GradedMesher"
            }
          },
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "UniformGrid": "#/definitions/UniformGrid",
              "CustomGrid": "#/definitions/CustomGrid",
              "AutoGrid": "#/definitions/AutoGrid"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/UniformGrid"
            },
            {
              "$ref": "#/definitions/CustomGrid"
            },
            {
              "$ref": "#/definitions/AutoGrid"
            }
          ]
        },
        "grid_y": {
          "title": "Grid specification along y-axis",
          "description": "Grid specification along y-axis",
          "default": {
            "type": "AutoGrid",
            "min_steps_per_wvl": 10.0,
            "max_scale": 1.4,
            "dl_min": 0.0,
            "mesher": {
              "type": "GradedMesher"
            }
          },
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "UniformGrid": "#/definitions/UniformGrid",
              "CustomGrid": "#/definitions/CustomGrid",
              "AutoGrid": "#/definitions/AutoGrid"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/UniformGrid"
            },
            {
              "$ref": "#/definitions/CustomGrid"
            },
            {
              "$ref": "#/definitions/AutoGrid"
            }
          ]
        },
        "grid_z": {
          "title": "Grid specification along z-axis",
          "description": "Grid specification along z-axis",
          "default": {
            "type": "AutoGrid",
            "min_steps_per_wvl": 10.0,
            "max_scale": 1.4,
            "dl_min": 0.0,
            "mesher": {
              "type": "GradedMesher"
            }
          },
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "UniformGrid": "#/definitions/UniformGrid",
              "CustomGrid": "#/definitions/CustomGrid",
              "AutoGrid": "#/definitions/AutoGrid"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/UniformGrid"
            },
            {
              "$ref": "#/definitions/CustomGrid"
            },
            {
              "$ref": "#/definitions/AutoGrid"
            }
          ]
        },
        "wavelength": {
          "title": "Free-space wavelength",
          "description": "Free-space wavelength for automatic nonuniform grid. It can be 'None' if there is at least one source in the simulation, in which case it is defined by the source central frequency. Note: it only takes effect when at least one of the three dimensions uses :class:`.AutoGrid`.",
          "units": "um",
          "type": "number"
        },
        "override_structures": {
          "title": "Grid specification override structures",
          "description": "A set of structures that is added on top of the simulation structures in the process of generating the grid. This can be used to refine the grid or make it coarser depending than the expected need for higher/lower resolution regions. Note: it only takes effect when at least one of the three dimensions uses :class:`.AutoGrid`.",
          "default": [],
          "type": "array",
          "items": {
            "discriminator": {
              "propertyName": "type",
              "mapping": {
                "Structure": "#/definitions/Structure",
                "MeshOverrideStructure": "#/definitions/MeshOverrideStructure"
              }
            },
            "oneOf": [
              {
                "$ref": "#/definitions/Structure"
              },
              {
                "$ref": "#/definitions/MeshOverrideStructure"
              }
            ]
          }
        },
        "type": {
          "title": "Type",
          "default": "GridSpec",
          "enum": [
            "GridSpec"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    }
  }
}
{
  "title": "Simulation",
  "description": "Contains all information about Tidy3d simulation.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nrun_time : PositiveFloat\n    [units = sec].  Total electromagnetic evolution time in seconds. Note: If simulation 'shutoff' is specified, simulation will terminate early when shutoff condition met. \nmedium : Union[Medium, CustomMedium, AnisotropicMedium, PECMedium, PoleResidue, Sellmeier, Lorentz, Debye, Drude] = Medium(name=None, frequency_range=None, type='Medium', permittivity=1.0, conductivity=0.0)\n    Background medium of simulation, defaults to vacuum if not specified.\nsymmetry : Tuple[Literal[0, -1, 1], Literal[0, -1, 1], Literal[0, -1, 1]] = (0, 0, 0)\n    Tuple of integers defining reflection symmetry across a plane bisecting the simulation domain normal to the x-, y-, and z-axis at the simulation center of each axis, respectvely. Each element can be ``0`` (no symmetry), ``1`` (even, i.e. 'PMC' symmetry) or ``-1`` (odd, i.e. 'PEC' symmetry). Note that the vectorial nature of the fields must be taken into account to correctly determine the symmetry value.\nstructures : Tuple[Structure, ...] = ()\n    Tuple of structures present in simulation. Note: Structures defined later in this list override the simulation material properties in regions of spatial overlap.\nsources : Tuple[Annotated[Union[tidy3d.components.source.UniformCurrentSource, tidy3d.components.source.PointDipole, tidy3d.components.source.GaussianBeam, tidy3d.components.source.AstigmaticGaussianBeam, tidy3d.components.source.ModeSource, tidy3d.components.source.PlaneWave, tidy3d.components.source.CustomFieldSource], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})], ...] = ()\n    Tuple of electric current sources injecting fields into the simulation.\nboundary_spec : Optional[BoundarySpec] = None\n    Specification of boundary conditions along each dimension. If ``None``, periodic boundary conditions are applied on all sides. Default will change to PML in 2.0 so explicitly setting the boundaries is recommended.\nmonitors : Tuple[Annotated[Union[tidy3d.components.monitor.FieldMonitor, tidy3d.components.monitor.FieldTimeMonitor, tidy3d.components.monitor.PermittivityMonitor, tidy3d.components.monitor.FluxMonitor, tidy3d.components.monitor.FluxTimeMonitor, tidy3d.components.monitor.ModeMonitor, tidy3d.components.monitor.ModeSolverMonitor, tidy3d.components.monitor.FieldProjectionAngleMonitor, tidy3d.components.monitor.FieldProjectionCartesianMonitor, tidy3d.components.monitor.FieldProjectionKSpaceMonitor, tidy3d.components.monitor.DiffractionMonitor], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})], ...] = ()\n    Tuple of monitors in the simulation. Note: monitor names are used to access data after simulation is run.\ngrid_spec : GridSpec = GridSpec(grid_x=AutoGrid(type='AutoGrid',, min_steps_per_wvl=10.0,, max_scale=1.4,, dl_min=0.0,, mesher=GradedMesher(type='GradedMesher')), grid_y=AutoGrid(type='AutoGrid',, min_steps_per_wvl=10.0,, max_scale=1.4,, dl_min=0.0,, mesher=GradedMesher(type='GradedMesher')), grid_z=AutoGrid(type='AutoGrid',, min_steps_per_wvl=10.0,, max_scale=1.4,, dl_min=0.0,, mesher=GradedMesher(type='GradedMesher')), wavelength=None, override_structures=(), type='GridSpec')\n    Specifications for the simulation grid along each of the three directions.\nshutoff : NonNegativeFloat = 1e-05\n    Ratio of the instantaneous integrated E-field intensity to the maximum value at which the simulation will automatically terminate time stepping. Used to prevent extraneous run time of simulations with fully decayed fields. Set to ``0`` to disable this feature.\nsubpixel : bool = True\n    If ``True``, uses subpixel averaging of the permittivity based on structure definition, resulting in much higher accuracy for a given grid size.\nnormalize_index : Optional[NonNegativeInt] = 0\n    Index of the source in the tuple of sources whose spectrum will be used to normalize the frequency-dependent data. If ``None``, the raw field data is returned unnormalized.\ncourant : ConstrainedFloatValue = 0.99\n    Courant stability factor, controls time step to spatial step ratio. Lower values lead to more stable simulations for dispersive materials, but result in longer simulation times. This factor is normalized to no larger than 1 when CFL stability condition is met in 3D.\nversion : str = 1.9.0\n    String specifying the front end version number.\n\nExample\n-------\n>>> from tidy3d import Sphere, Cylinder, PolySlab\n>>> from tidy3d import UniformCurrentSource, GaussianPulse\n>>> from tidy3d import FieldMonitor, FluxMonitor\n>>> from tidy3d import GridSpec, AutoGrid\n>>> from tidy3d import BoundarySpec, Boundary\n>>> sim = Simulation(\n...     size=(2.0, 2.0, 2.0),\n...     grid_spec=GridSpec(\n...         grid_x = AutoGrid(min_steps_per_wvl = 20),\n...         grid_y = AutoGrid(min_steps_per_wvl = 20),\n...         grid_z = AutoGrid(min_steps_per_wvl = 20)\n...     ),\n...     run_time=40e-11,\n...     structures=[\n...         Structure(\n...             geometry=Box(size=(1, 1, 1), center=(-1, 0, 0)),\n...             medium=Medium(permittivity=2.0),\n...         ),\n...     ],\n...     sources=[\n...         UniformCurrentSource(\n...             size=(0, 0, 0),\n...             center=(0, 0.5, 0),\n...             polarization=\"Hx\",\n...             source_time=GaussianPulse(\n...                 freq0=2e14,\n...                 fwidth=4e13,\n...             ),\n...         )\n...     ],\n...     monitors=[\n...         FieldMonitor(size=(0, 0, 0), center=(0, 0, 0), freqs=[1.5e14, 2e14], name='point'),\n...         FluxMonitor(size=(1, 1, 0), center=(0, 0, 0), freqs=[2e14, 2.5e14], name='flux'),\n...     ],\n...     symmetry=(0, 0, 0),\n...     boundary_spec=BoundarySpec(\n...         x = Boundary.pml(num_layers=20),\n...         y = Boundary.pml(num_layers=30),\n...         z = Boundary.periodic(),\n...     ),\n...     shutoff=1e-6,\n...     courant=0.8,\n...     subpixel=False,\n... )",
  "type": "object",
  "properties": {
    "type": {
      "title": "Type",
      "default": "Simulation",
      "enum": [
        "Simulation"
      ],
      "type": "string"
    },
    "center": {
      "title": "Center",
      "description": "Center of object in x, y, and z.",
      "default": [
        0.0,
        0.0,
        0.0
      ],
      "units": "um",
      "type": "array",
      "minItems": 3,
      "maxItems": 3,
      "items": [
        {
          "type": "number"
        },
        {
          "type": "number"
        },
        {
          "type": "number"
        }
      ]
    },
    "size": {
      "title": "Size",
      "description": "Size in x, y, and z directions.",
      "units": "um",
      "type": "array",
      "minItems": 3,
      "maxItems": 3,
      "items": [
        {
          "type": "number",
          "minimum": 0
        },
        {
          "type": "number",
          "minimum": 0
        },
        {
          "type": "number",
          "minimum": 0
        }
      ]
    },
    "run_time": {
      "title": "Run Time",
      "description": "Total electromagnetic evolution time in seconds. Note: If simulation 'shutoff' is specified, simulation will terminate early when shutoff condition met. ",
      "units": "sec",
      "exclusiveMinimum": 0,
      "type": "number"
    },
    "medium": {
      "title": "Background Medium",
      "description": "Background medium of simulation, defaults to vacuum if not specified.",
      "default": {
        "name": null,
        "frequency_range": null,
        "type": "Medium",
        "permittivity": 1.0,
        "conductivity": 0.0
      },
      "anyOf": [
        {
          "$ref": "#/definitions/Medium"
        },
        {
          "$ref": "#/definitions/CustomMedium"
        },
        {
          "$ref": "#/definitions/AnisotropicMedium"
        },
        {
          "$ref": "#/definitions/PECMedium"
        },
        {
          "$ref": "#/definitions/PoleResidue"
        },
        {
          "$ref": "#/definitions/Sellmeier"
        },
        {
          "$ref": "#/definitions/Lorentz"
        },
        {
          "$ref": "#/definitions/Debye"
        },
        {
          "$ref": "#/definitions/Drude"
        }
      ]
    },
    "symmetry": {
      "title": "Symmetries",
      "description": "Tuple of integers defining reflection symmetry across a plane bisecting the simulation domain normal to the x-, y-, and z-axis at the simulation center of each axis, respectvely. Each element can be ``0`` (no symmetry), ``1`` (even, i.e. 'PMC' symmetry) or ``-1`` (odd, i.e. 'PEC' symmetry). Note that the vectorial nature of the fields must be taken into account to correctly determine the symmetry value.",
      "default": [
        0,
        0,
        0
      ],
      "type": "array",
      "minItems": 3,
      "maxItems": 3,
      "items": [
        {
          "enum": [
            0,
            -1,
            1
          ],
          "type": "integer"
        },
        {
          "enum": [
            0,
            -1,
            1
          ],
          "type": "integer"
        },
        {
          "enum": [
            0,
            -1,
            1
          ],
          "type": "integer"
        }
      ]
    },
    "structures": {
      "title": "Structures",
      "description": "Tuple of structures present in simulation. Note: Structures defined later in this list override the simulation material properties in regions of spatial overlap.",
      "default": [],
      "type": "array",
      "items": {
        "$ref": "#/definitions/Structure"
      }
    },
    "sources": {
      "title": "Sources",
      "description": "Tuple of electric current sources injecting fields into the simulation.",
      "default": [],
      "type": "array",
      "items": {
        "discriminator": {
          "propertyName": "type",
          "mapping": {
            "UniformCurrentSource": "#/definitions/UniformCurrentSource",
            "PointDipole": "#/definitions/PointDipole",
            "GaussianBeam": "#/definitions/GaussianBeam",
            "AstigmaticGaussianBeam": "#/definitions/AstigmaticGaussianBeam",
            "ModeSource": "#/definitions/ModeSource",
            "PlaneWave": "#/definitions/PlaneWave",
            "CustomFieldSource": "#/definitions/CustomFieldSource"
          }
        },
        "oneOf": [
          {
            "$ref": "#/definitions/UniformCurrentSource"
          },
          {
            "$ref": "#/definitions/PointDipole"
          },
          {
            "$ref": "#/definitions/GaussianBeam"
          },
          {
            "$ref": "#/definitions/AstigmaticGaussianBeam"
          },
          {
            "$ref": "#/definitions/ModeSource"
          },
          {
            "$ref": "#/definitions/PlaneWave"
          },
          {
            "$ref": "#/definitions/CustomFieldSource"
          }
        ]
      }
    },
    "boundary_spec": {
      "title": "Boundaries",
      "description": "Specification of boundary conditions along each dimension. If ``None``, periodic boundary conditions are applied on all sides. Default will change to PML in 2.0 so explicitly setting the boundaries is recommended.",
      "allOf": [
        {
          "$ref": "#/definitions/BoundarySpec"
        }
      ]
    },
    "monitors": {
      "title": "Monitors",
      "description": "Tuple of monitors in the simulation. Note: monitor names are used to access data after simulation is run.",
      "default": [],
      "type": "array",
      "items": {
        "discriminator": {
          "propertyName": "type",
          "mapping": {
            "FieldMonitor": "#/definitions/FieldMonitor",
            "FieldTimeMonitor": "#/definitions/FieldTimeMonitor",
            "PermittivityMonitor": "#/definitions/PermittivityMonitor",
            "FluxMonitor": "#/definitions/FluxMonitor",
            "FluxTimeMonitor": "#/definitions/FluxTimeMonitor",
            "ModeMonitor": "#/definitions/ModeMonitor",
            "ModeSolverMonitor": "#/definitions/ModeSolverMonitor",
            "FieldProjectionAngleMonitor": "#/definitions/FieldProjectionAngleMonitor",
            "FieldProjectionCartesianMonitor": "#/definitions/FieldProjectionCartesianMonitor",
            "FieldProjectionKSpaceMonitor": "#/definitions/FieldProjectionKSpaceMonitor",
            "DiffractionMonitor": "#/definitions/DiffractionMonitor"
          }
        },
        "oneOf": [
          {
            "$ref": "#/definitions/FieldMonitor"
          },
          {
            "$ref": "#/definitions/FieldTimeMonitor"
          },
          {
            "$ref": "#/definitions/PermittivityMonitor"
          },
          {
            "$ref": "#/definitions/FluxMonitor"
          },
          {
            "$ref": "#/definitions/FluxTimeMonitor"
          },
          {
            "$ref": "#/definitions/ModeMonitor"
          },
          {
            "$ref": "#/definitions/ModeSolverMonitor"
          },
          {
            "$ref": "#/definitions/FieldProjectionAngleMonitor"
          },
          {
            "$ref": "#/definitions/FieldProjectionCartesianMonitor"
          },
          {
            "$ref": "#/definitions/FieldProjectionKSpaceMonitor"
          },
          {
            "$ref": "#/definitions/DiffractionMonitor"
          }
        ]
      }
    },
    "grid_spec": {
      "title": "Grid Specification",
      "description": "Specifications for the simulation grid along each of the three directions.",
      "default": {
        "grid_x": {
          "type": "AutoGrid",
          "min_steps_per_wvl": 10.0,
          "max_scale": 1.4,
          "dl_min": 0.0,
          "mesher": {
            "type": "GradedMesher"
          }
        },
        "grid_y": {
          "type": "AutoGrid",
          "min_steps_per_wvl": 10.0,
          "max_scale": 1.4,
          "dl_min": 0.0,
          "mesher": {
            "type": "GradedMesher"
          }
        },
        "grid_z": {
          "type": "AutoGrid",
          "min_steps_per_wvl": 10.0,
          "max_scale": 1.4,
          "dl_min": 0.0,
          "mesher": {
            "type": "GradedMesher"
          }
        },
        "wavelength": null,
        "override_structures": [],
        "type": "GridSpec"
      },
      "allOf": [
        {
          "$ref": "#/definitions/GridSpec"
        }
      ]
    },
    "shutoff": {
      "title": "Shutoff Condition",
      "description": "Ratio of the instantaneous integrated E-field intensity to the maximum value at which the simulation will automatically terminate time stepping. Used to prevent extraneous run time of simulations with fully decayed fields. Set to ``0`` to disable this feature.",
      "default": 1e-05,
      "minimum": 0,
      "type": "number"
    },
    "subpixel": {
      "title": "Subpixel Averaging",
      "description": "If ``True``, uses subpixel averaging of the permittivity based on structure definition, resulting in much higher accuracy for a given grid size.",
      "default": true,
      "type": "boolean"
    },
    "normalize_index": {
      "title": "Normalization index",
      "description": "Index of the source in the tuple of sources whose spectrum will be used to normalize the frequency-dependent data. If ``None``, the raw field data is returned unnormalized.",
      "default": 0,
      "minimum": 0,
      "type": "integer"
    },
    "courant": {
      "title": "Courant Factor",
      "description": "Courant stability factor, controls time step to spatial step ratio. Lower values lead to more stable simulations for dispersive materials, but result in longer simulation times. This factor is normalized to no larger than 1 when CFL stability condition is met in 3D.",
      "default": 0.99,
      "exclusiveMinimum": 0.0,
      "maximum": 1.0,
      "type": "number"
    },
    "version": {
      "title": "Version",
      "description": "String specifying the front end version number.",
      "default": "1.9.0",
      "type": "string"
    }
  },
  "required": [
    "size",
    "run_time"
  ],
  "additionalProperties": false,
  "definitions": {
    "Medium": {
      "title": "Medium",
      "description": "Dispersionless medium.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\npermittivity : ConstrainedFloatValue = 1.0\n    [units = None (relative permittivity)].  Relative permittivity.\nconductivity : ConstrainedFloatValue = 0.0\n    [units = S/um].  Electric conductivity.  Defined such that the imaginary part of the complex permittivity at angular frequency omega is given by conductivity/omega.\n\nExample\n-------\n>>> dielectric = Medium(permittivity=4.0, name='my_medium')\n>>> eps = dielectric.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Medium",
          "enum": [
            "Medium"
          ],
          "type": "string"
        },
        "permittivity": {
          "title": "Permittivity",
          "description": "Relative permittivity.",
          "default": 1.0,
          "minimum": 1.0,
          "units": "None (relative permittivity)",
          "type": "number"
        },
        "conductivity": {
          "title": "Conductivity",
          "description": "Electric conductivity.  Defined such that the imaginary part of the complex permittivity at angular frequency omega is given by conductivity/omega.",
          "default": 0.0,
          "minimum": 0.0,
          "units": "S/um",
          "type": "number"
        }
      },
      "additionalProperties": false
    },
    "PermittivityDataset": {
      "title": "PermittivityDataset",
      "description": "Dataset storing the diagonal components of the permittivity tensor.\n\nParameters\n----------\neps_xx : ScalarFieldDataArray\n    Spatial distribution of the xx-component of the relative permittivity.\neps_yy : ScalarFieldDataArray\n    Spatial distribution of the yy-component of the relative permittivity.\neps_zz : ScalarFieldDataArray\n    Spatial distribution of the zz-component of the relative permittivity.\n\nExample\n-------\n>>> x = [-1,1]\n>>> y = [-2,0,2]\n>>> z = [-3,-1,1,3]\n>>> f = [2e14, 3e14]\n>>> coords = dict(x=x, y=y, z=z, f=f)\n>>> sclr_fld = ScalarFieldDataArray((1+1j) * np.random.random((2,3,4,2)), coords=coords)\n>>> data = PermittivityDataset(eps_xx=sclr_fld, eps_yy=sclr_fld, eps_zz=sclr_fld)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "PermittivityDataset",
          "enum": [
            "PermittivityDataset"
          ],
          "type": "string"
        },
        "eps_xx": {
          "title": "DataArray",
          "description": "Spatial distribution of the xx-component of the relative permittivity.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "eps_yy": {
          "title": "DataArray",
          "description": "Spatial distribution of the yy-component of the relative permittivity.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "eps_zz": {
          "title": "DataArray",
          "description": "Spatial distribution of the zz-component of the relative permittivity.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        }
      },
      "required": [
        "eps_xx",
        "eps_yy",
        "eps_zz"
      ],
      "additionalProperties": false
    },
    "CustomMedium": {
      "title": "CustomMedium",
      "description": ":class:`.Medium` with user-supplied permittivity distribution.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\neps_dataset : PermittivityDataset\n    User-supplied dataset containing complex-valued permittivity as a function of space. Permittivity distribution over the Yee-grid will be interpolated based on ``interp_method``.\ninterp_method : Literal['nearest', 'linear'] = nearest\n    Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.\n\nExample\n-------\n>>> Nx, Ny, Nz = 10, 9, 8\n>>> X = np.linspace(-1, 1, Nx)\n>>> Y = np.linspace(-1, 1, Ny)\n>>> Z = np.linspace(-1, 1, Nz)\n>>> freqs = [2e14]\n>>> data = np.ones((Nx, Ny, Nz, 1))\n>>> eps_diagonal_data = ScalarFieldDataArray(data, coords=dict(x=X, y=Y, z=Z, f=freqs))\n>>> eps_components = {f\"eps_{d}{d}\": eps_diagonal_data for d in \"xyz\"}\n>>> eps_dataset = PermittivityDataset(**eps_components)\n>>> dielectric = CustomMedium(eps_dataset=eps_dataset, name='my_medium')\n>>> eps = dielectric.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "CustomMedium",
          "enum": [
            "CustomMedium"
          ],
          "type": "string"
        },
        "eps_dataset": {
          "title": "Permittivity Dataset",
          "description": "User-supplied dataset containing complex-valued permittivity as a function of space. Permittivity distribution over the Yee-grid will be interpolated based on ``interp_method``.",
          "allOf": [
            {
              "$ref": "#/definitions/PermittivityDataset"
            }
          ]
        },
        "interp_method": {
          "title": "Interpolation method",
          "description": "Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.",
          "default": "nearest",
          "enum": [
            "nearest",
            "linear"
          ],
          "type": "string"
        }
      },
      "required": [
        "eps_dataset"
      ],
      "additionalProperties": false
    },
    "ComplexNumber": {
      "title": "ComplexNumber",
      "description": "Complex number with a well defined schema.",
      "type": "object",
      "properties": {
        "real": {
          "title": "Real",
          "type": "number"
        },
        "imag": {
          "title": "Imag",
          "type": "number"
        }
      },
      "required": [
        "real",
        "imag"
      ]
    },
    "PoleResidue": {
      "title": "PoleResidue",
      "description": "A dispersive medium described by the pole-residue pair model.\nThe frequency-dependence of the complex-valued permittivity is described by:\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\neps_inf : float = 1.0\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\npoles : Tuple[Tuple[Union[tidy3d.components.types.tidycomplex, tidy3d.components.types.ComplexNumber], Union[tidy3d.components.types.tidycomplex, tidy3d.components.types.ComplexNumber]], ...] = ()\n    [units = (rad/sec, rad/sec)].  Tuple of complex-valued (:math:`a_i, c_i`) poles for the model.\n\nNote\n----\n.. math::\n\n    \\epsilon(\\omega) = \\epsilon_\\infty - \\sum_i\n    \\left[\\frac{c_i}{j \\omega + a_i} +\n    \\frac{c_i^*}{j \\omega + a_i^*}\\right]\n\nExample\n-------\n>>> pole_res = PoleResidue(eps_inf=2.0, poles=[((1+2j), (3+4j)), ((5+6j), (7+8j))])\n>>> eps = pole_res.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "PoleResidue",
          "enum": [
            "PoleResidue"
          ],
          "type": "string"
        },
        "eps_inf": {
          "title": "Epsilon at Infinity",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "default": 1.0,
          "units": "None (relative permittivity)",
          "type": "number"
        },
        "poles": {
          "title": "Poles",
          "description": "Tuple of complex-valued (:math:`a_i, c_i`) poles for the model.",
          "default": [],
          "units": [
            "rad/sec",
            "rad/sec"
          ],
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "anyOf": [
                  {
                    "title": "ComplexNumber",
                    "description": "Complex number with a well defined schema.",
                    "type": "object",
                    "properties": {
                      "real": {
                        "title": "Real",
                        "type": "number"
                      },
                      "imag": {
                        "title": "Imag",
                        "type": "number"
                      }
                    },
                    "required": [
                      "real",
                      "imag"
                    ]
                  },
                  {
                    "$ref": "#/definitions/ComplexNumber"
                  }
                ]
              },
              {
                "anyOf": [
                  {
                    "title": "ComplexNumber",
                    "description": "Complex number with a well defined schema.",
                    "type": "object",
                    "properties": {
                      "real": {
                        "title": "Real",
                        "type": "number"
                      },
                      "imag": {
                        "title": "Imag",
                        "type": "number"
                      }
                    },
                    "required": [
                      "real",
                      "imag"
                    ]
                  },
                  {
                    "$ref": "#/definitions/ComplexNumber"
                  }
                ]
              }
            ]
          }
        }
      },
      "additionalProperties": false
    },
    "Sellmeier": {
      "title": "Sellmeier",
      "description": "A dispersive medium described by the Sellmeier model.\nThe frequency-dependence of the refractive index is described by:\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\ncoeffs : Tuple[Tuple[float, pydantic.types.PositiveFloat], ...]\n    [units = (None, um^2)].  List of Sellmeier (:math:`B_i, C_i`) coefficients.\n\nNote\n----\n.. math::\n\n    n(\\lambda)^2 = 1 + \\sum_i \\frac{B_i \\lambda^2}{\\lambda^2 - C_i}\n\nExample\n-------\n>>> sellmeier_medium = Sellmeier(coeffs=[(1,2), (3,4)])\n>>> eps = sellmeier_medium.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Sellmeier",
          "enum": [
            "Sellmeier"
          ],
          "type": "string"
        },
        "coeffs": {
          "title": "Coefficients",
          "description": "List of Sellmeier (:math:`B_i, C_i`) coefficients.",
          "units": [
            null,
            "um^2"
          ],
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "type": "number"
              },
              {
                "type": "number",
                "exclusiveMinimum": 0
              }
            ]
          }
        }
      },
      "required": [
        "coeffs"
      ],
      "additionalProperties": false
    },
    "Lorentz": {
      "title": "Lorentz",
      "description": "A dispersive medium described by the Lorentz model.\nThe frequency-dependence of the complex-valued permittivity is described by:\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\neps_inf : float = 1.0\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\ncoeffs : Tuple[Tuple[float, float, float], ...]\n    [units = (None (relative permittivity), Hz, Hz)].  List of (:math:`\\Delta\\epsilon_i, f_i, \\delta_i`) values for model.\n\nNote\n----\n.. math::\n\n    \\epsilon(f) = \\epsilon_\\infty + \\sum_i\n    \\frac{\\Delta\\epsilon_i f_i^2}{f_i^2 - 2jf\\delta_i - f^2}\n\nExample\n-------\n>>> lorentz_medium = Lorentz(eps_inf=2.0, coeffs=[(1,2,3), (4,5,6)])\n>>> eps = lorentz_medium.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Lorentz",
          "enum": [
            "Lorentz"
          ],
          "type": "string"
        },
        "eps_inf": {
          "title": "Epsilon at Infinity",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "default": 1.0,
          "units": "None (relative permittivity)",
          "type": "number"
        },
        "coeffs": {
          "title": "Coefficients",
          "description": "List of (:math:`\\Delta\\epsilon_i, f_i, \\delta_i`) values for model.",
          "units": [
            "None (relative permittivity)",
            "Hz",
            "Hz"
          ],
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 3,
            "maxItems": 3,
            "items": [
              {
                "type": "number"
              },
              {
                "type": "number"
              },
              {
                "type": "number"
              }
            ]
          }
        }
      },
      "required": [
        "coeffs"
      ],
      "additionalProperties": false
    },
    "Debye": {
      "title": "Debye",
      "description": "A dispersive medium described by the Debye model.\nThe frequency-dependence of the complex-valued permittivity is described by:\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\neps_inf : float = 1.0\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\ncoeffs : Tuple[Tuple[float, pydantic.types.PositiveFloat], ...]\n    [units = (None (relative permittivity), sec)].  List of (:math:`\\Delta\\epsilon_i, \\tau_i`) values for model.\n\nNote\n----\n.. math::\n\n    \\epsilon(f) = \\epsilon_\\infty + \\sum_i\n    \\frac{\\Delta\\epsilon_i}{1 - jf\\tau_i}\n\nExample\n-------\n>>> debye_medium = Debye(eps_inf=2.0, coeffs=[(1,2),(3,4)])\n>>> eps = debye_medium.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Debye",
          "enum": [
            "Debye"
          ],
          "type": "string"
        },
        "eps_inf": {
          "title": "Epsilon at Infinity",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "default": 1.0,
          "units": "None (relative permittivity)",
          "type": "number"
        },
        "coeffs": {
          "title": "Coefficients",
          "description": "List of (:math:`\\Delta\\epsilon_i, \\tau_i`) values for model.",
          "units": [
            "None (relative permittivity)",
            "sec"
          ],
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "type": "number"
              },
              {
                "type": "number",
                "exclusiveMinimum": 0
              }
            ]
          }
        }
      },
      "required": [
        "coeffs"
      ],
      "additionalProperties": false
    },
    "Drude": {
      "title": "Drude",
      "description": "A dispersive medium described by the Drude model.\nThe frequency-dependence of the complex-valued permittivity is described by:\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\neps_inf : float = 1.0\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\ncoeffs : Tuple[Tuple[float, pydantic.types.PositiveFloat], ...]\n    [units = (Hz, Hz)].  List of (:math:`f_i, \\delta_i`) values for model.\n\nNote\n----\n.. math::\n\n    \\epsilon(f) = \\epsilon_\\infty - \\sum_i\n    \\frac{ f_i^2}{f^2 + jf\\delta_i}\n\nExample\n-------\n>>> drude_medium = Drude(eps_inf=2.0, coeffs=[(1,2), (3,4)])\n>>> eps = drude_medium.eps_model(200e12)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Drude",
          "enum": [
            "Drude"
          ],
          "type": "string"
        },
        "eps_inf": {
          "title": "Epsilon at Infinity",
          "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
          "default": 1.0,
          "units": "None (relative permittivity)",
          "type": "number"
        },
        "coeffs": {
          "title": "Coefficients",
          "description": "List of (:math:`f_i, \\delta_i`) values for model.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": [
              {
                "type": "number"
              },
              {
                "type": "number",
                "exclusiveMinimum": 0
              }
            ]
          }
        }
      },
      "required": [
        "coeffs"
      ],
      "additionalProperties": false
    },
    "AnisotropicMedium": {
      "title": "AnisotropicMedium",
      "description": "Diagonally anisotropic medium.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nxx : Union[Medium, PoleResidue, Sellmeier, Lorentz, Debye, Drude]\n    Medium describing the xx-component of the diagonal permittivity tensor.\nyy : Union[Medium, PoleResidue, Sellmeier, Lorentz, Debye, Drude]\n    Medium describing the yy-component of the diagonal permittivity tensor.\nzz : Union[Medium, PoleResidue, Sellmeier, Lorentz, Debye, Drude]\n    Medium describing the zz-component of the diagonal permittivity tensor.\n\nNote\n----\nOnly diagonal anisotropy is currently supported.\n\nExample\n-------\n>>> medium_xx = Medium(permittivity=4.0)\n>>> medium_yy = Medium(permittivity=4.1)\n>>> medium_zz = Medium(permittivity=3.9)\n>>> anisotropic_dielectric = AnisotropicMedium(xx=medium_xx, yy=medium_yy, zz=medium_zz)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "AnisotropicMedium",
          "enum": [
            "AnisotropicMedium"
          ],
          "type": "string"
        },
        "xx": {
          "title": "XX Component",
          "description": "Medium describing the xx-component of the diagonal permittivity tensor.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "Medium": "#/definitions/Medium",
              "PoleResidue": "#/definitions/PoleResidue",
              "Sellmeier": "#/definitions/Sellmeier",
              "Lorentz": "#/definitions/Lorentz",
              "Debye": "#/definitions/Debye",
              "Drude": "#/definitions/Drude"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/Medium"
            },
            {
              "$ref": "#/definitions/PoleResidue"
            },
            {
              "$ref": "#/definitions/Sellmeier"
            },
            {
              "$ref": "#/definitions/Lorentz"
            },
            {
              "$ref": "#/definitions/Debye"
            },
            {
              "$ref": "#/definitions/Drude"
            }
          ]
        },
        "yy": {
          "title": "YY Component",
          "description": "Medium describing the yy-component of the diagonal permittivity tensor.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "Medium": "#/definitions/Medium",
              "PoleResidue": "#/definitions/PoleResidue",
              "Sellmeier": "#/definitions/Sellmeier",
              "Lorentz": "#/definitions/Lorentz",
              "Debye": "#/definitions/Debye",
              "Drude": "#/definitions/Drude"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/Medium"
            },
            {
              "$ref": "#/definitions/PoleResidue"
            },
            {
              "$ref": "#/definitions/Sellmeier"
            },
            {
              "$ref": "#/definitions/Lorentz"
            },
            {
              "$ref": "#/definitions/Debye"
            },
            {
              "$ref": "#/definitions/Drude"
            }
          ]
        },
        "zz": {
          "title": "ZZ Component",
          "description": "Medium describing the zz-component of the diagonal permittivity tensor.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "Medium": "#/definitions/Medium",
              "PoleResidue": "#/definitions/PoleResidue",
              "Sellmeier": "#/definitions/Sellmeier",
              "Lorentz": "#/definitions/Lorentz",
              "Debye": "#/definitions/Debye",
              "Drude": "#/definitions/Drude"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/Medium"
            },
            {
              "$ref": "#/definitions/PoleResidue"
            },
            {
              "$ref": "#/definitions/Sellmeier"
            },
            {
              "$ref": "#/definitions/Lorentz"
            },
            {
              "$ref": "#/definitions/Debye"
            },
            {
              "$ref": "#/definitions/Drude"
            }
          ]
        }
      },
      "required": [
        "xx",
        "yy",
        "zz"
      ],
      "additionalProperties": false
    },
    "PECMedium": {
      "title": "PECMedium",
      "description": "Perfect electrical conductor class.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\n\nNote\n----\nTo avoid confusion from duplicate PECs, should import ``tidy3d.PEC`` instance directly.",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for medium.",
          "type": "string"
        },
        "frequency_range": {
          "title": "Frequency Range",
          "description": "Optional range of validity for the medium.",
          "units": [
            "Hz",
            "Hz"
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "PECMedium",
          "enum": [
            "PECMedium"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "Box": {
      "title": "Box",
      "description": "Rectangular prism.\n   Also base class for :class:`Simulation`, :class:`Monitor`, and :class:`Source`.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\n\nExample\n-------\n>>> b = Box(center=(1,2,3), size=(2,2,2))",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "Box",
          "enum": [
            "Box"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        }
      },
      "required": [
        "size"
      ],
      "additionalProperties": false
    },
    "Sphere": {
      "title": "Sphere",
      "description": "Spherical geometry.\n\nParameters\n----------\nradius : NonNegativeFloat\n    [units = um].  Radius of geometry.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\n\nExample\n-------\n>>> b = Sphere(center=(1,2,3), radius=2)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "Sphere",
          "enum": [
            "Sphere"
          ],
          "type": "string"
        },
        "radius": {
          "title": "Radius",
          "description": "Radius of geometry.",
          "units": "um",
          "minimum": 0,
          "type": "number"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        }
      },
      "required": [
        "radius"
      ],
      "additionalProperties": false
    },
    "Cylinder": {
      "title": "Cylinder",
      "description": "Cylindrical geometry with optional sidewall angle along axis\ndirection. When ``sidewall_angle`` is nonzero, the shape is a\nconical frustum or a cone.\n\nParameters\n----------\naxis : Literal[0, 1, 2] = 2\n    Specifies dimension of the planar axis (0,1,2) -> (x,y,z).\nsidewall_angle : ConstrainedFloatValue = 0.0\n    [units = rad].  Angle of the sidewall. ``sidewall_angle=0`` (default) specifies a vertical wall; ``0<sidewall_angle<np.pi/2`` specifies a shrinking cross section along the ``axis`` direction; and ``-np.pi/2<sidewall_angle<0`` specifies an expanding cross section along the ``axis`` direction.\nreference_plane : Literal['bottom', 'middle', 'top'] = bottom\n    The position of the plane where the supplied cross section are defined. The plane is perpendicular to the ``axis``. The plane is located at the ``bottom``, ``middle``, or ``top`` of the geometry with respect to the axis. E.g. if ``axis=1``, ``bottom`` refers to the negative side of the y-axis, and ``top`` refers to the positive side of the y-axis.\nradius : NonNegativeFloat\n    [units = um].  Radius of geometry.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nlength : NonNegativeFloat\n    [units = um].  Defines thickness of cylinder along axis dimension.\n\nExample\n-------\n>>> c = Cylinder(center=(1,2,3), radius=2, length=5, axis=2)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "Cylinder",
          "enum": [
            "Cylinder"
          ],
          "type": "string"
        },
        "axis": {
          "title": "Axis",
          "description": "Specifies dimension of the planar axis (0,1,2) -> (x,y,z).",
          "default": 2,
          "enum": [
            0,
            1,
            2
          ],
          "type": "integer"
        },
        "sidewall_angle": {
          "title": "Sidewall angle",
          "description": "Angle of the sidewall. ``sidewall_angle=0`` (default) specifies a vertical wall; ``0<sidewall_angle<np.pi/2`` specifies a shrinking cross section along the ``axis`` direction; and ``-np.pi/2<sidewall_angle<0`` specifies an expanding cross section along the ``axis`` direction.",
          "default": 0.0,
          "exclusiveMinimum": -1.5707963267948966,
          "exclusiveMaximum": 1.5707963267948966,
          "units": "rad",
          "type": "number"
        },
        "reference_plane": {
          "title": "Reference plane for cross section",
          "description": "The position of the plane where the supplied cross section are defined. The plane is perpendicular to the ``axis``. The plane is located at the ``bottom``, ``middle``, or ``top`` of the geometry with respect to the axis. E.g. if ``axis=1``, ``bottom`` refers to the negative side of the y-axis, and ``top`` refers to the positive side of the y-axis.",
          "default": "bottom",
          "enum": [
            "bottom",
            "middle",
            "top"
          ],
          "type": "string"
        },
        "radius": {
          "title": "Radius",
          "description": "Radius of geometry.",
          "units": "um",
          "minimum": 0,
          "type": "number"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "length": {
          "title": "Length",
          "description": "Defines thickness of cylinder along axis dimension.",
          "units": "um",
          "minimum": 0,
          "type": "number"
        }
      },
      "required": [
        "radius",
        "length"
      ],
      "additionalProperties": false
    },
    "PolySlab": {
      "title": "PolySlab",
      "description": "Polygon extruded with optional sidewall angle along axis direction.\n\nParameters\n----------\naxis : Literal[0, 1, 2] = 2\n    Specifies dimension of the planar axis (0,1,2) -> (x,y,z).\nsidewall_angle : ConstrainedFloatValue = 0.0\n    [units = rad].  Angle of the sidewall. ``sidewall_angle=0`` (default) specifies a vertical wall; ``0<sidewall_angle<np.pi/2`` specifies a shrinking cross section along the ``axis`` direction; and ``-np.pi/2<sidewall_angle<0`` specifies an expanding cross section along the ``axis`` direction.\nreference_plane : Literal['bottom', 'middle', 'top'] = bottom\n    The position of the plane where the supplied cross section are defined. The plane is perpendicular to the ``axis``. The plane is located at the ``bottom``, ``middle``, or ``top`` of the geometry with respect to the axis. E.g. if ``axis=1``, ``bottom`` refers to the negative side of the y-axis, and ``top`` refers to the positive side of the y-axis.\nslab_bounds : Tuple[float, float]\n    [units = um].  Minimum and maximum positions of the slab along axis dimension.\ndilation : float = 0.0\n    [units = um].  Dilation of the supplied polygon by shifting each edge along its normal outwards direction by a distance; a negative value corresponds to erosion.\nvertices : Union[Tuple[Tuple[float, float], ...], Array]\n    [units = um].  List of (d1, d2) defining the 2 dimensional positions of the polygon face vertices at the ``reference_plane``. The index of dimension should be in the ascending order: e.g. if the slab normal axis is ``axis=y``, the coordinate of the vertices will be in (x, z)\n\nExample\n-------\n>>> vertices = np.array([(0,0), (1,0), (1,1)])\n>>> p = PolySlab(vertices=vertices, axis=2, slab_bounds=(-1, 1))",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "PolySlab",
          "enum": [
            "PolySlab"
          ],
          "type": "string"
        },
        "axis": {
          "title": "Axis",
          "description": "Specifies dimension of the planar axis (0,1,2) -> (x,y,z).",
          "default": 2,
          "enum": [
            0,
            1,
            2
          ],
          "type": "integer"
        },
        "sidewall_angle": {
          "title": "Sidewall angle",
          "description": "Angle of the sidewall. ``sidewall_angle=0`` (default) specifies a vertical wall; ``0<sidewall_angle<np.pi/2`` specifies a shrinking cross section along the ``axis`` direction; and ``-np.pi/2<sidewall_angle<0`` specifies an expanding cross section along the ``axis`` direction.",
          "default": 0.0,
          "exclusiveMinimum": -1.5707963267948966,
          "exclusiveMaximum": 1.5707963267948966,
          "units": "rad",
          "type": "number"
        },
        "reference_plane": {
          "title": "Reference plane for cross section",
          "description": "The position of the plane where the supplied cross section are defined. The plane is perpendicular to the ``axis``. The plane is located at the ``bottom``, ``middle``, or ``top`` of the geometry with respect to the axis. E.g. if ``axis=1``, ``bottom`` refers to the negative side of the y-axis, and ``top`` refers to the positive side of the y-axis.",
          "default": "bottom",
          "enum": [
            "bottom",
            "middle",
            "top"
          ],
          "type": "string"
        },
        "slab_bounds": {
          "title": "Slab Bounds",
          "description": "Minimum and maximum positions of the slab along axis dimension.",
          "units": "um",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "dilation": {
          "title": "Dilation",
          "description": "Dilation of the supplied polygon by shifting each edge along its normal outwards direction by a distance; a negative value corresponds to erosion.",
          "default": 0.0,
          "units": "um",
          "type": "number"
        },
        "vertices": {
          "title": "Vertices",
          "description": "List of (d1, d2) defining the 2 dimensional positions of the polygon face vertices at the ``reference_plane``. The index of dimension should be in the ascending order: e.g. if the slab normal axis is ``axis=y``, the coordinate of the vertices will be in (x, z)",
          "units": "um",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "array",
                "minItems": 2,
                "maxItems": 2,
                "items": [
                  {
                    "type": "number"
                  },
                  {
                    "type": "number"
                  }
                ]
              }
            },
            {
              "title": "Array Like",
              "description": "Accepts sequence (tuple, list, numpy array) and converts to tuple.",
              "type": "tuple",
              "properties": {},
              "required": []
            }
          ]
        }
      },
      "required": [
        "slab_bounds",
        "vertices"
      ],
      "additionalProperties": false
    },
    "GeometryGroup": {
      "title": "GeometryGroup",
      "description": "A collection of Geometry objects that can be called as a single geometry object.\n\nParameters\n----------\ngeometries : Tuple[Annotated[Union[tidy3d.components.geometry.Box, tidy3d.components.geometry.Sphere, tidy3d.components.geometry.Cylinder, tidy3d.components.geometry.PolySlab], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})], ...]\n    Tuple of geometries in a single grouping. Can provide significant performance enhancement in ``Structure`` when all geometries are assigned the same medium.",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "GeometryGroup",
          "enum": [
            "GeometryGroup"
          ],
          "type": "string"
        },
        "geometries": {
          "title": "Geometries",
          "description": "Tuple of geometries in a single grouping. Can provide significant performance enhancement in ``Structure`` when all geometries are assigned the same medium.",
          "type": "array",
          "items": {
            "discriminator": {
              "propertyName": "type",
              "mapping": {
                "Box": "#/definitions/Box",
                "Sphere": "#/definitions/Sphere",
                "Cylinder": "#/definitions/Cylinder",
                "PolySlab": "#/definitions/PolySlab"
              }
            },
            "oneOf": [
              {
                "$ref": "#/definitions/Box"
              },
              {
                "$ref": "#/definitions/Sphere"
              },
              {
                "$ref": "#/definitions/Cylinder"
              },
              {
                "$ref": "#/definitions/PolySlab"
              }
            ]
          }
        }
      },
      "required": [
        "geometries"
      ],
      "additionalProperties": false
    },
    "Structure": {
      "title": "Structure",
      "description": "Defines a physical object that interacts with the electromagnetic fields.\nA :class:`Structure` is a combination of a material property (:class:`AbstractMedium`)\nand a :class:`Geometry`.\n\nParameters\n----------\ngeometry : Union[Box, Sphere, Cylinder, PolySlab, GeometryGroup]\n    Defines geometric properties of the structure.\nname : Optional[str] = None\n    Optional name for the structure.\nmedium : Union[Medium, CustomMedium, AnisotropicMedium, PECMedium, PoleResidue, Sellmeier, Lorentz, Debye, Drude]\n    Defines the electromagnetic properties of the structure's medium.\n\nExample\n-------\n>>> from tidy3d import Box, Medium\n>>> box = Box(center=(0,0,1), size=(2, 2, 2))\n>>> glass = Medium(permittivity=3.9)\n>>> struct = Structure(geometry=box, medium=glass, name='glass_box')",
      "type": "object",
      "properties": {
        "geometry": {
          "title": "Geometry",
          "description": "Defines geometric properties of the structure.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "Box": "#/definitions/Box",
              "Sphere": "#/definitions/Sphere",
              "Cylinder": "#/definitions/Cylinder",
              "PolySlab": "#/definitions/PolySlab",
              "GeometryGroup": "#/definitions/GeometryGroup"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/Box"
            },
            {
              "$ref": "#/definitions/Sphere"
            },
            {
              "$ref": "#/definitions/Cylinder"
            },
            {
              "$ref": "#/definitions/PolySlab"
            },
            {
              "$ref": "#/definitions/GeometryGroup"
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Optional name for the structure.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "Structure",
          "enum": [
            "Structure"
          ],
          "type": "string"
        },
        "medium": {
          "title": "Medium",
          "description": "Defines the electromagnetic properties of the structure's medium.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "Medium": "#/definitions/Medium",
              "CustomMedium": "#/definitions/CustomMedium",
              "AnisotropicMedium": "#/definitions/AnisotropicMedium",
              "PECMedium": "#/definitions/PECMedium",
              "PoleResidue": "#/definitions/PoleResidue",
              "Sellmeier": "#/definitions/Sellmeier",
              "Lorentz": "#/definitions/Lorentz",
              "Debye": "#/definitions/Debye",
              "Drude": "#/definitions/Drude"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/Medium"
            },
            {
              "$ref": "#/definitions/CustomMedium"
            },
            {
              "$ref": "#/definitions/AnisotropicMedium"
            },
            {
              "$ref": "#/definitions/PECMedium"
            },
            {
              "$ref": "#/definitions/PoleResidue"
            },
            {
              "$ref": "#/definitions/Sellmeier"
            },
            {
              "$ref": "#/definitions/Lorentz"
            },
            {
              "$ref": "#/definitions/Debye"
            },
            {
              "$ref": "#/definitions/Drude"
            }
          ]
        }
      },
      "required": [
        "geometry",
        "medium"
      ],
      "additionalProperties": false
    },
    "GaussianPulse": {
      "title": "GaussianPulse",
      "description": "Source time dependence that describes a Gaussian pulse.\n\nParameters\n----------\namplitude : NonNegativeFloat = 1.0\n    Real-valued maximum amplitude of the time dependence.\nphase : float = 0.0\n    [units = rad].  Phase shift of the time dependence.\nfreq0 : PositiveFloat\n    [units = Hz].  Central frequency of the pulse.\nfwidth : PositiveFloat\n    [units = Hz].  Standard deviation of the frequency content of the pulse.\noffset : ConstrainedFloatValue = 5.0\n    Time delay of the maximum value of the pulse in units of 1 / (``2pi * fwidth``).\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)",
      "type": "object",
      "properties": {
        "amplitude": {
          "title": "Amplitude",
          "description": "Real-valued maximum amplitude of the time dependence.",
          "default": 1.0,
          "minimum": 0,
          "type": "number"
        },
        "phase": {
          "title": "Phase",
          "description": "Phase shift of the time dependence.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "type": {
          "title": "Type",
          "default": "GaussianPulse",
          "enum": [
            "GaussianPulse"
          ],
          "type": "string"
        },
        "freq0": {
          "title": "Central Frequency",
          "description": "Central frequency of the pulse.",
          "units": "Hz",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "fwidth": {
          "title": "Fwidth",
          "description": "Standard deviation of the frequency content of the pulse.",
          "units": "Hz",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "offset": {
          "title": "Offset",
          "description": "Time delay of the maximum value of the pulse in units of 1 / (``2pi * fwidth``).",
          "default": 5.0,
          "minimum": 2.5,
          "type": "number"
        }
      },
      "required": [
        "freq0",
        "fwidth"
      ],
      "additionalProperties": false
    },
    "ContinuousWave": {
      "title": "ContinuousWave",
      "description": "Source time dependence that ramps up to continuous oscillation\nand holds until end of simulation.\n\nParameters\n----------\namplitude : NonNegativeFloat = 1.0\n    Real-valued maximum amplitude of the time dependence.\nphase : float = 0.0\n    [units = rad].  Phase shift of the time dependence.\nfreq0 : PositiveFloat\n    [units = Hz].  Central frequency of the pulse.\nfwidth : PositiveFloat\n    [units = Hz].  Standard deviation of the frequency content of the pulse.\noffset : ConstrainedFloatValue = 5.0\n    Time delay of the maximum value of the pulse in units of 1 / (``2pi * fwidth``).\n\nExample\n-------\n>>> cw = ContinuousWave(freq0=200e12, fwidth=20e12)",
      "type": "object",
      "properties": {
        "amplitude": {
          "title": "Amplitude",
          "description": "Real-valued maximum amplitude of the time dependence.",
          "default": 1.0,
          "minimum": 0,
          "type": "number"
        },
        "phase": {
          "title": "Phase",
          "description": "Phase shift of the time dependence.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "type": {
          "title": "Type",
          "default": "ContinuousWave",
          "enum": [
            "ContinuousWave"
          ],
          "type": "string"
        },
        "freq0": {
          "title": "Central Frequency",
          "description": "Central frequency of the pulse.",
          "units": "Hz",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "fwidth": {
          "title": "Fwidth",
          "description": "Standard deviation of the frequency content of the pulse.",
          "units": "Hz",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "offset": {
          "title": "Offset",
          "description": "Time delay of the maximum value of the pulse in units of 1 / (``2pi * fwidth``).",
          "default": 5.0,
          "minimum": 2.5,
          "type": "number"
        }
      },
      "required": [
        "freq0",
        "fwidth"
      ],
      "additionalProperties": false
    },
    "UniformCurrentSource": {
      "title": "UniformCurrentSource",
      "description": "Source in a rectangular volume with uniform time dependence. size=(0,0,0) gives point source.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave]\n    Specification of the source time-dependence.\nname : Optional[str] = None\n    Optional name for the source.\npolarization : Literal['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']\n    Specifies the direction and type of current component.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> pt_source = UniformCurrentSource(size=(0,0,0), source_time=pulse, polarization='Ex')",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "UniformCurrentSource",
          "enum": [
            "UniformCurrentSource"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "anyOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "polarization": {
          "title": "Polarization",
          "description": "Specifies the direction and type of current component.",
          "enum": [
            "Ex",
            "Ey",
            "Ez",
            "Hx",
            "Hy",
            "Hz"
          ],
          "type": "string"
        }
      },
      "required": [
        "size",
        "source_time",
        "polarization"
      ],
      "additionalProperties": false
    },
    "PointDipole": {
      "title": "PointDipole",
      "description": "Uniform current source with a zero size.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[Literal[0], Literal[0], Literal[0]] = (0, 0, 0)\n    [units = um].  Size in x, y, and z directions, constrained to ``(0, 0, 0)``.\nsource_time : Union[GaussianPulse, ContinuousWave]\n    Specification of the source time-dependence.\nname : Optional[str] = None\n    Optional name for the source.\npolarization : Literal['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']\n    Specifies the direction and type of current component.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> pt_dipole = PointDipole(center=(1,2,3), source_time=pulse, polarization='Ex')",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "PointDipole",
          "enum": [
            "PointDipole"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions, constrained to ``(0, 0, 0)``.",
          "default": [
            0,
            0,
            0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "enum": [
                0
              ],
              "type": "integer"
            },
            {
              "enum": [
                0
              ],
              "type": "integer"
            },
            {
              "enum": [
                0
              ],
              "type": "integer"
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "anyOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "polarization": {
          "title": "Polarization",
          "description": "Specifies the direction and type of current component.",
          "enum": [
            "Ex",
            "Ey",
            "Ez",
            "Hx",
            "Hy",
            "Hz"
          ],
          "type": "string"
        }
      },
      "required": [
        "source_time",
        "polarization"
      ],
      "additionalProperties": false
    },
    "GaussianBeam": {
      "title": "GaussianBeam",
      "description": "Guassian distribution on finite extent plane.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave]\n    Specification of the source time-dependence.\nname : Optional[str] = None\n    Optional name for the source.\nnum_freqs : ConstrainedIntValue = 1\n    Number of points used to approximate the frequency dependence of injected field. A Chebyshev interpolation is used, thus, only a small number of points, i.e., less than 20, is typically sufficient to obtain converged results.\ndirection : Literal['+', '-']\n    Specifies propagation in the positive or negative direction of the injection axis.\nangle_theta : float = 0.0\n    [units = rad].  Polar angle of the propagation axis from the injection axis.\nangle_phi : float = 0.0\n    [units = rad].  Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.\npol_angle : float = 0\n    [units = rad].  Specifies the angle between the electric field polarization of the source and the plane defined by the injection axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.\nwaist_radius : PositiveFloat = 1.0\n    [units = um].  Radius of the beam at the waist.\nwaist_distance : float = 0.0\n    [units = um].  Distance from the beam waist along the propagation direction.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> gauss = GaussianBeam(\n...     size=(0,3,3),\n...     source_time=pulse,\n...     pol_angle=np.pi / 2,\n...     direction='+',\n...     waist_radius=1.0)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "GaussianBeam",
          "enum": [
            "GaussianBeam"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "anyOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "num_freqs": {
          "title": "Number of Frequency Points",
          "description": "Number of points used to approximate the frequency dependence of injected field. A Chebyshev interpolation is used, thus, only a small number of points, i.e., less than 20, is typically sufficient to obtain converged results.",
          "default": 1,
          "minimum": 1,
          "maximum": 99,
          "type": "integer"
        },
        "direction": {
          "title": "Direction",
          "description": "Specifies propagation in the positive or negative direction of the injection axis.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "angle_theta": {
          "title": "Polar Angle",
          "description": "Polar angle of the propagation axis from the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "angle_phi": {
          "title": "Azimuth Angle",
          "description": "Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "pol_angle": {
          "title": "Polarization Angle",
          "description": "Specifies the angle between the electric field polarization of the source and the plane defined by the injection axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.",
          "default": 0,
          "units": "rad",
          "type": "number"
        },
        "waist_radius": {
          "title": "Waist Radius",
          "description": "Radius of the beam at the waist.",
          "default": 1.0,
          "units": "um",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "waist_distance": {
          "title": "Waist Distance",
          "description": "Distance from the beam waist along the propagation direction.",
          "default": 0.0,
          "units": "um",
          "type": "number"
        }
      },
      "required": [
        "size",
        "source_time",
        "direction"
      ],
      "additionalProperties": false
    },
    "AstigmaticGaussianBeam": {
      "title": "AstigmaticGaussianBeam",
      "description": "This class implements the simple astigmatic Gaussian beam described in Kochkina et al.,\nApplied Optics, vol. 52, issue 24, 2013. The simple astigmatic Guassian distribution allows\nboth an elliptical intensity profile and different waist locations for the two principal axes\nof the ellipse. When equal waist sizes and equal waist distances are specified in the two\ndirections, this source becomes equivalent to :class:`GaussianBeam`.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave]\n    Specification of the source time-dependence.\nname : Optional[str] = None\n    Optional name for the source.\nnum_freqs : ConstrainedIntValue = 1\n    Number of points used to approximate the frequency dependence of injected field. A Chebyshev interpolation is used, thus, only a small number of points, i.e., less than 20, is typically sufficient to obtain converged results.\ndirection : Literal['+', '-']\n    Specifies propagation in the positive or negative direction of the injection axis.\nangle_theta : float = 0.0\n    [units = rad].  Polar angle of the propagation axis from the injection axis.\nangle_phi : float = 0.0\n    [units = rad].  Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.\npol_angle : float = 0\n    [units = rad].  Specifies the angle between the electric field polarization of the source and the plane defined by the injection axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.\nwaist_sizes : Tuple[PositiveFloat, PositiveFloat] = (1.0, 1.0)\n    [units = um].  Size of the beam at the waist in the local x and y directions.\nwaist_distances : Tuple[float, float] = (0.0, 0.0)\n    [units = um].  Distance to the beam waist along the propagation direction for the waist sizes in the local x and y directions.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> gauss = AstigmaticGaussianBeam(\n...     size=(0,3,3),\n...     source_time=pulse,\n...     pol_angle=np.pi / 2,\n...     direction='+',\n...     waist_sizes=(1.0, 2.0),\n...     waist_distances = (3.0, 4.0))",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "AstigmaticGaussianBeam",
          "enum": [
            "AstigmaticGaussianBeam"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "anyOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "num_freqs": {
          "title": "Number of Frequency Points",
          "description": "Number of points used to approximate the frequency dependence of injected field. A Chebyshev interpolation is used, thus, only a small number of points, i.e., less than 20, is typically sufficient to obtain converged results.",
          "default": 1,
          "minimum": 1,
          "maximum": 99,
          "type": "integer"
        },
        "direction": {
          "title": "Direction",
          "description": "Specifies propagation in the positive or negative direction of the injection axis.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "angle_theta": {
          "title": "Polar Angle",
          "description": "Polar angle of the propagation axis from the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "angle_phi": {
          "title": "Azimuth Angle",
          "description": "Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "pol_angle": {
          "title": "Polarization Angle",
          "description": "Specifies the angle between the electric field polarization of the source and the plane defined by the injection axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.",
          "default": 0,
          "units": "rad",
          "type": "number"
        },
        "waist_sizes": {
          "title": "Waist sizes",
          "description": "Size of the beam at the waist in the local x and y directions.",
          "default": [
            1.0,
            1.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number",
              "exclusiveMinimum": 0
            },
            {
              "type": "number",
              "exclusiveMinimum": 0
            }
          ]
        },
        "waist_distances": {
          "title": "Waist distances",
          "description": "Distance to the beam waist along the propagation direction for the waist sizes in the local x and y directions.",
          "default": [
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        }
      },
      "required": [
        "size",
        "source_time",
        "direction"
      ],
      "additionalProperties": false
    },
    "ModeSpec": {
      "title": "ModeSpec",
      "description": "Stores specifications for the mode solver to find an electromagntic mode.\nNote, the planar axes are found by popping the injection axis from {x,y,z}.\nFor example, if injection axis is y, the planar axes are ordered {x,z}.\n\nParameters\n----------\nnum_modes : PositiveInt = 1\n    Number of modes returned by mode solver.\ntarget_neff : Optional[PositiveFloat] = None\n    Guess for effective index of the mode.\nnum_pml : Tuple[NonNegativeInt, NonNegativeInt] = (0, 0)\n    Number of standard pml layers to add in the two tangential axes.\nfilter_pol : Optional[Literal['te', 'tm']] = None\n    The solver always computes the ``num_modes`` modes closest to the given ``target_neff``. If ``filter_pol==None``, they are simply sorted in order of decresing effective index. If a polarization filter is selected, the modes are rearranged such that the first ``n_pol`` modes in the list are the ones with the selected polarization fraction larger than or equal to 0.5, while the next ``num_modes - n_pol`` modes are the ones where it is smaller than 0.5 (i.e. the opposite polarization fraction is larger than 0.5). Within each polarization subset, the modes are still ordered by decreasing effective index. ``te``-fraction is defined as the integrated intensity of the E-field component parallel to the first plane axis, normalized to the total in-plane E-field intensity. Conversely, ``tm``-fraction uses the E field component parallel to the second plane axis.\nangle_theta : float = 0.0\n    [units = rad].  Polar angle of the propagation axis from the injection axis.\nangle_phi : float = 0.0\n    [units = rad].  Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.\nprecision : Literal['single', 'double'] = single\n    The solver will be faster and using less memory under single precision, but more accurate under double precision.\nbend_radius : Optional[float] = None\n    [units = um].  A curvature radius for simulation of waveguide bends. Can be negative, in which case the mode plane center has a smaller value than the curvature center along the tangential axis perpendicular to the bend axis.\nbend_axis : Optional[Literal[0, 1]] = None\n    Index into the two tangential axes defining the normal to the plane in which the bend lies. This must be provided if ``bend_radius`` is not ``None``. For example, for a ring in the global xy-plane, and a mode plane in either the xz or the yz plane, the ``bend_axis`` is always 1 (the global z axis).\ntrack_freq : Optional[Literal['central', 'lowest', 'highest']] = central\n    Parameter that turns on/off mode tracking based on their similarity. Can take values ``'lowest'``, ``'central'``, or ``'highest'``, which correspond to mode tracking based on the lowest, central, or highest frequency. If ``None`` no mode tracking is performed.\n\nExample\n-------\n>>> mode_spec = ModeSpec(num_modes=3, target_neff=1.5)",
      "type": "object",
      "properties": {
        "num_modes": {
          "title": "Number of modes",
          "description": "Number of modes returned by mode solver.",
          "default": 1,
          "exclusiveMinimum": 0,
          "type": "integer"
        },
        "target_neff": {
          "title": "Target effective index",
          "description": "Guess for effective index of the mode.",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "num_pml": {
          "title": "Number of PML layers",
          "description": "Number of standard pml layers to add in the two tangential axes.",
          "default": [
            0,
            0
          ],
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": [
            {
              "type": "integer",
              "minimum": 0
            },
            {
              "type": "integer",
              "minimum": 0
            }
          ]
        },
        "filter_pol": {
          "title": "Polarization filtering",
          "description": "The solver always computes the ``num_modes`` modes closest to the given ``target_neff``. If ``filter_pol==None``, they are simply sorted in order of decresing effective index. If a polarization filter is selected, the modes are rearranged such that the first ``n_pol`` modes in the list are the ones with the selected polarization fraction larger than or equal to 0.5, while the next ``num_modes - n_pol`` modes are the ones where it is smaller than 0.5 (i.e. the opposite polarization fraction is larger than 0.5). Within each polarization subset, the modes are still ordered by decreasing effective index. ``te``-fraction is defined as the integrated intensity of the E-field component parallel to the first plane axis, normalized to the total in-plane E-field intensity. Conversely, ``tm``-fraction uses the E field component parallel to the second plane axis.",
          "enum": [
            "te",
            "tm"
          ],
          "type": "string"
        },
        "angle_theta": {
          "title": "Polar Angle",
          "description": "Polar angle of the propagation axis from the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "angle_phi": {
          "title": "Azimuth Angle",
          "description": "Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "precision": {
          "title": "single or double precision in mode solver",
          "description": "The solver will be faster and using less memory under single precision, but more accurate under double precision.",
          "default": "single",
          "enum": [
            "single",
            "double"
          ],
          "type": "string"
        },
        "bend_radius": {
          "title": "Bend radius",
          "description": "A curvature radius for simulation of waveguide bends. Can be negative, in which case the mode plane center has a smaller value than the curvature center along the tangential axis perpendicular to the bend axis.",
          "units": "um",
          "type": "number"
        },
        "bend_axis": {
          "title": "Bend axis",
          "description": "Index into the two tangential axes defining the normal to the plane in which the bend lies. This must be provided if ``bend_radius`` is not ``None``. For example, for a ring in the global xy-plane, and a mode plane in either the xz or the yz plane, the ``bend_axis`` is always 1 (the global z axis).",
          "enum": [
            0,
            1
          ],
          "type": "integer"
        },
        "track_freq": {
          "title": "Mode Tracking Frequency",
          "description": "Parameter that turns on/off mode tracking based on their similarity. Can take values ``'lowest'``, ``'central'``, or ``'highest'``, which correspond to mode tracking based on the lowest, central, or highest frequency. If ``None`` no mode tracking is performed.",
          "default": "central",
          "enum": [
            "central",
            "lowest",
            "highest"
          ],
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "ModeSpec",
          "enum": [
            "ModeSpec"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "ModeSource": {
      "title": "ModeSource",
      "description": "Injects current source to excite modal profile on finite extent plane.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave]\n    Specification of the source time-dependence.\nname : Optional[str] = None\n    Optional name for the source.\nnum_freqs : ConstrainedIntValue = 1\n    Number of points used to approximate the frequency dependence of injected field. A Chebyshev interpolation is used, thus, only a small number of points, i.e., less than 20, is typically sufficient to obtain converged results.\ndirection : Literal['+', '-']\n    Specifies propagation in the positive or negative direction of the injection axis.\nmode_spec : ModeSpec = ModeSpec(num_modes=1, target_neff=None, num_pml=(0,, 0), filter_pol=None, angle_theta=0.0, angle_phi=0.0, precision='single', bend_radius=None, bend_axis=None, track_freq='central', type='ModeSpec')\n    Parameters to feed to mode solver which determine modes measured by monitor.\nmode_index : NonNegativeInt = 0\n    Index into the collection of modes returned by mode solver.  Specifies which mode to inject using this source. If larger than ``mode_spec.num_modes``, ``num_modes`` in the solver will be set to ``mode_index + 1``.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> mode_spec = ModeSpec(target_neff=2.)\n>>> mode_source = ModeSource(\n...     size=(10,10,0),\n...     source_time=pulse,\n...     mode_spec=mode_spec,\n...     mode_index=1,\n...     direction='-')",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "ModeSource",
          "enum": [
            "ModeSource"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "anyOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "num_freqs": {
          "title": "Number of Frequency Points",
          "description": "Number of points used to approximate the frequency dependence of injected field. A Chebyshev interpolation is used, thus, only a small number of points, i.e., less than 20, is typically sufficient to obtain converged results.",
          "default": 1,
          "minimum": 1,
          "maximum": 99,
          "type": "integer"
        },
        "direction": {
          "title": "Direction",
          "description": "Specifies propagation in the positive or negative direction of the injection axis.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "mode_spec": {
          "title": "Mode Specification",
          "description": "Parameters to feed to mode solver which determine modes measured by monitor.",
          "default": {
            "num_modes": 1,
            "target_neff": null,
            "num_pml": [
              0,
              0
            ],
            "filter_pol": null,
            "angle_theta": 0.0,
            "angle_phi": 0.0,
            "precision": "single",
            "bend_radius": null,
            "bend_axis": null,
            "track_freq": "central",
            "type": "ModeSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ModeSpec"
            }
          ]
        },
        "mode_index": {
          "title": "Mode Index",
          "description": "Index into the collection of modes returned by mode solver.  Specifies which mode to inject using this source. If larger than ``mode_spec.num_modes``, ``num_modes`` in the solver will be set to ``mode_index + 1``.",
          "default": 0,
          "minimum": 0,
          "type": "integer"
        }
      },
      "required": [
        "size",
        "source_time",
        "direction"
      ],
      "additionalProperties": false
    },
    "PlaneWave": {
      "title": "PlaneWave",
      "description": "Uniform current distribution on an infinite extent plane. One element of size must be zero.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave]\n    Specification of the source time-dependence.\nname : Optional[str] = None\n    Optional name for the source.\ndirection : Literal['+', '-']\n    Specifies propagation in the positive or negative direction of the injection axis.\nangle_theta : float = 0.0\n    [units = rad].  Polar angle of the propagation axis from the injection axis.\nangle_phi : float = 0.0\n    [units = rad].  Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.\npol_angle : float = 0\n    [units = rad].  Specifies the angle between the electric field polarization of the source and the plane defined by the injection axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> pw_source = PlaneWave(size=(inf,0,inf), source_time=pulse, pol_angle=0.1, direction='+')",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "PlaneWave",
          "enum": [
            "PlaneWave"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "anyOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "direction": {
          "title": "Direction",
          "description": "Specifies propagation in the positive or negative direction of the injection axis.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "angle_theta": {
          "title": "Polar Angle",
          "description": "Polar angle of the propagation axis from the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "angle_phi": {
          "title": "Azimuth Angle",
          "description": "Azimuth angle of the propagation axis in the plane orthogonal to the injection axis.",
          "default": 0.0,
          "units": "rad",
          "type": "number"
        },
        "pol_angle": {
          "title": "Polarization Angle",
          "description": "Specifies the angle between the electric field polarization of the source and the plane defined by the injection axis and the propagation axis (rad). ``pol_angle=0`` (default) specifies P polarization, while ``pol_angle=np.pi/2`` specifies S polarization. At normal incidence when S and P are undefined, ``pol_angle=0`` defines: - ``Ey`` polarization for propagation along ``x``.- ``Ex`` polarization for propagation along ``y``.- ``Ex`` polarization for propagation along ``z``.",
          "default": 0,
          "units": "rad",
          "type": "number"
        }
      },
      "required": [
        "size",
        "source_time",
        "direction"
      ],
      "additionalProperties": false
    },
    "FieldDataset": {
      "title": "FieldDataset",
      "description": "Dataset storing a collection of the scalar components of E and H fields in the freq. domain\n\nParameters\n----------\nEx : Optional[ScalarFieldDataArray] = None\n    Spatial distribution of the x-component of the electric field.\nEy : Optional[ScalarFieldDataArray] = None\n    Spatial distribution of the y-component of the electric field.\nEz : Optional[ScalarFieldDataArray] = None\n    Spatial distribution of the z-component of the electric field.\nHx : Optional[ScalarFieldDataArray] = None\n    Spatial distribution of the x-component of the magnetic field.\nHy : Optional[ScalarFieldDataArray] = None\n    Spatial distribution of the y-component of the magnetic field.\nHz : Optional[ScalarFieldDataArray] = None\n    Spatial distribution of the z-component of the magnetic field.\n\nExample\n-------\n>>> x = [-1,1]\n>>> y = [-2,0,2]\n>>> z = [-3,-1,1,3]\n>>> f = [2e14, 3e14]\n>>> coords = dict(x=x, y=y, z=z, f=f)\n>>> scalar_field = ScalarFieldDataArray((1+1j) * np.random.random((2,3,4,2)), coords=coords)\n>>> data = FieldDataset(Ex=scalar_field, Hz=scalar_field)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "FieldDataset",
          "enum": [
            "FieldDataset"
          ],
          "type": "string"
        },
        "Ex": {
          "title": "DataArray",
          "description": "Spatial distribution of the x-component of the electric field.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "Ey": {
          "title": "DataArray",
          "description": "Spatial distribution of the y-component of the electric field.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "Ez": {
          "title": "DataArray",
          "description": "Spatial distribution of the z-component of the electric field.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "Hx": {
          "title": "DataArray",
          "description": "Spatial distribution of the x-component of the magnetic field.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "Hy": {
          "title": "DataArray",
          "description": "Spatial distribution of the y-component of the magnetic field.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        },
        "Hz": {
          "title": "DataArray",
          "description": "Spatial distribution of the z-component of the magnetic field.",
          "type": "xr.DataArray",
          "properties": {
            "_dims": {
              "title": "_dims",
              "type": "Tuple[str, ...]"
            }
          },
          "required": [
            "_dims"
          ]
        }
      },
      "additionalProperties": false
    },
    "CustomFieldSource": {
      "title": "CustomFieldSource",
      "description": "Implements a source corresponding to an input dataset containing ``E`` and ``H`` fields.\nFor the injection to work as expected, the fields must decay by the edges of the source plane,\nor the source plane must span the entire simulation domain and the fields must match the\nsimulation boundary conditions. The equivalent source currents are fully defined by the field\ncomponents tangential to the source plane. The normal components (e.g. ``Ez`` and ``Hz``) can be\nprovided but will have no effect on the results, in accordance with the equivalence principle.\nAt least one of the tangential components has to be defined. For example, for a ``z``-normal\nsource, at least one of ``Ex``, ``Ey``, ``Hx``, and ``Hy`` has to be present in the provided\ndataset. The coordinates of all provided fields are assumed to be relative to the source\ncenter. Each provided field component must also span the size of the source.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave]\n    Specification of the source time-dependence.\nname : Optional[str] = None\n    Optional name for the source.\nfield_dataset : Optional[FieldDataset]\n    :class:`.FieldDataset` containing the desired frequency-domain fields patterns to inject. At least one tangetial field component must be specified.\n\nNote\n----\n    If only the ``E`` or only the ``H`` fields are provided, the source will not be directional,\n    but will inject equal power in both directions instead.\n\nExample\n-------\n>>> from tidy3d import ScalarFieldDataArray\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> x = np.linspace(-1, 1, 101)\n>>> y = np.linspace(-1, 1, 101)\n>>> z = np.array([0])\n>>> f = [2e14]\n>>> coords = dict(x=x, y=y, z=z, f=f)\n>>> scalar_field = ScalarFieldDataArray(np.ones((101, 101, 1, 1)), coords=coords)\n>>> dataset = FieldDataset(Ex=scalar_field)\n>>> custom_source = CustomFieldSource(\n...     center=(1, 1, 1),\n...     size=(2, 2, 0),\n...     source_time=pulse,\n...     field_dataset=dataset)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "CustomFieldSource",
          "enum": [
            "CustomFieldSource"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "source_time": {
          "title": "Source Time",
          "description": "Specification of the source time-dependence.",
          "anyOf": [
            {
              "$ref": "#/definitions/GaussianPulse"
            },
            {
              "$ref": "#/definitions/ContinuousWave"
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Optional name for the source.",
          "type": "string"
        },
        "field_dataset": {
          "title": "Field Dataset",
          "description": ":class:`.FieldDataset` containing the desired frequency-domain fields patterns to inject. At least one tangetial field component must be specified.",
          "allOf": [
            {
              "$ref": "#/definitions/FieldDataset"
            }
          ]
        }
      },
      "required": [
        "size",
        "source_time",
        "field_dataset"
      ],
      "additionalProperties": false
    },
    "Periodic": {
      "title": "Periodic",
      "description": "Periodic boundary condition class.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for boundary.",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for boundary.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "Periodic",
          "enum": [
            "Periodic"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PECBoundary": {
      "title": "PECBoundary",
      "description": "Perfect electric conductor boundary condition class.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for boundary.",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for boundary.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "PECBoundary",
          "enum": [
            "PECBoundary"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PMCBoundary": {
      "title": "PMCBoundary",
      "description": "Perfect magnetic conductor boundary condition class.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for boundary.",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for boundary.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "PMCBoundary",
          "enum": [
            "PMCBoundary"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PMLParams": {
      "title": "PMLParams",
      "description": "Specifies full set of parameters needed for complex, frequency-shifted PML.\n\nParameters\n----------\nsigma_order : NonNegativeInt = 3\n    Order of the polynomial describing the absorber profile (~dist^sigma_order).\nsigma_min : NonNegativeFloat = 0.0\n    [units = 2*EPSILON_0/dt].  Minimum value of the absorber conductivity.\nsigma_max : NonNegativeFloat = 1.5\n    [units = 2*EPSILON_0/dt].  Maximum value of the absorber conductivity.\nkappa_order : NonNegativeInt = 3\n    Order of the polynomial describing the PML kappa profile (kappa~dist^kappa_order).\nkappa_min : NonNegativeFloat = 0.0\n    \nkappa_max : NonNegativeFloat = 1.5\n    \nalpha_order : NonNegativeInt = 3\n    Order of the polynomial describing the PML alpha profile (alpha~dist^alpha_order).\nalpha_min : NonNegativeFloat = 0.0\n    [units = 2*EPSILON_0/dt].  Minimum value of the PML alpha.\nalpha_max : NonNegativeFloat = 1.5\n    [units = 2*EPSILON_0/dt].  Maximum value of the PML alpha.\n\nExample\n-------\n>>> params = PMLParams(sigma_order=3, sigma_min=0.0, sigma_max=1.5, kappa_min=0.0)",
      "type": "object",
      "properties": {
        "sigma_order": {
          "title": "Sigma Order",
          "description": "Order of the polynomial describing the absorber profile (~dist^sigma_order).",
          "default": 3,
          "minimum": 0,
          "type": "integer"
        },
        "sigma_min": {
          "title": "Sigma Minimum",
          "description": "Minimum value of the absorber conductivity.",
          "default": 0.0,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        },
        "sigma_max": {
          "title": "Sigma Maximum",
          "description": "Maximum value of the absorber conductivity.",
          "default": 1.5,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        },
        "type": {
          "title": "Type",
          "default": "PMLParams",
          "enum": [
            "PMLParams"
          ],
          "type": "string"
        },
        "kappa_order": {
          "title": "Kappa Order",
          "description": "Order of the polynomial describing the PML kappa profile (kappa~dist^kappa_order).",
          "default": 3,
          "minimum": 0,
          "type": "integer"
        },
        "kappa_min": {
          "title": "Kappa Minimum",
          "default": 0.0,
          "minimum": 0,
          "type": "number"
        },
        "kappa_max": {
          "title": "Kappa Maximum",
          "default": 1.5,
          "minimum": 0,
          "type": "number"
        },
        "alpha_order": {
          "title": "Alpha Order",
          "description": "Order of the polynomial describing the PML alpha profile (alpha~dist^alpha_order).",
          "default": 3,
          "minimum": 0,
          "type": "integer"
        },
        "alpha_min": {
          "title": "Alpha Minimum",
          "description": "Minimum value of the PML alpha.",
          "default": 0.0,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        },
        "alpha_max": {
          "title": "Alpha Maximum",
          "description": "Maximum value of the PML alpha.",
          "default": 1.5,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        }
      },
      "additionalProperties": false
    },
    "PML": {
      "title": "PML",
      "description": "Specifies a standard PML along a single dimension.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for boundary.\nnum_layers : NonNegativeInt = 12\n    Number of layers of standard PML.\nparameters : PMLParams = PMLParams(sigma_order=3, sigma_min=0.0, sigma_max=1.5, type='PMLParams', kappa_order=3, kappa_min=1.0, kappa_max=3.0, alpha_order=1, alpha_min=0.0, alpha_max=0.0)\n    Parameters of the complex frequency-shifted absorption poles.\n\nExample\n-------\n>>> pml = PML(num_layers=10)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for boundary.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "PML",
          "enum": [
            "PML"
          ],
          "type": "string"
        },
        "num_layers": {
          "title": "Number of Layers",
          "description": "Number of layers of standard PML.",
          "default": 12,
          "minimum": 0,
          "type": "integer"
        },
        "parameters": {
          "title": "PML Parameters",
          "description": "Parameters of the complex frequency-shifted absorption poles.",
          "default": {
            "sigma_order": 3,
            "sigma_min": 0.0,
            "sigma_max": 1.5,
            "type": "PMLParams",
            "kappa_order": 3,
            "kappa_min": 1.0,
            "kappa_max": 3.0,
            "alpha_order": 1,
            "alpha_min": 0.0,
            "alpha_max": 0.0
          },
          "allOf": [
            {
              "$ref": "#/definitions/PMLParams"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "StablePML": {
      "title": "StablePML",
      "description": "Specifies a 'stable' PML along a single dimension.\nThis PML deals handles possbly divergent simulations better, but at the expense of more layers.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for boundary.\nnum_layers : NonNegativeInt = 40\n    Number of layers of 'stable' PML.\nparameters : PMLParams = PMLParams(sigma_order=3, sigma_min=0.0, sigma_max=1.0, type='PMLParams', kappa_order=3, kappa_min=1.0, kappa_max=5.0, alpha_order=1, alpha_min=0.0, alpha_max=0.9)\n    'Stable' parameters of the complex frequency-shifted absorption poles.\n\nExample\n-------\n>>> pml = StablePML(num_layers=40)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for boundary.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "StablePML",
          "enum": [
            "StablePML"
          ],
          "type": "string"
        },
        "num_layers": {
          "title": "Number of Layers",
          "description": "Number of layers of 'stable' PML.",
          "default": 40,
          "minimum": 0,
          "type": "integer"
        },
        "parameters": {
          "title": "Stable PML Parameters",
          "description": "'Stable' parameters of the complex frequency-shifted absorption poles.",
          "default": {
            "sigma_order": 3,
            "sigma_min": 0.0,
            "sigma_max": 1.0,
            "type": "PMLParams",
            "kappa_order": 3,
            "kappa_min": 1.0,
            "kappa_max": 5.0,
            "alpha_order": 1,
            "alpha_min": 0.0,
            "alpha_max": 0.9
          },
          "allOf": [
            {
              "$ref": "#/definitions/PMLParams"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "AbsorberParams": {
      "title": "AbsorberParams",
      "description": "Specifies parameters common to Absorbers and PMLs.\n\nParameters\n----------\nsigma_order : NonNegativeInt = 3\n    Order of the polynomial describing the absorber profile (~dist^sigma_order).\nsigma_min : NonNegativeFloat = 0.0\n    [units = 2*EPSILON_0/dt].  Minimum value of the absorber conductivity.\nsigma_max : NonNegativeFloat = 1.5\n    [units = 2*EPSILON_0/dt].  Maximum value of the absorber conductivity.\n\nExample\n-------\n>>> params = AbsorberParams(sigma_order=3, sigma_min=0.0, sigma_max=1.5)",
      "type": "object",
      "properties": {
        "sigma_order": {
          "title": "Sigma Order",
          "description": "Order of the polynomial describing the absorber profile (~dist^sigma_order).",
          "default": 3,
          "minimum": 0,
          "type": "integer"
        },
        "sigma_min": {
          "title": "Sigma Minimum",
          "description": "Minimum value of the absorber conductivity.",
          "default": 0.0,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        },
        "sigma_max": {
          "title": "Sigma Maximum",
          "description": "Maximum value of the absorber conductivity.",
          "default": 1.5,
          "units": "2*EPSILON_0/dt",
          "minimum": 0,
          "type": "number"
        },
        "type": {
          "title": "Type",
          "default": "AbsorberParams",
          "enum": [
            "AbsorberParams"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "Absorber": {
      "title": "Absorber",
      "description": "Specifies an adiabatic absorber along a single dimension.\nThis absorber is well-suited for dispersive materials\nintersecting with absorbing edges of the simulation at the expense of more layers.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for boundary.\nnum_layers : NonNegativeInt = 40\n    Number of layers of absorber to add to + and - boundaries.\nparameters : AbsorberParams = AbsorberParams(sigma_order=3, sigma_min=0.0, sigma_max=6.4, type='AbsorberParams')\n    Adiabatic absorber parameters.\n\nExample\n-------\n>>> pml = Absorber(num_layers=40)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for boundary.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "Absorber",
          "enum": [
            "Absorber"
          ],
          "type": "string"
        },
        "num_layers": {
          "title": "Number of Layers",
          "description": "Number of layers of absorber to add to + and - boundaries.",
          "default": 40,
          "minimum": 0,
          "type": "integer"
        },
        "parameters": {
          "title": "Absorber Parameters",
          "description": "Adiabatic absorber parameters.",
          "default": {
            "sigma_order": 3,
            "sigma_min": 0.0,
            "sigma_max": 6.4,
            "type": "AbsorberParams"
          },
          "allOf": [
            {
              "$ref": "#/definitions/AbsorberParams"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "BlochBoundary": {
      "title": "BlochBoundary",
      "description": "Specifies a Bloch boundary condition along a single dimension.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for boundary.\nbloch_vec : float\n    Normalized component of the Bloch vector in units of 2 * pi / (size along dimension) in the background medium, along the dimension in which the boundary is specified.\n\nExample\n-------\n>>> bloch = BlochBoundary(bloch_vec=1)",
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "description": "Optional unique name for boundary.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "BlochBoundary",
          "enum": [
            "BlochBoundary"
          ],
          "type": "string"
        },
        "bloch_vec": {
          "title": "Normalized Bloch vector component",
          "description": "Normalized component of the Bloch vector in units of 2 * pi / (size along dimension) in the background medium, along the dimension in which the boundary is specified.",
          "type": "number"
        }
      },
      "required": [
        "bloch_vec"
      ],
      "additionalProperties": false
    },
    "Boundary": {
      "title": "Boundary",
      "description": "Boundary conditions at the minus and plus extents along a dimension\n\nParameters\n----------\nplus : Union[Periodic, PECBoundary, PMCBoundary, PML, StablePML, Absorber, BlochBoundary] = Periodic(name=None, type='Periodic')\n    Boundary condition on the plus side along a dimension.\nminus : Union[Periodic, PECBoundary, PMCBoundary, PML, StablePML, Absorber, BlochBoundary] = Periodic(name=None, type='Periodic')\n    Boundary condition on the minus side along a dimension.\n\nExample\n-------\n>>> boundary = Boundary(plus = PML(), minus = PECBoundary())",
      "type": "object",
      "properties": {
        "plus": {
          "title": "Plus BC",
          "description": "Boundary condition on the plus side along a dimension.",
          "default": {
            "name": null,
            "type": "Periodic"
          },
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "Periodic": "#/definitions/Periodic",
              "PECBoundary": "#/definitions/PECBoundary",
              "PMCBoundary": "#/definitions/PMCBoundary",
              "PML": "#/definitions/PML",
              "StablePML": "#/definitions/StablePML",
              "Absorber": "#/definitions/Absorber",
              "BlochBoundary": "#/definitions/BlochBoundary"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/Periodic"
            },
            {
              "$ref": "#/definitions/PECBoundary"
            },
            {
              "$ref": "#/definitions/PMCBoundary"
            },
            {
              "$ref": "#/definitions/PML"
            },
            {
              "$ref": "#/definitions/StablePML"
            },
            {
              "$ref": "#/definitions/Absorber"
            },
            {
              "$ref": "#/definitions/BlochBoundary"
            }
          ]
        },
        "minus": {
          "title": "Minus BC",
          "description": "Boundary condition on the minus side along a dimension.",
          "default": {
            "name": null,
            "type": "Periodic"
          },
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "Periodic": "#/definitions/Periodic",
              "PECBoundary": "#/definitions/PECBoundary",
              "PMCBoundary": "#/definitions/PMCBoundary",
              "PML": "#/definitions/PML",
              "StablePML": "#/definitions/StablePML",
              "Absorber": "#/definitions/Absorber",
              "BlochBoundary": "#/definitions/BlochBoundary"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/Periodic"
            },
            {
              "$ref": "#/definitions/PECBoundary"
            },
            {
              "$ref": "#/definitions/PMCBoundary"
            },
            {
              "$ref": "#/definitions/PML"
            },
            {
              "$ref": "#/definitions/StablePML"
            },
            {
              "$ref": "#/definitions/Absorber"
            },
            {
              "$ref": "#/definitions/BlochBoundary"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "Boundary",
          "enum": [
            "Boundary"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "BoundarySpec": {
      "title": "BoundarySpec",
      "description": "Specifies boundary conditions on each side of the domain and along each dimension.\n\nParameters\n----------\nx : Optional[Boundary] = None\n    Boundary condition on the plus and minus sides along the x axis. If `None`, periodic boundaries are applied. Default will change to PML in 2.0 so explicitly setting the boundaries is recommended.\ny : Optional[Boundary] = None\n    Boundary condition on the plus and minus sides along the y axis. If `None`, periodic boundaries are applied. Default will change to PML in 2.0 so explicitly setting the boundaries is recommended.\nz : Optional[Boundary] = None\n    Boundary condition on the plus and minus sides along the z axis. If `None`, periodic boundaries are applied. Default will change to PML in 2.0 so explicitly setting the boundaries is recommended.",
      "type": "object",
      "properties": {
        "x": {
          "title": "Boundary condition along x.",
          "description": "Boundary condition on the plus and minus sides along the x axis. If `None`, periodic boundaries are applied. Default will change to PML in 2.0 so explicitly setting the boundaries is recommended.",
          "allOf": [
            {
              "$ref": "#/definitions/Boundary"
            }
          ]
        },
        "y": {
          "title": "Boundary condition along y.",
          "description": "Boundary condition on the plus and minus sides along the y axis. If `None`, periodic boundaries are applied. Default will change to PML in 2.0 so explicitly setting the boundaries is recommended.",
          "allOf": [
            {
              "$ref": "#/definitions/Boundary"
            }
          ]
        },
        "z": {
          "title": "Boundary condition along z.",
          "description": "Boundary condition on the plus and minus sides along the z axis. If `None`, periodic boundaries are applied. Default will change to PML in 2.0 so explicitly setting the boundaries is recommended.",
          "allOf": [
            {
              "$ref": "#/definitions/Boundary"
            }
          ]
        },
        "type": {
          "title": "Type",
          "default": "BoundarySpec",
          "enum": [
            "BoundarySpec"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "ApodizationSpec": {
      "title": "ApodizationSpec",
      "description": "Stores specifications for the apodizaton of frequency-domain monitors.\n\nParameters\n----------\nstart : Optional[NonNegativeFloat] = None\n    [units = sec].  Defines the time at which the start apodization ends.\nend : Optional[NonNegativeFloat] = None\n    [units = sec].  Defines the time at which the end apodization begins.\nwidth : Optional[PositiveFloat] = None\n    [units = sec].  Characteristic decay length of the apodization function.\n\nExample\n-------\n>>> apod_spec = ApodizationSpec(start=1, end=2, width=0.5)",
      "type": "object",
      "properties": {
        "start": {
          "title": "Start Interval",
          "description": "Defines the time at which the start apodization ends.",
          "units": "sec",
          "minimum": 0,
          "type": "number"
        },
        "end": {
          "title": "End Interval",
          "description": "Defines the time at which the end apodization begins.",
          "units": "sec",
          "minimum": 0,
          "type": "number"
        },
        "width": {
          "title": "Apodization Width",
          "description": "Characteristic decay length of the apodization function.",
          "units": "sec",
          "exclusiveMinimum": 0,
          "type": "number"
        },
        "type": {
          "title": "Type",
          "default": "ApodizationSpec",
          "enum": [
            "ApodizationSpec"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "FieldMonitor": {
      "title": "FieldMonitor",
      "description": ":class:`Monitor` that records electromagnetic fields in the frequency domain.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\nfreqs : Union[Tuple[float, ...], Array]\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\napodization : ApodizationSpec = ApodizationSpec(start=None, end=None, width=None, type='ApodizationSpec')\n    Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.\nfields : Tuple[Literal['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz'], ...] = ['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']\n    Collection of field components to store in the monitor.\ninterval_space : Tuple[PositiveInt, PositiveInt, PositiveInt] = (1, 1, 1)\n    Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, fields will be downsampled and automatically colocated.\ncolocate : Optional[bool] = None\n    Toggle whether fields should be colocated to grid cell centers. Default: ``False`` if ``interval_space`` is 1 in each direction, ``True`` if ``interval_space`` is greater than one in any direction.\n\nExample\n-------\n>>> monitor = FieldMonitor(\n...     center=(1,2,3),\n...     size=(2,2,2),\n...     fields=['Hx'],\n...     freqs=[250e12, 300e12],\n...     name='steady_state_monitor')",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "FieldMonitor",
          "enum": [
            "FieldMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "title": "Array Like",
              "description": "Accepts sequence (tuple, list, numpy array) and converts to tuple.",
              "type": "tuple",
              "properties": {},
              "required": []
            }
          ]
        },
        "apodization": {
          "title": "Apodization Specification",
          "description": "Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.",
          "default": {
            "start": null,
            "end": null,
            "width": null,
            "type": "ApodizationSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ApodizationSpec"
            }
          ]
        },
        "fields": {
          "title": "Field Components",
          "description": "Collection of field components to store in the monitor.",
          "default": [
            "Ex",
            "Ey",
            "Ez",
            "Hx",
            "Hy",
            "Hz"
          ],
          "type": "array",
          "items": {
            "enum": [
              "Ex",
              "Ey",
              "Ez",
              "Hx",
              "Hy",
              "Hz"
            ],
            "type": "string"
          }
        },
        "interval_space": {
          "title": "Spatial interval",
          "description": "Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, fields will be downsampled and automatically colocated.",
          "default": [
            1,
            1,
            1
          ],
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "integer",
              "exclusiveMinimum": 0
            },
            {
              "type": "integer",
              "exclusiveMinimum": 0
            },
            {
              "type": "integer",
              "exclusiveMinimum": 0
            }
          ]
        },
        "colocate": {
          "title": "Colocate fields",
          "description": "Toggle whether fields should be colocated to grid cell centers. Default: ``False`` if ``interval_space`` is 1 in each direction, ``True`` if ``interval_space`` is greater than one in any direction.",
          "type": "boolean"
        }
      },
      "required": [
        "size",
        "name",
        "freqs"
      ],
      "additionalProperties": false
    },
    "FieldTimeMonitor": {
      "title": "FieldTimeMonitor",
      "description": ":class:`Monitor` that records electromagnetic fields in the time domain.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\nstart : NonNegativeFloat = 0.0\n    [units = sec].  Time at which to start monitor recording.\nstop : Optional[NonNegativeFloat] = None\n    [units = sec].  Time at which to stop monitor recording.  If not specified, record until end of simulation.\ninterval : PositiveInt = 1\n    Number of time step intervals between monitor recordings.\nfields : Tuple[Literal['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz'], ...] = ['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']\n    Collection of field components to store in the monitor.\ninterval_space : Tuple[PositiveInt, PositiveInt, PositiveInt] = (1, 1, 1)\n    Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, fields will be downsampled and automatically colocated.\ncolocate : Optional[bool] = None\n    Toggle whether fields should be colocated to grid cell centers. Default: ``False`` if ``interval_space`` is 1 in each direction, ``True`` if ``interval_space`` is greater than one in any direction.\n\nExample\n-------\n>>> monitor = FieldTimeMonitor(\n...     center=(1,2,3),\n...     size=(2,2,2),\n...     fields=['Hx'],\n...     start=1e-13,\n...     stop=5e-13,\n...     interval=2,\n...     name='movie_monitor')",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "FieldTimeMonitor",
          "enum": [
            "FieldTimeMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "start": {
          "title": "Start time",
          "description": "Time at which to start monitor recording.",
          "default": 0.0,
          "units": "sec",
          "minimum": 0,
          "type": "number"
        },
        "stop": {
          "title": "Stop time",
          "description": "Time at which to stop monitor recording.  If not specified, record until end of simulation.",
          "units": "sec",
          "minimum": 0,
          "type": "number"
        },
        "interval": {
          "title": "Time interval",
          "description": "Number of time step intervals between monitor recordings.",
          "default": 1,
          "exclusiveMinimum": 0,
          "type": "integer"
        },
        "fields": {
          "title": "Field Components",
          "description": "Collection of field components to store in the monitor.",
          "default": [
            "Ex",
            "Ey",
            "Ez",
            "Hx",
            "Hy",
            "Hz"
          ],
          "type": "array",
          "items": {
            "enum": [
              "Ex",
              "Ey",
              "Ez",
              "Hx",
              "Hy",
              "Hz"
            ],
            "type": "string"
          }
        },
        "interval_space": {
          "title": "Spatial interval",
          "description": "Number of grid step intervals between monitor recordings. If equal to 1, there will be no downsampling. If greater than 1, fields will be downsampled and automatically colocated.",
          "default": [
            1,
            1,
            1
          ],
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "integer",
              "exclusiveMinimum": 0
            },
            {
              "type": "integer",
              "exclusiveMinimum": 0
            },
            {
              "type": "integer",
              "exclusiveMinimum": 0
            }
          ]
        },
        "colocate": {
          "title": "Colocate fields",
          "description": "Toggle whether fields should be colocated to grid cell centers. Default: ``False`` if ``interval_space`` is 1 in each direction, ``True`` if ``interval_space`` is greater than one in any direction.",
          "type": "boolean"
        }
      },
      "required": [
        "size",
        "name"
      ],
      "additionalProperties": false
    },
    "PermittivityMonitor": {
      "title": "PermittivityMonitor",
      "description": ":class:`Monitor` that records the diagonal components of the complex-valued relative\npermittivity tensor in the frequency domain. The recorded data has the same shape as a\n:class:`.FieldMonitor` of the same geometry: the permittivity values are saved at the\nYee grid locations, and can be interpolated to any point inside the monitor.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\nfreqs : Union[Tuple[float, ...], Array]\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\napodization : ApodizationSpec = ApodizationSpec(start=None, end=None, width=None, type='ApodizationSpec')\n    Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.\n\nExample\n-------\n>>> monitor = PermittivityMonitor(\n...     center=(1,2,3),\n...     size=(2,2,2),\n...     freqs=[250e12, 300e12],\n...     name='eps_monitor')",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "PermittivityMonitor",
          "enum": [
            "PermittivityMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "title": "Array Like",
              "description": "Accepts sequence (tuple, list, numpy array) and converts to tuple.",
              "type": "tuple",
              "properties": {},
              "required": []
            }
          ]
        },
        "apodization": {
          "title": "Apodization Specification",
          "description": "Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.",
          "default": {
            "start": null,
            "end": null,
            "width": null,
            "type": "ApodizationSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ApodizationSpec"
            }
          ]
        }
      },
      "required": [
        "size",
        "name",
        "freqs"
      ],
      "additionalProperties": false
    },
    "FluxMonitor": {
      "title": "FluxMonitor",
      "description": ":class:`Monitor` that records power flux in the frequency domain.\nIf the monitor geometry is a 2D box, the total flux through this plane is returned, with a\npositive sign corresponding to power flow in the positive direction along the axis normal to\nthe plane. If the geometry is a 3D box, the total power coming out of the box is returned by\nintegrating the flux over all box surfaces (excpet the ones defined in ``exclude_surfaces``).\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\nfreqs : Union[Tuple[float, ...], Array]\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\napodization : ApodizationSpec = ApodizationSpec(start=None, end=None, width=None, type='ApodizationSpec')\n    Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.\nnormal_dir : Optional[Literal['+', '-']] = None\n    Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.\nexclude_surfaces : Optional[Tuple[Literal['x-', 'x+', 'y-', 'y+', 'z-', 'z+'], ...]] = None\n    Surfaces to exclude in the integration, if a volume monitor.\n\nExample\n-------\n>>> monitor = FluxMonitor(\n...     center=(1,2,3),\n...     size=(2,2,0),\n...     freqs=[200e12, 210e12],\n...     name='flux_monitor')",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "FluxMonitor",
          "enum": [
            "FluxMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "title": "Array Like",
              "description": "Accepts sequence (tuple, list, numpy array) and converts to tuple.",
              "type": "tuple",
              "properties": {},
              "required": []
            }
          ]
        },
        "apodization": {
          "title": "Apodization Specification",
          "description": "Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.",
          "default": {
            "start": null,
            "end": null,
            "width": null,
            "type": "ApodizationSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ApodizationSpec"
            }
          ]
        },
        "normal_dir": {
          "title": "Normal vector orientation",
          "description": "Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "exclude_surfaces": {
          "title": "Excluded surfaces",
          "description": "Surfaces to exclude in the integration, if a volume monitor.",
          "type": "array",
          "items": {
            "enum": [
              "x-",
              "x+",
              "y-",
              "y+",
              "z-",
              "z+"
            ],
            "type": "string"
          }
        }
      },
      "required": [
        "size",
        "name",
        "freqs"
      ],
      "additionalProperties": false
    },
    "FluxTimeMonitor": {
      "title": "FluxTimeMonitor",
      "description": ":class:`Monitor` that records power flux in the time domain.\nIf the monitor geometry is a 2D box, the total flux through this plane is returned, with a\npositive sign corresponding to power flow in the positive direction along the axis normal to\nthe plane. If the geometry is a 3D box, the total power coming out of the box is returned by\nintegrating the flux over all box surfaces (excpet the ones defined in ``exclude_surfaces``).\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\nstart : NonNegativeFloat = 0.0\n    [units = sec].  Time at which to start monitor recording.\nstop : Optional[NonNegativeFloat] = None\n    [units = sec].  Time at which to stop monitor recording.  If not specified, record until end of simulation.\ninterval : PositiveInt = 1\n    Number of time step intervals between monitor recordings.\nnormal_dir : Optional[Literal['+', '-']] = None\n    Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.\nexclude_surfaces : Optional[Tuple[Literal['x-', 'x+', 'y-', 'y+', 'z-', 'z+'], ...]] = None\n    Surfaces to exclude in the integration, if a volume monitor.\n\nExample\n-------\n>>> monitor = FluxTimeMonitor(\n...     center=(1,2,3),\n...     size=(2,2,0),\n...     start=1e-13,\n...     stop=5e-13,\n...     interval=2,\n...     name='flux_vs_time')",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "FluxTimeMonitor",
          "enum": [
            "FluxTimeMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "start": {
          "title": "Start time",
          "description": "Time at which to start monitor recording.",
          "default": 0.0,
          "units": "sec",
          "minimum": 0,
          "type": "number"
        },
        "stop": {
          "title": "Stop time",
          "description": "Time at which to stop monitor recording.  If not specified, record until end of simulation.",
          "units": "sec",
          "minimum": 0,
          "type": "number"
        },
        "interval": {
          "title": "Time interval",
          "description": "Number of time step intervals between monitor recordings.",
          "default": 1,
          "exclusiveMinimum": 0,
          "type": "integer"
        },
        "normal_dir": {
          "title": "Normal vector orientation",
          "description": "Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "exclude_surfaces": {
          "title": "Excluded surfaces",
          "description": "Surfaces to exclude in the integration, if a volume monitor.",
          "type": "array",
          "items": {
            "enum": [
              "x-",
              "x+",
              "y-",
              "y+",
              "z-",
              "z+"
            ],
            "type": "string"
          }
        }
      },
      "required": [
        "size",
        "name"
      ],
      "additionalProperties": false
    },
    "ModeMonitor": {
      "title": "ModeMonitor",
      "description": ":class:`Monitor` that records amplitudes from modal decomposition of fields on plane.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\nfreqs : Union[Tuple[float, ...], Array]\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\napodization : ApodizationSpec = ApodizationSpec(start=None, end=None, width=None, type='ApodizationSpec')\n    Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.\nmode_spec : ModeSpec\n    Parameters to feed to mode solver which determine modes measured by monitor.\n\nExample\n-------\n>>> mode_spec = ModeSpec(num_modes=3)\n>>> monitor = ModeMonitor(\n...     center=(1,2,3),\n...     size=(2,2,0),\n...     freqs=[200e12, 210e12],\n...     mode_spec=mode_spec,\n...     name='mode_monitor')",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "ModeMonitor",
          "enum": [
            "ModeMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "title": "Array Like",
              "description": "Accepts sequence (tuple, list, numpy array) and converts to tuple.",
              "type": "tuple",
              "properties": {},
              "required": []
            }
          ]
        },
        "apodization": {
          "title": "Apodization Specification",
          "description": "Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.",
          "default": {
            "start": null,
            "end": null,
            "width": null,
            "type": "ApodizationSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ApodizationSpec"
            }
          ]
        },
        "mode_spec": {
          "title": "Mode Specification",
          "description": "Parameters to feed to mode solver which determine modes measured by monitor.",
          "allOf": [
            {
              "$ref": "#/definitions/ModeSpec"
            }
          ]
        }
      },
      "required": [
        "size",
        "name",
        "freqs",
        "mode_spec"
      ],
      "additionalProperties": false
    },
    "ModeSolverMonitor": {
      "title": "ModeSolverMonitor",
      "description": ":class:`Monitor` that stores the mode field profiles returned by the mode solver in the\nmonitor plane.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\nfreqs : Union[Tuple[float, ...], Array]\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\napodization : ApodizationSpec = ApodizationSpec(start=None, end=None, width=None, type='ApodizationSpec')\n    Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.\nmode_spec : ModeSpec\n    Parameters to feed to mode solver which determine modes measured by monitor.\n\nExample\n-------\n>>> mode_spec = ModeSpec(num_modes=3)\n>>> monitor = ModeSolverMonitor(\n...     center=(1,2,3),\n...     size=(2,2,0),\n...     freqs=[200e12, 210e12],\n...     mode_spec=mode_spec,\n...     name='mode_monitor')",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "ModeSolverMonitor",
          "enum": [
            "ModeSolverMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "title": "Array Like",
              "description": "Accepts sequence (tuple, list, numpy array) and converts to tuple.",
              "type": "tuple",
              "properties": {},
              "required": []
            }
          ]
        },
        "apodization": {
          "title": "Apodization Specification",
          "description": "Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.",
          "default": {
            "start": null,
            "end": null,
            "width": null,
            "type": "ApodizationSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ApodizationSpec"
            }
          ]
        },
        "mode_spec": {
          "title": "Mode Specification",
          "description": "Parameters to feed to mode solver which determine modes measured by monitor.",
          "allOf": [
            {
              "$ref": "#/definitions/ModeSpec"
            }
          ]
        }
      },
      "required": [
        "size",
        "name",
        "freqs",
        "mode_spec"
      ],
      "additionalProperties": false
    },
    "FieldProjectionAngleMonitor": {
      "title": "FieldProjectionAngleMonitor",
      "description": ":class:`Monitor` that samples electromagnetic near fields in the frequency domain\nand projects them at given observation angles.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\nfreqs : Union[Tuple[float, ...], Array]\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\napodization : ApodizationSpec = ApodizationSpec(start=None, end=None, width=None, type='ApodizationSpec')\n    Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.\nnormal_dir : Optional[Literal['+', '-']] = None\n    Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.\nexclude_surfaces : Optional[Tuple[Literal['x-', 'x+', 'y-', 'y+', 'z-', 'z+'], ...]] = None\n    Surfaces to exclude in the integration, if a volume monitor.\ncustom_origin : Optional[Tuple[float, float, float]] = None\n    [units = um].  Local origin used for defining observation points. If ``None``, uses the monitor's center.\nfar_field_approx : bool = True\n    Whether to enable the far field approximation when projecting fields.\nproj_distance : float = 1000000.0\n    [units = um].  Radial distance of the projection points from ``local_origin``.\ntheta : Union[Tuple[float, ...], Array]\n    [units = rad].  Polar angles with respect to the global z axis, relative to the location of ``local_origin``, at which to project fields.\nphi : Union[Tuple[float, ...], Array]\n    [units = rad].  Azimuth angles with respect to the global z axis, relative to the location of ``local_origin``, at which to project fields.\n\nExample\n-------\n>>> monitor = FieldProjectionAngleMonitor(\n...     center=(1,2,3),\n...     size=(2,2,2),\n...     freqs=[250e12, 300e12],\n...     name='n2f_monitor',\n...     custom_origin=(1,2,3),\n...     phi=[0, np.pi/2],\n...     theta=np.linspace(-np.pi/2, np.pi/2, 100)\n...     )",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "FieldProjectionAngleMonitor",
          "enum": [
            "FieldProjectionAngleMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "title": "Array Like",
              "description": "Accepts sequence (tuple, list, numpy array) and converts to tuple.",
              "type": "tuple",
              "properties": {},
              "required": []
            }
          ]
        },
        "apodization": {
          "title": "Apodization Specification",
          "description": "Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.",
          "default": {
            "start": null,
            "end": null,
            "width": null,
            "type": "ApodizationSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ApodizationSpec"
            }
          ]
        },
        "normal_dir": {
          "title": "Normal vector orientation",
          "description": "Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "exclude_surfaces": {
          "title": "Excluded surfaces",
          "description": "Surfaces to exclude in the integration, if a volume monitor.",
          "type": "array",
          "items": {
            "enum": [
              "x-",
              "x+",
              "y-",
              "y+",
              "z-",
              "z+"
            ],
            "type": "string"
          }
        },
        "custom_origin": {
          "title": "Local origin",
          "description": "Local origin used for defining observation points. If ``None``, uses the monitor's center.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "far_field_approx": {
          "title": "Far field approximation",
          "description": "Whether to enable the far field approximation when projecting fields.",
          "default": true,
          "type": "boolean"
        },
        "proj_distance": {
          "title": "Projection distance",
          "description": "Radial distance of the projection points from ``local_origin``.",
          "default": 1000000.0,
          "units": "um",
          "type": "number"
        },
        "theta": {
          "title": "Polar angles",
          "description": "Polar angles with respect to the global z axis, relative to the location of ``local_origin``, at which to project fields.",
          "units": "rad",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "title": "Array Like",
              "description": "Accepts sequence (tuple, list, numpy array) and converts to tuple.",
              "type": "tuple",
              "properties": {},
              "required": []
            }
          ]
        },
        "phi": {
          "title": "Azimuth angles",
          "description": "Azimuth angles with respect to the global z axis, relative to the location of ``local_origin``, at which to project fields.",
          "units": "rad",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "title": "Array Like",
              "description": "Accepts sequence (tuple, list, numpy array) and converts to tuple.",
              "type": "tuple",
              "properties": {},
              "required": []
            }
          ]
        }
      },
      "required": [
        "size",
        "name",
        "freqs",
        "theta",
        "phi"
      ],
      "additionalProperties": false
    },
    "FieldProjectionCartesianMonitor": {
      "title": "FieldProjectionCartesianMonitor",
      "description": ":class:`Monitor` that samples electromagnetic near fields in the frequency domain\nand projects them on a Cartesian observation plane.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\nfreqs : Union[Tuple[float, ...], Array]\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\napodization : ApodizationSpec = ApodizationSpec(start=None, end=None, width=None, type='ApodizationSpec')\n    Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.\nnormal_dir : Optional[Literal['+', '-']] = None\n    Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.\nexclude_surfaces : Optional[Tuple[Literal['x-', 'x+', 'y-', 'y+', 'z-', 'z+'], ...]] = None\n    Surfaces to exclude in the integration, if a volume monitor.\ncustom_origin : Optional[Tuple[float, float, float]] = None\n    [units = um].  Local origin used for defining observation points. If ``None``, uses the monitor's center.\nfar_field_approx : bool = True\n    Whether to enable the far field approximation when projecting fields.\nproj_axis : Literal[0, 1, 2]\n    Axis along which the observation plane is oriented.\nproj_distance : float = 1000000.0\n    [units = um].  Signed distance of the projection plane along ``proj_axis``. from the plane containing ``local_origin``.\nx : Union[Tuple[float, ...], Array]\n    [units = um].  Local x observation coordinates w.r.t. ``local_origin`` and ``proj_axis``. When ``proj_axis`` is 0, this corresponds to the global y axis. When ``proj_axis`` is 1, this corresponds to the global x axis. When ``proj_axis`` is 2, this corresponds to the global x axis. \ny : Union[Tuple[float, ...], Array]\n    [units = um].  Local y observation coordinates w.r.t. ``local_origin`` and ``proj_axis``. When ``proj_axis`` is 0, this corresponds to the global z axis. When ``proj_axis`` is 1, this corresponds to the global z axis. When ``proj_axis`` is 2, this corresponds to the global y axis. \n\nExample\n-------\n>>> monitor = FieldProjectionCartesianMonitor(\n...     center=(1,2,3),\n...     size=(2,2,2),\n...     freqs=[250e12, 300e12],\n...     name='n2f_monitor',\n...     custom_origin=(1,2,3),\n...     x=[-1, 0, 1],\n...     y=[-2, -1, 0, 1, 2],\n...     proj_axis=2,\n...     proj_distance=5\n...     )",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "FieldProjectionCartesianMonitor",
          "enum": [
            "FieldProjectionCartesianMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "title": "Array Like",
              "description": "Accepts sequence (tuple, list, numpy array) and converts to tuple.",
              "type": "tuple",
              "properties": {},
              "required": []
            }
          ]
        },
        "apodization": {
          "title": "Apodization Specification",
          "description": "Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.",
          "default": {
            "start": null,
            "end": null,
            "width": null,
            "type": "ApodizationSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ApodizationSpec"
            }
          ]
        },
        "normal_dir": {
          "title": "Normal vector orientation",
          "description": "Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "exclude_surfaces": {
          "title": "Excluded surfaces",
          "description": "Surfaces to exclude in the integration, if a volume monitor.",
          "type": "array",
          "items": {
            "enum": [
              "x-",
              "x+",
              "y-",
              "y+",
              "z-",
              "z+"
            ],
            "type": "string"
          }
        },
        "custom_origin": {
          "title": "Local origin",
          "description": "Local origin used for defining observation points. If ``None``, uses the monitor's center.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "far_field_approx": {
          "title": "Far field approximation",
          "description": "Whether to enable the far field approximation when projecting fields.",
          "default": true,
          "type": "boolean"
        },
        "proj_axis": {
          "title": "Projection plane axis",
          "description": "Axis along which the observation plane is oriented.",
          "enum": [
            0,
            1,
            2
          ],
          "type": "integer"
        },
        "proj_distance": {
          "title": "Projection distance",
          "description": "Signed distance of the projection plane along ``proj_axis``. from the plane containing ``local_origin``.",
          "default": 1000000.0,
          "units": "um",
          "type": "number"
        },
        "x": {
          "title": "Local x observation coordinates",
          "description": "Local x observation coordinates w.r.t. ``local_origin`` and ``proj_axis``. When ``proj_axis`` is 0, this corresponds to the global y axis. When ``proj_axis`` is 1, this corresponds to the global x axis. When ``proj_axis`` is 2, this corresponds to the global x axis. ",
          "units": "um",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "title": "Array Like",
              "description": "Accepts sequence (tuple, list, numpy array) and converts to tuple.",
              "type": "tuple",
              "properties": {},
              "required": []
            }
          ]
        },
        "y": {
          "title": "Local y observation coordinates",
          "description": "Local y observation coordinates w.r.t. ``local_origin`` and ``proj_axis``. When ``proj_axis`` is 0, this corresponds to the global z axis. When ``proj_axis`` is 1, this corresponds to the global z axis. When ``proj_axis`` is 2, this corresponds to the global y axis. ",
          "units": "um",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "title": "Array Like",
              "description": "Accepts sequence (tuple, list, numpy array) and converts to tuple.",
              "type": "tuple",
              "properties": {},
              "required": []
            }
          ]
        }
      },
      "required": [
        "size",
        "name",
        "freqs",
        "proj_axis",
        "x",
        "y"
      ],
      "additionalProperties": false
    },
    "FieldProjectionKSpaceMonitor": {
      "title": "FieldProjectionKSpaceMonitor",
      "description": ":class:`Monitor` that samples electromagnetic near fields in the frequency domain\nand projects them on an observation plane defined in k-space.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\nfreqs : Union[Tuple[float, ...], Array]\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\napodization : ApodizationSpec = ApodizationSpec(start=None, end=None, width=None, type='ApodizationSpec')\n    Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.\nnormal_dir : Optional[Literal['+', '-']] = None\n    Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.\nexclude_surfaces : Optional[Tuple[Literal['x-', 'x+', 'y-', 'y+', 'z-', 'z+'], ...]] = None\n    Surfaces to exclude in the integration, if a volume monitor.\ncustom_origin : Optional[Tuple[float, float, float]] = None\n    [units = um].  Local origin used for defining observation points. If ``None``, uses the monitor's center.\nfar_field_approx : bool = True\n    Whether to enable the far field approximation when projecting fields.\nproj_axis : Literal[0, 1, 2]\n    Axis along which the observation plane is oriented.\nproj_distance : float = 1000000.0\n    [units = um].  Radial distance of the projection points from ``local_origin``.\nux : Union[Tuple[float, ...], Array]\n    Local x component of wave vectors on the observation plane, relative to ``local_origin`` and oriented with respect to ``proj_axis``, normalized by (2*pi/lambda) where lambda is the wavelength associated with the background medium. Must be in the range [-1, 1].\nuy : Union[Tuple[float, ...], Array]\n    Local y component of wave vectors on the observation plane, relative to ``local_origin`` and oriented with respect to ``proj_axis``, normalized by (2*pi/lambda) where lambda is the wavelength associated with the background medium. Must be in the range [-1, 1].\n\nExample\n-------\n>>> monitor = FieldProjectionKSpaceMonitor(\n...     center=(1,2,3),\n...     size=(2,2,2),\n...     freqs=[250e12, 300e12],\n...     name='n2f_monitor',\n...     custom_origin=(1,2,3),\n...     proj_axis=2,\n...     ux=[0.1,0.2],\n...     uy=[0.3,0.4,0.5]\n...     )",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "FieldProjectionKSpaceMonitor",
          "enum": [
            "FieldProjectionKSpaceMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "title": "Array Like",
              "description": "Accepts sequence (tuple, list, numpy array) and converts to tuple.",
              "type": "tuple",
              "properties": {},
              "required": []
            }
          ]
        },
        "apodization": {
          "title": "Apodization Specification",
          "description": "Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.",
          "default": {
            "start": null,
            "end": null,
            "width": null,
            "type": "ApodizationSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ApodizationSpec"
            }
          ]
        },
        "normal_dir": {
          "title": "Normal vector orientation",
          "description": "Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Applies to surface monitors only, and defaults to ``'+'`` if not provided.",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        },
        "exclude_surfaces": {
          "title": "Excluded surfaces",
          "description": "Surfaces to exclude in the integration, if a volume monitor.",
          "type": "array",
          "items": {
            "enum": [
              "x-",
              "x+",
              "y-",
              "y+",
              "z-",
              "z+"
            ],
            "type": "string"
          }
        },
        "custom_origin": {
          "title": "Local origin",
          "description": "Local origin used for defining observation points. If ``None``, uses the monitor's center.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "far_field_approx": {
          "title": "Far field approximation",
          "description": "Whether to enable the far field approximation when projecting fields.",
          "default": true,
          "type": "boolean"
        },
        "proj_axis": {
          "title": "Projection plane axis",
          "description": "Axis along which the observation plane is oriented.",
          "enum": [
            0,
            1,
            2
          ],
          "type": "integer"
        },
        "proj_distance": {
          "title": "Projection distance",
          "description": "Radial distance of the projection points from ``local_origin``.",
          "default": 1000000.0,
          "units": "um",
          "type": "number"
        },
        "ux": {
          "title": "Normalized kx",
          "description": "Local x component of wave vectors on the observation plane, relative to ``local_origin`` and oriented with respect to ``proj_axis``, normalized by (2*pi/lambda) where lambda is the wavelength associated with the background medium. Must be in the range [-1, 1].",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "title": "Array Like",
              "description": "Accepts sequence (tuple, list, numpy array) and converts to tuple.",
              "type": "tuple",
              "properties": {},
              "required": []
            }
          ]
        },
        "uy": {
          "title": "Normalized ky",
          "description": "Local y component of wave vectors on the observation plane, relative to ``local_origin`` and oriented with respect to ``proj_axis``, normalized by (2*pi/lambda) where lambda is the wavelength associated with the background medium. Must be in the range [-1, 1].",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "title": "Array Like",
              "description": "Accepts sequence (tuple, list, numpy array) and converts to tuple.",
              "type": "tuple",
              "properties": {},
              "required": []
            }
          ]
        }
      },
      "required": [
        "size",
        "name",
        "freqs",
        "proj_axis",
        "ux",
        "uy"
      ],
      "additionalProperties": false
    },
    "DiffractionMonitor": {
      "title": "DiffractionMonitor",
      "description": ":class:`Monitor` that uses a 2D Fourier transform to compute the\ndiffraction amplitudes and efficiency for allowed diffraction orders.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for monitor.\nfreqs : Union[Tuple[float, ...], Array]\n    [units = Hz].  Array or list of frequencies stored by the field monitor.\napodization : ApodizationSpec = ApodizationSpec(start=None, end=None, width=None, type='ApodizationSpec')\n    Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.\nnormal_dir : Literal['+', '-'] = +\n    Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Defaults to ``'+'`` if not provided.\n\nExample\n-------\n>>> monitor = DiffractionMonitor(\n...     center=(1,2,3),\n...     size=(inf,inf,0),\n...     freqs=[250e12, 300e12],\n...     name='diffraction_monitor',\n...     normal_dir='+',\n...     )",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "DiffractionMonitor",
          "enum": [
            "DiffractionMonitor"
          ],
          "type": "string"
        },
        "center": {
          "title": "Center",
          "description": "Center of object in x, y, and z.",
          "default": [
            0.0,
            0.0,
            0.0
          ],
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ]
        },
        "size": {
          "title": "Size",
          "description": "Size in x, y, and z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            },
            {
              "type": "number",
              "minimum": 0
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Unique name for monitor.",
          "minLength": 1,
          "type": "string"
        },
        "freqs": {
          "title": "Frequencies",
          "description": "Array or list of frequencies stored by the field monitor.",
          "units": "Hz",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            {
              "title": "Array Like",
              "description": "Accepts sequence (tuple, list, numpy array) and converts to tuple.",
              "type": "tuple",
              "properties": {},
              "required": []
            }
          ]
        },
        "apodization": {
          "title": "Apodization Specification",
          "description": "Sets parameters of (optional) apodization. Apodization applies a windowing function to the Fourier transform of the time-domain fields into frequency-domain ones, and can be used to truncate the beginning and/or end of the time signal, for example to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization affects the normalization of the frequency-domain fields.",
          "default": {
            "start": null,
            "end": null,
            "width": null,
            "type": "ApodizationSpec"
          },
          "allOf": [
            {
              "$ref": "#/definitions/ApodizationSpec"
            }
          ]
        },
        "normal_dir": {
          "title": "Normal vector orientation",
          "description": "Direction of the surface monitor's normal vector w.r.t. the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. Defaults to ``'+'`` if not provided.",
          "default": "+",
          "enum": [
            "+",
            "-"
          ],
          "type": "string"
        }
      },
      "required": [
        "size",
        "name",
        "freqs"
      ],
      "additionalProperties": false
    },
    "UniformGrid": {
      "title": "UniformGrid",
      "description": "Uniform 1D grid.\n\nParameters\n----------\ndl : PositiveFloat\n    [units = um].  Grid size for uniform grid generation.\n\nExample\n-------\n>>> grid_1d = UniformGrid(dl=0.1)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "UniformGrid",
          "enum": [
            "UniformGrid"
          ],
          "type": "string"
        },
        "dl": {
          "title": "Grid Size",
          "description": "Grid size for uniform grid generation.",
          "units": "um",
          "exclusiveMinimum": 0,
          "type": "number"
        }
      },
      "required": [
        "dl"
      ],
      "additionalProperties": false
    },
    "CustomGrid": {
      "title": "CustomGrid",
      "description": "Custom 1D grid supplied as a list of grid cell sizes centered on the simulation center.\n\nParameters\n----------\ndl : Tuple[PositiveFloat, ...]\n    [units = um].  An array of custom nonuniform grid sizes. The resulting grid is centered on the simulation center such that it spans the region ``(center - sum(dl)/2, center + sum(dl)/2)``. Note: if supplied sizes do not cover the simulation size, the first and last sizes are repeated to cover the simulation domain.\n\nExample\n-------\n>>> grid_1d = CustomGrid(dl=[0.2, 0.2, 0.1, 0.1, 0.1, 0.2, 0.2])",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "CustomGrid",
          "enum": [
            "CustomGrid"
          ],
          "type": "string"
        },
        "dl": {
          "title": "Customized grid sizes.",
          "description": "An array of custom nonuniform grid sizes. The resulting grid is centered on the simulation center such that it spans the region ``(center - sum(dl)/2, center + sum(dl)/2)``. Note: if supplied sizes do not cover the simulation size, the first and last sizes are repeated to cover the simulation domain.",
          "units": "um",
          "type": "array",
          "items": {
            "type": "number",
            "exclusiveMinimum": 0
          }
        }
      },
      "required": [
        "dl"
      ],
      "additionalProperties": false
    },
    "GradedMesher": {
      "title": "GradedMesher",
      "description": "Implements automatic nonuniform meshing with a set minimum steps per wavelength and\na graded mesh expanding from higher- to lower-resolution regions.\n\nParameters\n----------",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "GradedMesher",
          "enum": [
            "GradedMesher"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "AutoGrid": {
      "title": "AutoGrid",
      "description": "Specification for non-uniform grid along a given dimension.\n\nParameters\n----------\nmin_steps_per_wvl : ConstrainedFloatValue = 10.0\n    Minimal number of steps per wavelength in each medium.\nmax_scale : ConstrainedFloatValue = 1.4\n    Sets the maximum ratio between any two consecutive grid steps.\ndl_min : NonNegativeFloat = 0\n    Lower bound of the grid size along this dimension regardless of structures present in the simulation, including override structures with ``enforced=True``. It is a soft bound, meaning that the actual minimal grid size might be slightly smaller.\nmesher : GradedMesher = GradedMesher(type='GradedMesher')\n    The type of mesher to use to generate the grid automatically.\n\nExample\n-------\n>>> grid_1d = AutoGrid(min_steps_per_wvl=16, max_scale=1.4)",
      "type": "object",
      "properties": {
        "type": {
          "title": "Type",
          "default": "AutoGrid",
          "enum": [
            "AutoGrid"
          ],
          "type": "string"
        },
        "min_steps_per_wvl": {
          "title": "Minimal number of steps per wavelength",
          "description": "Minimal number of steps per wavelength in each medium.",
          "default": 10.0,
          "minimum": 6.0,
          "type": "number"
        },
        "max_scale": {
          "title": "Maximum Grid Size Scaling",
          "description": "Sets the maximum ratio between any two consecutive grid steps.",
          "default": 1.4,
          "exclusiveMaximum": 2.0,
          "minimum": 1.2,
          "type": "number"
        },
        "dl_min": {
          "title": "Lower bound of grid size",
          "description": "Lower bound of the grid size along this dimension regardless of structures present in the simulation, including override structures with ``enforced=True``. It is a soft bound, meaning that the actual minimal grid size might be slightly smaller.",
          "default": 0,
          "minimum": 0,
          "type": "number"
        },
        "mesher": {
          "title": "Grid Construction Tool",
          "description": "The type of mesher to use to generate the grid automatically.",
          "default": {
            "type": "GradedMesher"
          },
          "allOf": [
            {
              "$ref": "#/definitions/GradedMesher"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "MeshOverrideStructure": {
      "title": "MeshOverrideStructure",
      "description": "Defines an object that is only used in the process of generating the mesh.\nA :class:`MeshOverrideStructure` is a combination of geometry :class:`Geometry`,\ngrid size along x,y,z directions, and a boolean on whether the override\nwill be enforced.\n\nParameters\n----------\ngeometry : Union[Box, Sphere, Cylinder, PolySlab, GeometryGroup]\n    Defines geometric properties of the structure.\nname : Optional[str] = None\n    Optional name for the structure.\ndl : Tuple[PositiveFloat, PositiveFloat, PositiveFloat]\n    [units = um].  Grid size along x, y, z directions.\nenforce : bool = False\n    If ``True``, enforce the grid size setup inside the structure even if the structure is inside a structure of smaller grid size. In the intersection region of multiple structures of ``enforce=True``, grid size is decided by the last added structure of ``enforce=True``.\n\nExample\n-------\n>>> from tidy3d import Box\n>>> box = Box(center=(0,0,1), size=(2, 2, 2))\n>>> struct_override = MeshOverrideStructure(geometry=box, dl=(0.1,0.2,0.3), name='override_box')",
      "type": "object",
      "properties": {
        "geometry": {
          "title": "Geometry",
          "description": "Defines geometric properties of the structure.",
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "Box": "#/definitions/Box",
              "Sphere": "#/definitions/Sphere",
              "Cylinder": "#/definitions/Cylinder",
              "PolySlab": "#/definitions/PolySlab",
              "GeometryGroup": "#/definitions/GeometryGroup"
            }
          },
          "oneOf": [
            {
              "$ref": "#/definitions/Box"
            },
            {
              "$ref": "#/definitions/Sphere"
            },
            {
              "$ref": "#/definitions/Cylinder"
            },
            {
              "$ref": "#/definitions/PolySlab"
            },
            {
              "$ref": "#/definitions/GeometryGroup"
            }
          ]
        },
        "name": {
          "title": "Name",
          "description": "Optional name for the structure.",
          "type": "string"
        },
        "type": {
          "title": "Type",
          "default": "MeshOverrideStructure",
          "enum": [
            "MeshOverrideStructure"
          ],
          "type": "string"
        },
        "dl": {
          "title": "Grid Size",
          "description": "Grid size along x, y, z directions.",
          "units": "um",
          "type": "array",
          "minItems": 3,
          "maxItems": 3,
          "items": [
            {
              "type": "number",
              "exclusiveMinimum": 0
            },
            {
              "type": "number",
              "exclusiveMinimum": 0
            },
            {
              "type": "number",
              "exclusiveMinimum": 0
            }
          ]
        },
        "enforce": {
          "title": "Enforce grid size",
          "description": "If ``True``, enforce the grid size setup inside the structure even if the structure is inside a structure of smaller grid size. In the intersection region of multiple structures of ``enforce=True``, grid size is decided by the last added structure of ``enforce=True``.",
          "default": false,
          "type": "boolean"
        }
      },
      "required": [
        "geometry",
        "dl"
      ],
      "additionalProperties": false
    },
    "GridSpec": {
      "title": "GridSpec",
      "description": "Collective grid specification for all three dimensions.\n\nParameters\n----------\ngrid_x : Union[UniformGrid, CustomGrid, AutoGrid] = AutoGrid(type='AutoGrid', min_steps_per_wvl=10.0, max_scale=1.4, dl_min=0.0, mesher=GradedMesher(type='GradedMesher'))\n    Grid specification along x-axis\ngrid_y : Union[UniformGrid, CustomGrid, AutoGrid] = AutoGrid(type='AutoGrid', min_steps_per_wvl=10.0, max_scale=1.4, dl_min=0.0, mesher=GradedMesher(type='GradedMesher'))\n    Grid specification along y-axis\ngrid_z : Union[UniformGrid, CustomGrid, AutoGrid] = AutoGrid(type='AutoGrid', min_steps_per_wvl=10.0, max_scale=1.4, dl_min=0.0, mesher=GradedMesher(type='GradedMesher'))\n    Grid specification along z-axis\nwavelength : Optional[float] = None\n    [units = um].  Free-space wavelength for automatic nonuniform grid. It can be 'None' if there is at least one source in the simulation, in which case it is defined by the source central frequency.\noverride_structures : Tuple[Annotated[Union[tidy3d.components.structure.Structure, tidy3d.components.structure.MeshOverrideStructure], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})], ...] = ()\n    A set of structures that is added on top of the simulation structures in the process of generating the grid. This can be used to refine the grid or make it coarser depending than the expected need for higher/lower resolution regions.\n\nExample\n-------\n>>> uniform = UniformGrid(dl=0.1)\n>>> custom = CustomGrid(dl=[0.2, 0.2, 0.1, 0.1, 0.1, 0.2, 0.2])\n>>> auto = AutoGrid(min_steps_per_wvl=12)\n>>> grid_spec = GridSpec(grid_x=uniform, grid_y=custom, grid_z=auto, wavelength=1.5)",
      "type": "object",
      "properties": {
        "grid_x": {
          "title": "Grid specification along x-axis",
          "description": "Grid specification along x-axis",
          "default": {
            "type": "AutoGrid",
            "min_steps_per_wvl": 10.0,
            "max_scale": 1.4,
            "dl_min": 0.0,
            "mesher": {
              "type": "GradedMesher"
            }
          },
          "anyOf": [
            {
              "$ref": "#/definitions/UniformGrid"
            },
            {
              "$ref": "#/definitions/CustomGrid"
            },
            {
              "$ref": "#/definitions/AutoGrid"
            }
          ]
        },
        "grid_y": {
          "title": "Grid specification along y-axis",
          "description": "Grid specification along y-axis",
          "default": {
            "type": "AutoGrid",
            "min_steps_per_wvl": 10.0,
            "max_scale": 1.4,
            "dl_min": 0.0,
            "mesher": {
              "type": "GradedMesher"
            }
          },
          "anyOf": [
            {
              "$ref": "#/definitions/UniformGrid"
            },
            {
              "$ref": "#/definitions/CustomGrid"
            },
            {
              "$ref": "#/definitions/AutoGrid"
            }
          ]
        },
        "grid_z": {
          "title": "Grid specification along z-axis",
          "description": "Grid specification along z-axis",
          "default": {
            "type": "AutoGrid",
            "min_steps_per_wvl": 10.0,
            "max_scale": 1.4,
            "dl_min": 0.0,
            "mesher": {
              "type": "GradedMesher"
            }
          },
          "anyOf": [
            {
              "$ref": "#/definitions/UniformGrid"
            },
            {
              "$ref": "#/definitions/CustomGrid"
            },
            {
              "$ref": "#/definitions/AutoGrid"
            }
          ]
        },
        "wavelength": {
          "title": "Free-space wavelength",
          "description": "Free-space wavelength for automatic nonuniform grid. It can be 'None' if there is at least one source in the simulation, in which case it is defined by the source central frequency.",
          "units": "um",
          "type": "number"
        },
        "override_structures": {
          "title": "Grid specification override structures",
          "description": "A set of structures that is added on top of the simulation structures in the process of generating the grid. This can be used to refine the grid or make it coarser depending than the expected need for higher/lower resolution regions.",
          "default": [],
          "type": "array",
          "items": {
            "discriminator": {
              "propertyName": "type",
              "mapping": {
                "Structure": "#/definitions/Structure",
                "MeshOverrideStructure": "#/definitions/MeshOverrideStructure"
              }
            },
            "oneOf": [
              {
                "$ref": "#/definitions/Structure"
              },
              {
                "$ref": "#/definitions/MeshOverrideStructure"
              }
            ]
          }
        },
        "type": {
          "title": "Type",
          "default": "GridSpec",
          "enum": [
            "GridSpec"
          ],
          "type": "string"
        }
      },
      "additionalProperties": false
    }
  }
}